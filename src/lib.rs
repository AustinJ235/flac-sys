/* automatically generated by rust-bindgen */

#[link(name = "flac")] extern { }

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const FLAC_API_VERSION_CURRENT: u32 = 11;
pub const FLAC_API_VERSION_REVISION: u32 = 0;
pub const FLAC_API_VERSION_AGE: u32 = 3;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 29;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __FD_ZERO_STOS: &'static [u8; 6usize] = b"stosq\0";
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const __PTHREAD_MUTEX_LOCK_ELISION: u32 = 1;
pub const __PTHREAD_MUTEX_NUSERS_AFTER_KIND: u32 = 0;
pub const __PTHREAD_MUTEX_USE_UNION: u32 = 0;
pub const __PTHREAD_RWLOCK_INT_FLAGS_SHARED: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const FLAC__MAX_METADATA_TYPE_CODE: u32 = 126;
pub const FLAC__MIN_BLOCK_SIZE: u32 = 16;
pub const FLAC__MAX_BLOCK_SIZE: u32 = 65535;
pub const FLAC__SUBSET_MAX_BLOCK_SIZE_48000HZ: u32 = 4608;
pub const FLAC__MAX_CHANNELS: u32 = 8;
pub const FLAC__MIN_BITS_PER_SAMPLE: u32 = 4;
pub const FLAC__MAX_BITS_PER_SAMPLE: u32 = 32;
pub const FLAC__REFERENCE_CODEC_MAX_BITS_PER_SAMPLE: u32 = 24;
pub const FLAC__MAX_SAMPLE_RATE: u32 = 655350;
pub const FLAC__MAX_LPC_ORDER: u32 = 32;
pub const FLAC__SUBSET_MAX_LPC_ORDER_48000HZ: u32 = 12;
pub const FLAC__MIN_QLP_COEFF_PRECISION: u32 = 5;
pub const FLAC__MAX_QLP_COEFF_PRECISION: u32 = 15;
pub const FLAC__MAX_FIXED_ORDER: u32 = 4;
pub const FLAC__MAX_RICE_PARTITION_ORDER: u32 = 15;
pub const FLAC__SUBSET_MAX_RICE_PARTITION_ORDER: u32 = 8;
pub const FLAC__STREAM_SYNC_LENGTH: u32 = 4;
pub const FLAC__STREAM_METADATA_STREAMINFO_LENGTH: u32 = 34;
pub const FLAC__STREAM_METADATA_SEEKPOINT_LENGTH: u32 = 18;
pub const FLAC__STREAM_METADATA_HEADER_LENGTH: u32 = 4;
pub const _STDIO_H: u32 = 1;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
extern "C" {
    #[link_name = "\u{1}FLAC_API_SUPPORTS_OGG_FLAC"]
    pub static mut FLAC_API_SUPPORTS_OGG_FLAC: ::std::os::raw::c_int;
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type FLAC__int8 = i8;
pub type FLAC__uint8 = u8;
pub type FLAC__int16 = i16;
pub type FLAC__int32 = i32;
pub type FLAC__int64 = i64;
pub type FLAC__uint16 = u16;
pub type FLAC__uint32 = u32;
pub type FLAC__uint64 = u64;
pub type FLAC__bool = ::std::os::raw::c_int;
pub type FLAC__byte = FLAC__uint8;
pub type wchar_t = ::std::os::raw::c_int;
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulong;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __bindgen_anon_1: __pthread_cond_s__bindgen_ty_1,
    pub __bindgen_anon_2: __pthread_cond_s__bindgen_ty_2,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_1 {
    pub __wseq: ::std::os::raw::c_ulonglong,
    pub __wseq32: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_2 {
    pub __g1_start: ::std::os::raw::c_ulonglong,
    pub __g1_start32: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 5usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
    _bindgen_union_align: [u64; 6usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: u64,
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(__alignment: usize, __size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(__func: ::std::os::raw::c_int, __arg: *mut ::std::os::raw::c_void),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
#[doc = " This is the opaque handle type used by the callbacks.  Typically"]
#[doc = "  this is a \\c FILE* or address of a file descriptor."]
pub type FLAC__IOHandle = *mut ::std::os::raw::c_void;
#[doc = " Signature for the read callback."]
#[doc = "  The signature and semantics match POSIX fread() implementations"]
#[doc = "  and can generally be used interchangeably."]
#[doc = ""]
#[doc = " \\param  ptr      The address of the read buffer."]
#[doc = " \\param  size     The size of the records to be read."]
#[doc = " \\param  nmemb    The number of records to be read."]
#[doc = " \\param  handle   The handle to the data source."]
#[doc = " \\retval size_t"]
#[doc = "    The number of records read."]
pub type FLAC__IOCallback_Read = ::std::option::Option<
    unsafe extern "C" fn(
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
        nmemb: usize,
        handle: FLAC__IOHandle,
    ) -> usize,
>;
#[doc = " Signature for the write callback."]
#[doc = "  The signature and semantics match POSIX fwrite() implementations"]
#[doc = "  and can generally be used interchangeably."]
#[doc = ""]
#[doc = " \\param  ptr      The address of the write buffer."]
#[doc = " \\param  size     The size of the records to be written."]
#[doc = " \\param  nmemb    The number of records to be written."]
#[doc = " \\param  handle   The handle to the data source."]
#[doc = " \\retval size_t"]
#[doc = "    The number of records written."]
pub type FLAC__IOCallback_Write = ::std::option::Option<
    unsafe extern "C" fn(
        ptr: *const ::std::os::raw::c_void,
        size: usize,
        nmemb: usize,
        handle: FLAC__IOHandle,
    ) -> usize,
>;
#[doc = " Signature for the seek callback."]
#[doc = "  The signature and semantics mostly match POSIX fseek() WITH ONE IMPORTANT"]
#[doc = "  EXCEPTION: the offset is a 64-bit type whereas fseek() is generally \'long\'"]
#[doc = "  and 32-bits wide."]
#[doc = ""]
#[doc = " \\param  handle   The handle to the data source."]
#[doc = " \\param  offset   The new position, relative to \\a whence"]
#[doc = " \\param  whence   \\c SEEK_SET, \\c SEEK_CUR, or \\c SEEK_END"]
#[doc = " \\retval int"]
#[doc = "    \\c 0 on success, \\c -1 on error."]
pub type FLAC__IOCallback_Seek = ::std::option::Option<
    unsafe extern "C" fn(
        handle: FLAC__IOHandle,
        offset: FLAC__int64,
        whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Signature for the tell callback."]
#[doc = "  The signature and semantics mostly match POSIX ftell() WITH ONE IMPORTANT"]
#[doc = "  EXCEPTION: the offset is a 64-bit type whereas ftell() is generally \'long\'"]
#[doc = "  and 32-bits wide."]
#[doc = ""]
#[doc = " \\param  handle   The handle to the data source."]
#[doc = " \\retval FLAC__int64"]
#[doc = "    The current position on success, \\c -1 on error."]
pub type FLAC__IOCallback_Tell =
    ::std::option::Option<unsafe extern "C" fn(handle: FLAC__IOHandle) -> FLAC__int64>;
#[doc = " Signature for the EOF callback."]
#[doc = "  The signature and semantics mostly match POSIX feof() but WATCHOUT:"]
#[doc = "  on many systems, feof() is a macro, so in this case a wrapper function"]
#[doc = "  must be provided instead."]
#[doc = ""]
#[doc = " \\param  handle   The handle to the data source."]
#[doc = " \\retval int"]
#[doc = "    \\c 0 if not at end of file, nonzero if at end of file."]
pub type FLAC__IOCallback_Eof =
    ::std::option::Option<unsafe extern "C" fn(handle: FLAC__IOHandle) -> ::std::os::raw::c_int>;
#[doc = " Signature for the close callback."]
#[doc = "  The signature and semantics match POSIX fclose() implementations"]
#[doc = "  and can generally be used interchangeably."]
#[doc = ""]
#[doc = " \\param  handle   The handle to the data source."]
#[doc = " \\retval int"]
#[doc = "    \\c 0 on success, \\c EOF on error."]
pub type FLAC__IOCallback_Close =
    ::std::option::Option<unsafe extern "C" fn(handle: FLAC__IOHandle) -> ::std::os::raw::c_int>;
#[doc = " A structure for holding a set of callbacks."]
#[doc = "  Each FLAC interface that requires a FLAC__IOCallbacks structure will"]
#[doc = "  describe which of the callbacks are required.  The ones that are not"]
#[doc = "  required may be set to NULL."]
#[doc = ""]
#[doc = "  If the seek requirement for an interface is optional, you can signify that"]
#[doc = "  a data sorce is not seekable by setting the \\a seek field to \\c NULL."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__IOCallbacks {
    pub read: FLAC__IOCallback_Read,
    pub write: FLAC__IOCallback_Write,
    pub seek: FLAC__IOCallback_Seek,
    pub tell: FLAC__IOCallback_Tell,
    pub eof: FLAC__IOCallback_Eof,
    pub close: FLAC__IOCallback_Close,
}
extern "C" {
    #[link_name = "\u{1}FLAC__VERSION_STRING"]
    pub static mut FLAC__VERSION_STRING: *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}FLAC__VENDOR_STRING"]
    pub static mut FLAC__VENDOR_STRING: *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}FLAC__STREAM_SYNC_STRING"]
    pub static mut FLAC__STREAM_SYNC_STRING: [FLAC__byte; 4usize];
}
extern "C" {
    #[link_name = "\u{1}FLAC__STREAM_SYNC"]
    pub static FLAC__STREAM_SYNC: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}FLAC__STREAM_SYNC_LEN"]
    pub static FLAC__STREAM_SYNC_LEN: ::std::os::raw::c_uint;
}
pub const FLAC__EntropyCodingMethodType_FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE:
    FLAC__EntropyCodingMethodType = 0;
pub const FLAC__EntropyCodingMethodType_FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2:
    FLAC__EntropyCodingMethodType = 1;
#[doc = " An enumeration of the available entropy coding methods."]
pub type FLAC__EntropyCodingMethodType = u32;
extern "C" {
    #[link_name = "\u{1}FLAC__EntropyCodingMethodTypeString"]
    pub static mut FLAC__EntropyCodingMethodTypeString: [*const ::std::os::raw::c_char; 0usize];
}
#[doc = " Contents of a Rice partitioned residual"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__EntropyCodingMethod_PartitionedRiceContents {
    pub parameters: *mut ::std::os::raw::c_uint,
    pub raw_bits: *mut ::std::os::raw::c_uint,
    pub capacity_by_order: ::std::os::raw::c_uint,
}
#[doc = " Header for a Rice partitioned residual.  (c.f. <A HREF=\"../format.html#partitioned_rice\">format specification</A>)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__EntropyCodingMethod_PartitionedRice {
    pub order: ::std::os::raw::c_uint,
    pub contents: *const FLAC__EntropyCodingMethod_PartitionedRiceContents,
}
extern "C" {
    #[link_name = "\u{1}FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_ORDER_LEN"]
    pub static FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_ORDER_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_PARAMETER_LEN"]
    pub static FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_PARAMETER_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2_PARAMETER_LEN"]
    pub static FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2_PARAMETER_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_RAW_LEN"]
    pub static FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_RAW_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_ESCAPE_PARAMETER"]
    pub static FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_ESCAPE_PARAMETER:
        ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2_ESCAPE_PARAMETER"]
    pub static FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2_ESCAPE_PARAMETER:
        ::std::os::raw::c_uint;
}
#[doc = " Header for the entropy coding method.  (c.f. <A HREF=\"../format.html#residual\">format specification</A>)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FLAC__EntropyCodingMethod {
    pub type_: FLAC__EntropyCodingMethodType,
    pub data: FLAC__EntropyCodingMethod__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union FLAC__EntropyCodingMethod__bindgen_ty_1 {
    pub partitioned_rice: FLAC__EntropyCodingMethod_PartitionedRice,
    _bindgen_union_align: [u64; 2usize],
}
extern "C" {
    #[link_name = "\u{1}FLAC__ENTROPY_CODING_METHOD_TYPE_LEN"]
    pub static FLAC__ENTROPY_CODING_METHOD_TYPE_LEN: ::std::os::raw::c_uint;
}
#[doc = "< constant signal"]
pub const FLAC__SubframeType_FLAC__SUBFRAME_TYPE_CONSTANT: FLAC__SubframeType = 0;
#[doc = "< uncompressed signal"]
pub const FLAC__SubframeType_FLAC__SUBFRAME_TYPE_VERBATIM: FLAC__SubframeType = 1;
#[doc = "< fixed polynomial prediction"]
pub const FLAC__SubframeType_FLAC__SUBFRAME_TYPE_FIXED: FLAC__SubframeType = 2;
#[doc = "< linear prediction"]
pub const FLAC__SubframeType_FLAC__SUBFRAME_TYPE_LPC: FLAC__SubframeType = 3;
#[doc = " An enumeration of the available subframe types."]
pub type FLAC__SubframeType = u32;
extern "C" {
    #[link_name = "\u{1}FLAC__SubframeTypeString"]
    pub static mut FLAC__SubframeTypeString: [*const ::std::os::raw::c_char; 0usize];
}
#[doc = " CONSTANT subframe.  (c.f. <A HREF=\"../format.html#subframe_constant\">format specification</A>)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__Subframe_Constant {
    #[doc = "< The constant signal value."]
    pub value: FLAC__int32,
}
#[doc = " VERBATIM subframe.  (c.f. <A HREF=\"../format.html#subframe_verbatim\">format specification</A>)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__Subframe_Verbatim {
    #[doc = "< A pointer to verbatim signal."]
    pub data: *const FLAC__int32,
}
#[doc = " FIXED subframe.  (c.f. <A HREF=\"../format.html#subframe_fixed\">format specification</A>)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FLAC__Subframe_Fixed {
    pub entropy_coding_method: FLAC__EntropyCodingMethod,
    pub order: ::std::os::raw::c_uint,
    pub warmup: [FLAC__int32; 4usize],
    pub residual: *const FLAC__int32,
}
#[doc = " LPC subframe.  (c.f. <A HREF=\"../format.html#subframe_lpc\">format specification</A>)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FLAC__Subframe_LPC {
    pub entropy_coding_method: FLAC__EntropyCodingMethod,
    pub order: ::std::os::raw::c_uint,
    pub qlp_coeff_precision: ::std::os::raw::c_uint,
    pub quantization_level: ::std::os::raw::c_int,
    pub qlp_coeff: [FLAC__int32; 32usize],
    pub warmup: [FLAC__int32; 32usize],
    pub residual: *const FLAC__int32,
}
extern "C" {
    #[link_name = "\u{1}FLAC__SUBFRAME_LPC_QLP_COEFF_PRECISION_LEN"]
    pub static FLAC__SUBFRAME_LPC_QLP_COEFF_PRECISION_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}FLAC__SUBFRAME_LPC_QLP_SHIFT_LEN"]
    pub static FLAC__SUBFRAME_LPC_QLP_SHIFT_LEN: ::std::os::raw::c_uint;
}
#[doc = " FLAC subframe structure.  (c.f. <A HREF=\"../format.html#subframe\">format specification</A>)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FLAC__Subframe {
    pub type_: FLAC__SubframeType,
    pub data: FLAC__Subframe__bindgen_ty_1,
    pub wasted_bits: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union FLAC__Subframe__bindgen_ty_1 {
    pub constant: FLAC__Subframe_Constant,
    pub fixed: FLAC__Subframe_Fixed,
    pub lpc: FLAC__Subframe_LPC,
    pub verbatim: FLAC__Subframe_Verbatim,
    _bindgen_union_align: [u64; 38usize],
}
extern "C" {
    #[link_name = "\u{1}FLAC__SUBFRAME_ZERO_PAD_LEN"]
    pub static FLAC__SUBFRAME_ZERO_PAD_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}FLAC__SUBFRAME_TYPE_LEN"]
    pub static FLAC__SUBFRAME_TYPE_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}FLAC__SUBFRAME_WASTED_BITS_FLAG_LEN"]
    pub static FLAC__SUBFRAME_WASTED_BITS_FLAG_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}FLAC__SUBFRAME_TYPE_CONSTANT_BYTE_ALIGNED_MASK"]
    pub static FLAC__SUBFRAME_TYPE_CONSTANT_BYTE_ALIGNED_MASK: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}FLAC__SUBFRAME_TYPE_VERBATIM_BYTE_ALIGNED_MASK"]
    pub static FLAC__SUBFRAME_TYPE_VERBATIM_BYTE_ALIGNED_MASK: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}FLAC__SUBFRAME_TYPE_FIXED_BYTE_ALIGNED_MASK"]
    pub static FLAC__SUBFRAME_TYPE_FIXED_BYTE_ALIGNED_MASK: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}FLAC__SUBFRAME_TYPE_LPC_BYTE_ALIGNED_MASK"]
    pub static FLAC__SUBFRAME_TYPE_LPC_BYTE_ALIGNED_MASK: ::std::os::raw::c_uint;
}
#[doc = "< independent channels"]
pub const FLAC__ChannelAssignment_FLAC__CHANNEL_ASSIGNMENT_INDEPENDENT: FLAC__ChannelAssignment = 0;
#[doc = "< left+side stereo"]
pub const FLAC__ChannelAssignment_FLAC__CHANNEL_ASSIGNMENT_LEFT_SIDE: FLAC__ChannelAssignment = 1;
#[doc = "< right+side stereo"]
pub const FLAC__ChannelAssignment_FLAC__CHANNEL_ASSIGNMENT_RIGHT_SIDE: FLAC__ChannelAssignment = 2;
#[doc = "< mid+side stereo"]
pub const FLAC__ChannelAssignment_FLAC__CHANNEL_ASSIGNMENT_MID_SIDE: FLAC__ChannelAssignment = 3;
#[doc = " An enumeration of the available channel assignments."]
pub type FLAC__ChannelAssignment = u32;
extern "C" {
    #[link_name = "\u{1}FLAC__ChannelAssignmentString"]
    pub static mut FLAC__ChannelAssignmentString: [*const ::std::os::raw::c_char; 0usize];
}
#[doc = "< number contains the frame number"]
pub const FLAC__FrameNumberType_FLAC__FRAME_NUMBER_TYPE_FRAME_NUMBER: FLAC__FrameNumberType = 0;
#[doc = "< number contains the sample number of first sample in frame"]
pub const FLAC__FrameNumberType_FLAC__FRAME_NUMBER_TYPE_SAMPLE_NUMBER: FLAC__FrameNumberType = 1;
#[doc = " An enumeration of the possible frame numbering methods."]
pub type FLAC__FrameNumberType = u32;
extern "C" {
    #[link_name = "\u{1}FLAC__FrameNumberTypeString"]
    pub static mut FLAC__FrameNumberTypeString: [*const ::std::os::raw::c_char; 0usize];
}
#[doc = " FLAC frame header structure.  (c.f. <A HREF=\"../format.html#frame_header\">format specification</A>)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FLAC__FrameHeader {
    pub blocksize: ::std::os::raw::c_uint,
    pub sample_rate: ::std::os::raw::c_uint,
    pub channels: ::std::os::raw::c_uint,
    pub channel_assignment: FLAC__ChannelAssignment,
    pub bits_per_sample: ::std::os::raw::c_uint,
    pub number_type: FLAC__FrameNumberType,
    pub number: FLAC__FrameHeader__bindgen_ty_1,
    pub crc: FLAC__uint8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union FLAC__FrameHeader__bindgen_ty_1 {
    pub frame_number: FLAC__uint32,
    pub sample_number: FLAC__uint64,
    _bindgen_union_align: u64,
}
extern "C" {
    #[link_name = "\u{1}FLAC__FRAME_HEADER_SYNC"]
    pub static FLAC__FRAME_HEADER_SYNC: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}FLAC__FRAME_HEADER_SYNC_LEN"]
    pub static FLAC__FRAME_HEADER_SYNC_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}FLAC__FRAME_HEADER_RESERVED_LEN"]
    pub static FLAC__FRAME_HEADER_RESERVED_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}FLAC__FRAME_HEADER_BLOCKING_STRATEGY_LEN"]
    pub static FLAC__FRAME_HEADER_BLOCKING_STRATEGY_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}FLAC__FRAME_HEADER_BLOCK_SIZE_LEN"]
    pub static FLAC__FRAME_HEADER_BLOCK_SIZE_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}FLAC__FRAME_HEADER_SAMPLE_RATE_LEN"]
    pub static FLAC__FRAME_HEADER_SAMPLE_RATE_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}FLAC__FRAME_HEADER_CHANNEL_ASSIGNMENT_LEN"]
    pub static FLAC__FRAME_HEADER_CHANNEL_ASSIGNMENT_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}FLAC__FRAME_HEADER_BITS_PER_SAMPLE_LEN"]
    pub static FLAC__FRAME_HEADER_BITS_PER_SAMPLE_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}FLAC__FRAME_HEADER_ZERO_PAD_LEN"]
    pub static FLAC__FRAME_HEADER_ZERO_PAD_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}FLAC__FRAME_HEADER_CRC_LEN"]
    pub static FLAC__FRAME_HEADER_CRC_LEN: ::std::os::raw::c_uint;
}
#[doc = " FLAC frame footer structure.  (c.f. <A HREF=\"../format.html#frame_footer\">format specification</A>)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__FrameFooter {
    pub crc: FLAC__uint16,
}
extern "C" {
    #[link_name = "\u{1}FLAC__FRAME_FOOTER_CRC_LEN"]
    pub static FLAC__FRAME_FOOTER_CRC_LEN: ::std::os::raw::c_uint;
}
#[doc = " FLAC frame structure.  (c.f. <A HREF=\"../format.html#frame\">format specification</A>)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FLAC__Frame {
    pub header: FLAC__FrameHeader,
    pub subframes: [FLAC__Subframe; 8usize],
    pub footer: FLAC__FrameFooter,
}
pub const FLAC__MetadataType_FLAC__METADATA_TYPE_STREAMINFO: FLAC__MetadataType = 0;
pub const FLAC__MetadataType_FLAC__METADATA_TYPE_PADDING: FLAC__MetadataType = 1;
pub const FLAC__MetadataType_FLAC__METADATA_TYPE_APPLICATION: FLAC__MetadataType = 2;
pub const FLAC__MetadataType_FLAC__METADATA_TYPE_SEEKTABLE: FLAC__MetadataType = 3;
pub const FLAC__MetadataType_FLAC__METADATA_TYPE_VORBIS_COMMENT: FLAC__MetadataType = 4;
pub const FLAC__MetadataType_FLAC__METADATA_TYPE_CUESHEET: FLAC__MetadataType = 5;
pub const FLAC__MetadataType_FLAC__METADATA_TYPE_PICTURE: FLAC__MetadataType = 6;
pub const FLAC__MetadataType_FLAC__METADATA_TYPE_UNDEFINED: FLAC__MetadataType = 7;
pub const FLAC__MetadataType_FLAC__MAX_METADATA_TYPE: FLAC__MetadataType = 126;
#[doc = " An enumeration of the available metadata block types."]
pub type FLAC__MetadataType = u32;
extern "C" {
    #[link_name = "\u{1}FLAC__MetadataTypeString"]
    pub static mut FLAC__MetadataTypeString: [*const ::std::os::raw::c_char; 0usize];
}
#[doc = " FLAC STREAMINFO structure.  (c.f. <A HREF=\"../format.html#metadata_block_streaminfo\">format specification</A>)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__StreamMetadata_StreamInfo {
    pub min_blocksize: ::std::os::raw::c_uint,
    pub max_blocksize: ::std::os::raw::c_uint,
    pub min_framesize: ::std::os::raw::c_uint,
    pub max_framesize: ::std::os::raw::c_uint,
    pub sample_rate: ::std::os::raw::c_uint,
    pub channels: ::std::os::raw::c_uint,
    pub bits_per_sample: ::std::os::raw::c_uint,
    pub total_samples: FLAC__uint64,
    pub md5sum: [FLAC__byte; 16usize],
}
extern "C" {
    #[link_name = "\u{1}FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN"]
    pub static FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN"]
    pub static FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN"]
    pub static FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN"]
    pub static FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN"]
    pub static FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN"]
    pub static FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN"]
    pub static FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN"]
    pub static FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN"]
    pub static FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN: ::std::os::raw::c_uint;
}
#[doc = " FLAC PADDING structure.  (c.f. <A HREF=\"../format.html#metadata_block_padding\">format specification</A>)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__StreamMetadata_Padding {
    pub dummy: ::std::os::raw::c_int,
}
#[doc = " FLAC APPLICATION structure.  (c.f. <A HREF=\"../format.html#metadata_block_application\">format specification</A>)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__StreamMetadata_Application {
    pub id: [FLAC__byte; 4usize],
    pub data: *mut FLAC__byte,
}
extern "C" {
    #[link_name = "\u{1}FLAC__STREAM_METADATA_APPLICATION_ID_LEN"]
    pub static FLAC__STREAM_METADATA_APPLICATION_ID_LEN: ::std::os::raw::c_uint;
}
#[doc = " SeekPoint structure used in SEEKTABLE blocks.  (c.f. <A HREF=\"../format.html#seekpoint\">format specification</A>)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__StreamMetadata_SeekPoint {
    pub sample_number: FLAC__uint64,
    pub stream_offset: FLAC__uint64,
    pub frame_samples: ::std::os::raw::c_uint,
}
extern "C" {
    #[link_name = "\u{1}FLAC__STREAM_METADATA_SEEKPOINT_SAMPLE_NUMBER_LEN"]
    pub static FLAC__STREAM_METADATA_SEEKPOINT_SAMPLE_NUMBER_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}FLAC__STREAM_METADATA_SEEKPOINT_STREAM_OFFSET_LEN"]
    pub static FLAC__STREAM_METADATA_SEEKPOINT_STREAM_OFFSET_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}FLAC__STREAM_METADATA_SEEKPOINT_FRAME_SAMPLES_LEN"]
    pub static FLAC__STREAM_METADATA_SEEKPOINT_FRAME_SAMPLES_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}FLAC__STREAM_METADATA_SEEKPOINT_PLACEHOLDER"]
    pub static FLAC__STREAM_METADATA_SEEKPOINT_PLACEHOLDER: FLAC__uint64;
}
#[doc = " FLAC SEEKTABLE structure.  (c.f. <A HREF=\"../format.html#metadata_block_seektable\">format specification</A>)"]
#[doc = ""]
#[doc = " \\note From the format specification:"]
#[doc = " - The seek points must be sorted by ascending sample number."]
#[doc = " - Each seek point\'s sample number must be the first sample of the"]
#[doc = "   target frame."]
#[doc = " - Each seek point\'s sample number must be unique within the table."]
#[doc = " - Existence of a SEEKTABLE block implies a correct setting of"]
#[doc = "   total_samples in the stream_info block."]
#[doc = " - Behavior is undefined when more than one SEEKTABLE block is"]
#[doc = "   present in a stream."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__StreamMetadata_SeekTable {
    pub num_points: ::std::os::raw::c_uint,
    pub points: *mut FLAC__StreamMetadata_SeekPoint,
}
#[doc = " Vorbis comment entry structure used in VORBIS_COMMENT blocks.  (c.f. <A HREF=\"../format.html#metadata_block_vorbis_comment\">format specification</A>)"]
#[doc = ""]
#[doc = "  For convenience, the APIs maintain a trailing NUL character at the end of"]
#[doc = "  \\a entry which is not counted toward \\a length, i.e."]
#[doc = "  \\code strlen(entry) == length \\endcode"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__StreamMetadata_VorbisComment_Entry {
    pub length: FLAC__uint32,
    pub entry: *mut FLAC__byte,
}
extern "C" {
    #[link_name = "\u{1}FLAC__STREAM_METADATA_VORBIS_COMMENT_ENTRY_LENGTH_LEN"]
    pub static FLAC__STREAM_METADATA_VORBIS_COMMENT_ENTRY_LENGTH_LEN: ::std::os::raw::c_uint;
}
#[doc = " FLAC VORBIS_COMMENT structure.  (c.f. <A HREF=\"../format.html#metadata_block_vorbis_comment\">format specification</A>)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__StreamMetadata_VorbisComment {
    pub vendor_string: FLAC__StreamMetadata_VorbisComment_Entry,
    pub num_comments: FLAC__uint32,
    pub comments: *mut FLAC__StreamMetadata_VorbisComment_Entry,
}
extern "C" {
    #[link_name = "\u{1}FLAC__STREAM_METADATA_VORBIS_COMMENT_NUM_COMMENTS_LEN"]
    pub static FLAC__STREAM_METADATA_VORBIS_COMMENT_NUM_COMMENTS_LEN: ::std::os::raw::c_uint;
}
#[doc = " FLAC CUESHEET track index structure.  (See the"]
#[doc = " <A HREF=\"../format.html#cuesheet_track_index\">format specification</A> for"]
#[doc = " the full description of each field.)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__StreamMetadata_CueSheet_Index {
    pub offset: FLAC__uint64,
    pub number: FLAC__byte,
}
extern "C" {
    #[link_name = "\u{1}FLAC__STREAM_METADATA_CUESHEET_INDEX_OFFSET_LEN"]
    pub static FLAC__STREAM_METADATA_CUESHEET_INDEX_OFFSET_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}FLAC__STREAM_METADATA_CUESHEET_INDEX_NUMBER_LEN"]
    pub static FLAC__STREAM_METADATA_CUESHEET_INDEX_NUMBER_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}FLAC__STREAM_METADATA_CUESHEET_INDEX_RESERVED_LEN"]
    pub static FLAC__STREAM_METADATA_CUESHEET_INDEX_RESERVED_LEN: ::std::os::raw::c_uint;
}
#[doc = " FLAC CUESHEET track structure.  (See the"]
#[doc = " <A HREF=\"../format.html#cuesheet_track\">format specification</A> for"]
#[doc = " the full description of each field.)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__StreamMetadata_CueSheet_Track {
    pub offset: FLAC__uint64,
    pub number: FLAC__byte,
    pub isrc: [::std::os::raw::c_char; 13usize],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub num_indices: FLAC__byte,
    pub indices: *mut FLAC__StreamMetadata_CueSheet_Index,
}
impl FLAC__StreamMetadata_CueSheet_Track {
    #[inline]
    pub fn type_(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pre_emphasis(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pre_emphasis(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        type_: ::std::os::raw::c_uint,
        pre_emphasis: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let pre_emphasis: u32 = unsafe { ::std::mem::transmute(pre_emphasis) };
            pre_emphasis as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[link_name = "\u{1}FLAC__STREAM_METADATA_CUESHEET_TRACK_OFFSET_LEN"]
    pub static FLAC__STREAM_METADATA_CUESHEET_TRACK_OFFSET_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}FLAC__STREAM_METADATA_CUESHEET_TRACK_NUMBER_LEN"]
    pub static FLAC__STREAM_METADATA_CUESHEET_TRACK_NUMBER_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}FLAC__STREAM_METADATA_CUESHEET_TRACK_ISRC_LEN"]
    pub static FLAC__STREAM_METADATA_CUESHEET_TRACK_ISRC_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}FLAC__STREAM_METADATA_CUESHEET_TRACK_TYPE_LEN"]
    pub static FLAC__STREAM_METADATA_CUESHEET_TRACK_TYPE_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}FLAC__STREAM_METADATA_CUESHEET_TRACK_PRE_EMPHASIS_LEN"]
    pub static FLAC__STREAM_METADATA_CUESHEET_TRACK_PRE_EMPHASIS_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}FLAC__STREAM_METADATA_CUESHEET_TRACK_RESERVED_LEN"]
    pub static FLAC__STREAM_METADATA_CUESHEET_TRACK_RESERVED_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}FLAC__STREAM_METADATA_CUESHEET_TRACK_NUM_INDICES_LEN"]
    pub static FLAC__STREAM_METADATA_CUESHEET_TRACK_NUM_INDICES_LEN: ::std::os::raw::c_uint;
}
#[doc = " FLAC CUESHEET structure.  (See the"]
#[doc = " <A HREF=\"../format.html#metadata_block_cuesheet\">format specification</A>"]
#[doc = " for the full description of each field.)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FLAC__StreamMetadata_CueSheet {
    pub media_catalog_number: [::std::os::raw::c_char; 129usize],
    pub lead_in: FLAC__uint64,
    pub is_cd: FLAC__bool,
    pub num_tracks: ::std::os::raw::c_uint,
    pub tracks: *mut FLAC__StreamMetadata_CueSheet_Track,
}
extern "C" {
    #[link_name = "\u{1}FLAC__STREAM_METADATA_CUESHEET_MEDIA_CATALOG_NUMBER_LEN"]
    pub static FLAC__STREAM_METADATA_CUESHEET_MEDIA_CATALOG_NUMBER_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}FLAC__STREAM_METADATA_CUESHEET_LEAD_IN_LEN"]
    pub static FLAC__STREAM_METADATA_CUESHEET_LEAD_IN_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}FLAC__STREAM_METADATA_CUESHEET_IS_CD_LEN"]
    pub static FLAC__STREAM_METADATA_CUESHEET_IS_CD_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}FLAC__STREAM_METADATA_CUESHEET_RESERVED_LEN"]
    pub static FLAC__STREAM_METADATA_CUESHEET_RESERVED_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}FLAC__STREAM_METADATA_CUESHEET_NUM_TRACKS_LEN"]
    pub static FLAC__STREAM_METADATA_CUESHEET_NUM_TRACKS_LEN: ::std::os::raw::c_uint;
}
#[doc = "< Other"]
pub const FLAC__StreamMetadata_Picture_Type_FLAC__STREAM_METADATA_PICTURE_TYPE_OTHER:
    FLAC__StreamMetadata_Picture_Type = 0;
#[doc = "< 32x32 pixels \'file icon\' (PNG only)"]
pub const FLAC__StreamMetadata_Picture_Type_FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON_STANDARD : FLAC__StreamMetadata_Picture_Type = 1 ;
#[doc = "< Other file icon"]
pub const FLAC__StreamMetadata_Picture_Type_FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON:
    FLAC__StreamMetadata_Picture_Type = 2;
#[doc = "< Cover (front)"]
pub const FLAC__StreamMetadata_Picture_Type_FLAC__STREAM_METADATA_PICTURE_TYPE_FRONT_COVER:
    FLAC__StreamMetadata_Picture_Type = 3;
#[doc = "< Cover (back)"]
pub const FLAC__StreamMetadata_Picture_Type_FLAC__STREAM_METADATA_PICTURE_TYPE_BACK_COVER:
    FLAC__StreamMetadata_Picture_Type = 4;
#[doc = "< Leaflet page"]
pub const FLAC__StreamMetadata_Picture_Type_FLAC__STREAM_METADATA_PICTURE_TYPE_LEAFLET_PAGE:
    FLAC__StreamMetadata_Picture_Type = 5;
#[doc = "< Media (e.g. label side of CD)"]
pub const FLAC__StreamMetadata_Picture_Type_FLAC__STREAM_METADATA_PICTURE_TYPE_MEDIA:
    FLAC__StreamMetadata_Picture_Type = 6;
#[doc = "< Lead artist/lead performer/soloist"]
pub const FLAC__StreamMetadata_Picture_Type_FLAC__STREAM_METADATA_PICTURE_TYPE_LEAD_ARTIST:
    FLAC__StreamMetadata_Picture_Type = 7;
#[doc = "< Artist/performer"]
pub const FLAC__StreamMetadata_Picture_Type_FLAC__STREAM_METADATA_PICTURE_TYPE_ARTIST:
    FLAC__StreamMetadata_Picture_Type = 8;
#[doc = "< Conductor"]
pub const FLAC__StreamMetadata_Picture_Type_FLAC__STREAM_METADATA_PICTURE_TYPE_CONDUCTOR:
    FLAC__StreamMetadata_Picture_Type = 9;
#[doc = "< Band/Orchestra"]
pub const FLAC__StreamMetadata_Picture_Type_FLAC__STREAM_METADATA_PICTURE_TYPE_BAND:
    FLAC__StreamMetadata_Picture_Type = 10;
#[doc = "< Composer"]
pub const FLAC__StreamMetadata_Picture_Type_FLAC__STREAM_METADATA_PICTURE_TYPE_COMPOSER:
    FLAC__StreamMetadata_Picture_Type = 11;
#[doc = "< Lyricist/text writer"]
pub const FLAC__StreamMetadata_Picture_Type_FLAC__STREAM_METADATA_PICTURE_TYPE_LYRICIST:
    FLAC__StreamMetadata_Picture_Type = 12;
#[doc = "< Recording Location"]
pub const FLAC__StreamMetadata_Picture_Type_FLAC__STREAM_METADATA_PICTURE_TYPE_RECORDING_LOCATION : FLAC__StreamMetadata_Picture_Type = 13 ;
#[doc = "< During recording"]
pub const FLAC__StreamMetadata_Picture_Type_FLAC__STREAM_METADATA_PICTURE_TYPE_DURING_RECORDING:
    FLAC__StreamMetadata_Picture_Type = 14;
#[doc = "< During performance"]
pub const FLAC__StreamMetadata_Picture_Type_FLAC__STREAM_METADATA_PICTURE_TYPE_DURING_PERFORMANCE : FLAC__StreamMetadata_Picture_Type = 15 ;
#[doc = "< Movie/video screen capture"]
pub const FLAC__StreamMetadata_Picture_Type_FLAC__STREAM_METADATA_PICTURE_TYPE_VIDEO_SCREEN_CAPTURE : FLAC__StreamMetadata_Picture_Type = 16 ;
#[doc = "< A bright coloured fish"]
pub const FLAC__StreamMetadata_Picture_Type_FLAC__STREAM_METADATA_PICTURE_TYPE_FISH:
    FLAC__StreamMetadata_Picture_Type = 17;
#[doc = "< Illustration"]
pub const FLAC__StreamMetadata_Picture_Type_FLAC__STREAM_METADATA_PICTURE_TYPE_ILLUSTRATION:
    FLAC__StreamMetadata_Picture_Type = 18;
#[doc = "< Band/artist logotype"]
pub const FLAC__StreamMetadata_Picture_Type_FLAC__STREAM_METADATA_PICTURE_TYPE_BAND_LOGOTYPE:
    FLAC__StreamMetadata_Picture_Type = 19;
#[doc = "< Publisher/Studio logotype"]
pub const FLAC__StreamMetadata_Picture_Type_FLAC__STREAM_METADATA_PICTURE_TYPE_PUBLISHER_LOGOTYPE : FLAC__StreamMetadata_Picture_Type = 20 ;
pub const FLAC__StreamMetadata_Picture_Type_FLAC__STREAM_METADATA_PICTURE_TYPE_UNDEFINED:
    FLAC__StreamMetadata_Picture_Type = 21;
#[doc = " An enumeration of the PICTURE types (see FLAC__StreamMetadataPicture and id3 v2.4 APIC tag)."]
pub type FLAC__StreamMetadata_Picture_Type = u32;
extern "C" {
    #[link_name = "\u{1}FLAC__StreamMetadata_Picture_TypeString"]
    pub static mut FLAC__StreamMetadata_Picture_TypeString: [*const ::std::os::raw::c_char; 0usize];
}
#[doc = " FLAC PICTURE structure.  (See the"]
#[doc = " <A HREF=\"../format.html#metadata_block_picture\">format specification</A>"]
#[doc = " for the full description of each field.)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__StreamMetadata_Picture {
    pub type_: FLAC__StreamMetadata_Picture_Type,
    pub mime_type: *mut ::std::os::raw::c_char,
    pub description: *mut FLAC__byte,
    pub width: FLAC__uint32,
    pub height: FLAC__uint32,
    pub depth: FLAC__uint32,
    pub colors: FLAC__uint32,
    pub data_length: FLAC__uint32,
    pub data: *mut FLAC__byte,
}
extern "C" {
    #[link_name = "\u{1}FLAC__STREAM_METADATA_PICTURE_TYPE_LEN"]
    pub static FLAC__STREAM_METADATA_PICTURE_TYPE_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}FLAC__STREAM_METADATA_PICTURE_MIME_TYPE_LENGTH_LEN"]
    pub static FLAC__STREAM_METADATA_PICTURE_MIME_TYPE_LENGTH_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}FLAC__STREAM_METADATA_PICTURE_DESCRIPTION_LENGTH_LEN"]
    pub static FLAC__STREAM_METADATA_PICTURE_DESCRIPTION_LENGTH_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}FLAC__STREAM_METADATA_PICTURE_WIDTH_LEN"]
    pub static FLAC__STREAM_METADATA_PICTURE_WIDTH_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}FLAC__STREAM_METADATA_PICTURE_HEIGHT_LEN"]
    pub static FLAC__STREAM_METADATA_PICTURE_HEIGHT_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}FLAC__STREAM_METADATA_PICTURE_DEPTH_LEN"]
    pub static FLAC__STREAM_METADATA_PICTURE_DEPTH_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}FLAC__STREAM_METADATA_PICTURE_COLORS_LEN"]
    pub static FLAC__STREAM_METADATA_PICTURE_COLORS_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}FLAC__STREAM_METADATA_PICTURE_DATA_LENGTH_LEN"]
    pub static FLAC__STREAM_METADATA_PICTURE_DATA_LENGTH_LEN: ::std::os::raw::c_uint;
}
#[doc = " Structure that is used when a metadata block of unknown type is loaded."]
#[doc = "  The contents are opaque.  The structure is used only internally to"]
#[doc = "  correctly handle unknown metadata."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__StreamMetadata_Unknown {
    pub data: *mut FLAC__byte,
}
#[doc = " FLAC metadata block structure.  (c.f. <A HREF=\"../format.html#metadata_block\">format specification</A>)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FLAC__StreamMetadata {
    pub type_: FLAC__MetadataType,
    pub is_last: FLAC__bool,
    pub length: ::std::os::raw::c_uint,
    pub data: FLAC__StreamMetadata__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union FLAC__StreamMetadata__bindgen_ty_1 {
    pub stream_info: FLAC__StreamMetadata_StreamInfo,
    pub padding: FLAC__StreamMetadata_Padding,
    pub application: FLAC__StreamMetadata_Application,
    pub seek_table: FLAC__StreamMetadata_SeekTable,
    pub vorbis_comment: FLAC__StreamMetadata_VorbisComment,
    pub cue_sheet: FLAC__StreamMetadata_CueSheet,
    pub picture: FLAC__StreamMetadata_Picture,
    pub unknown: FLAC__StreamMetadata_Unknown,
    _bindgen_union_align: [u64; 20usize],
}
extern "C" {
    #[link_name = "\u{1}FLAC__STREAM_METADATA_IS_LAST_LEN"]
    pub static FLAC__STREAM_METADATA_IS_LAST_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}FLAC__STREAM_METADATA_TYPE_LEN"]
    pub static FLAC__STREAM_METADATA_TYPE_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}FLAC__STREAM_METADATA_LENGTH_LEN"]
    pub static FLAC__STREAM_METADATA_LENGTH_LEN: ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Tests that a sample rate is valid for FLAC."]
    #[doc = ""]
    #[doc = " \\param sample_rate  The sample rate to test for compliance."]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c true if the given sample rate conforms to the specification, else"]
    #[doc = "    \\c false."]
    pub fn FLAC__format_sample_rate_is_valid(sample_rate: ::std::os::raw::c_uint) -> FLAC__bool;
}
extern "C" {
    #[doc = " Tests that a blocksize at the given sample rate is valid for the FLAC"]
    #[doc = "  subset."]
    #[doc = ""]
    #[doc = " \\param blocksize    The blocksize to test for compliance."]
    #[doc = " \\param sample_rate  The sample rate is needed, since the valid subset"]
    #[doc = "                     blocksize depends on the sample rate."]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c true if the given blocksize conforms to the specification for the"]
    #[doc = "    subset at the given sample rate, else \\c false."]
    pub fn FLAC__format_blocksize_is_subset(
        blocksize: ::std::os::raw::c_uint,
        sample_rate: ::std::os::raw::c_uint,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Tests that a sample rate is valid for the FLAC subset.  The subset rules"]
    #[doc = "  for valid sample rates are slightly more complex since the rate has to"]
    #[doc = "  be expressible completely in the frame header."]
    #[doc = ""]
    #[doc = " \\param sample_rate  The sample rate to test for compliance."]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c true if the given sample rate conforms to the specification for the"]
    #[doc = "    subset, else \\c false."]
    pub fn FLAC__format_sample_rate_is_subset(sample_rate: ::std::os::raw::c_uint) -> FLAC__bool;
}
extern "C" {
    #[doc = " Check a Vorbis comment entry name to see if it conforms to the Vorbis"]
    #[doc = "  comment specification."]
    #[doc = ""]
    #[doc = "  Vorbis comment names must be composed only of characters from"]
    #[doc = "  [0x20-0x3C,0x3E-0x7D]."]
    #[doc = ""]
    #[doc = " \\param name       A NUL-terminated string to be checked."]
    #[doc = " \\assert"]
    #[doc = "    \\code name != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if entry name is illegal, else \\c true."]
    pub fn FLAC__format_vorbiscomment_entry_name_is_legal(
        name: *const ::std::os::raw::c_char,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Check a Vorbis comment entry value to see if it conforms to the Vorbis"]
    #[doc = "  comment specification."]
    #[doc = ""]
    #[doc = "  Vorbis comment values must be valid UTF-8 sequences."]
    #[doc = ""]
    #[doc = " \\param value      A string to be checked."]
    #[doc = " \\param length     A the length of \\a value in bytes.  May be"]
    #[doc = "                   \\c (unsigned)(-1) to indicate that \\a value is a plain"]
    #[doc = "                   UTF-8 NUL-terminated string."]
    #[doc = " \\assert"]
    #[doc = "    \\code value != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if entry name is illegal, else \\c true."]
    pub fn FLAC__format_vorbiscomment_entry_value_is_legal(
        value: *const FLAC__byte,
        length: ::std::os::raw::c_uint,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Check a Vorbis comment entry to see if it conforms to the Vorbis"]
    #[doc = "  comment specification."]
    #[doc = ""]
    #[doc = "  Vorbis comment entries must be of the form \'name=value\', and \'name\' and"]
    #[doc = "  \'value\' must be legal according to"]
    #[doc = "  FLAC__format_vorbiscomment_entry_name_is_legal() and"]
    #[doc = "  FLAC__format_vorbiscomment_entry_value_is_legal() respectively."]
    #[doc = ""]
    #[doc = " \\param entry      An entry to be checked."]
    #[doc = " \\param length     The length of \\a entry in bytes."]
    #[doc = " \\assert"]
    #[doc = "    \\code value != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if entry name is illegal, else \\c true."]
    pub fn FLAC__format_vorbiscomment_entry_is_legal(
        entry: *const FLAC__byte,
        length: ::std::os::raw::c_uint,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Check a seek table to see if it conforms to the FLAC specification."]
    #[doc = "  See the format specification for limits on the contents of the"]
    #[doc = "  seek table."]
    #[doc = ""]
    #[doc = " \\param seek_table  A pointer to a seek table to be checked."]
    #[doc = " \\assert"]
    #[doc = "    \\code seek_table != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if seek table is illegal, else \\c true."]
    pub fn FLAC__format_seektable_is_legal(
        seek_table: *const FLAC__StreamMetadata_SeekTable,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Sort a seek table\'s seek points according to the format specification."]
    #[doc = "  This includes a \"unique-ification\" step to remove duplicates, i.e."]
    #[doc = "  seek points with identical \\a sample_number values.  Duplicate seek"]
    #[doc = "  points are converted into placeholder points and sorted to the end of"]
    #[doc = "  the table."]
    #[doc = ""]
    #[doc = " \\param seek_table  A pointer to a seek table to be sorted."]
    #[doc = " \\assert"]
    #[doc = "    \\code seek_table != NULL \\endcode"]
    #[doc = " \\retval unsigned"]
    #[doc = "    The number of duplicate seek points converted into placeholders."]
    pub fn FLAC__format_seektable_sort(
        seek_table: *mut FLAC__StreamMetadata_SeekTable,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Check a cue sheet to see if it conforms to the FLAC specification."]
    #[doc = "  See the format specification for limits on the contents of the"]
    #[doc = "  cue sheet."]
    #[doc = ""]
    #[doc = " \\param cue_sheet  A pointer to an existing cue sheet to be checked."]
    #[doc = " \\param check_cd_da_subset  If \\c true, check CUESHEET against more"]
    #[doc = "                   stringent requirements for a CD-DA (audio) disc."]
    #[doc = " \\param violation  Address of a pointer to a string.  If there is a"]
    #[doc = "                   violation, a pointer to a string explanation of the"]
    #[doc = "                   violation will be returned here. \\a violation may be"]
    #[doc = "                   \\c NULL if you don\'t need the returned string.  Do not"]
    #[doc = "                   free the returned string; it will always point to static"]
    #[doc = "                   data."]
    #[doc = " \\assert"]
    #[doc = "    \\code cue_sheet != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if cue sheet is illegal, else \\c true."]
    pub fn FLAC__format_cuesheet_is_legal(
        cue_sheet: *const FLAC__StreamMetadata_CueSheet,
        check_cd_da_subset: FLAC__bool,
        violation: *mut *const ::std::os::raw::c_char,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Check picture data to see if it conforms to the FLAC specification."]
    #[doc = "  See the format specification for limits on the contents of the"]
    #[doc = "  PICTURE block."]
    #[doc = ""]
    #[doc = " \\param picture    A pointer to existing picture data to be checked."]
    #[doc = " \\param violation  Address of a pointer to a string.  If there is a"]
    #[doc = "                   violation, a pointer to a string explanation of the"]
    #[doc = "                   violation will be returned here. \\a violation may be"]
    #[doc = "                   \\c NULL if you don\'t need the returned string.  Do not"]
    #[doc = "                   free the returned string; it will always point to static"]
    #[doc = "                   data."]
    #[doc = " \\assert"]
    #[doc = "    \\code picture != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if picture data is illegal, else \\c true."]
    pub fn FLAC__format_picture_is_legal(
        picture: *const FLAC__StreamMetadata_Picture,
        violation: *mut *const ::std::os::raw::c_char,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Read the STREAMINFO metadata block of the given FLAC file.  This function"]
    #[doc = "  will try to skip any ID3v2 tag at the head of the file."]
    #[doc = ""]
    #[doc = " \\param filename    The path to the FLAC file to read."]
    #[doc = " \\param streaminfo  A pointer to space for the STREAMINFO block.  Since"]
    #[doc = "                    FLAC__StreamMetadata is a simple structure with no"]
    #[doc = "                    memory allocation involved, you pass the address of"]
    #[doc = "                    an existing structure.  It need not be initialized."]
    #[doc = " \\assert"]
    #[doc = "    \\code filename != NULL \\endcode"]
    #[doc = "    \\code streaminfo != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c true if a valid STREAMINFO block was read from \\a filename.  Returns"]
    #[doc = "    \\c false if there was a memory allocation error, a file decoder error,"]
    #[doc = "    or the file contained no STREAMINFO block.  (A memory allocation error"]
    #[doc = "    is possible because this function must set up a file decoder.)"]
    pub fn FLAC__metadata_get_streaminfo(
        filename: *const ::std::os::raw::c_char,
        streaminfo: *mut FLAC__StreamMetadata,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Read the VORBIS_COMMENT metadata block of the given FLAC file.  This"]
    #[doc = "  function will try to skip any ID3v2 tag at the head of the file."]
    #[doc = ""]
    #[doc = " \\param filename    The path to the FLAC file to read."]
    #[doc = " \\param tags        The address where the returned pointer will be"]
    #[doc = "                    stored.  The \\a tags object must be deleted by"]
    #[doc = "                    the caller using FLAC__metadata_object_delete()."]
    #[doc = " \\assert"]
    #[doc = "    \\code filename != NULL \\endcode"]
    #[doc = "    \\code tags != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c true if a valid VORBIS_COMMENT block was read from \\a filename,"]
    #[doc = "    and \\a *tags will be set to the address of the metadata structure."]
    #[doc = "    Returns \\c false if there was a memory allocation error, a file"]
    #[doc = "    decoder error, or the file contained no VORBIS_COMMENT block, and"]
    #[doc = "    \\a *tags will be set to \\c NULL."]
    pub fn FLAC__metadata_get_tags(
        filename: *const ::std::os::raw::c_char,
        tags: *mut *mut FLAC__StreamMetadata,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Read the CUESHEET metadata block of the given FLAC file.  This"]
    #[doc = "  function will try to skip any ID3v2 tag at the head of the file."]
    #[doc = ""]
    #[doc = " \\param filename    The path to the FLAC file to read."]
    #[doc = " \\param cuesheet    The address where the returned pointer will be"]
    #[doc = "                    stored.  The \\a cuesheet object must be deleted by"]
    #[doc = "                    the caller using FLAC__metadata_object_delete()."]
    #[doc = " \\assert"]
    #[doc = "    \\code filename != NULL \\endcode"]
    #[doc = "    \\code cuesheet != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c true if a valid CUESHEET block was read from \\a filename,"]
    #[doc = "    and \\a *cuesheet will be set to the address of the metadata"]
    #[doc = "    structure.  Returns \\c false if there was a memory allocation"]
    #[doc = "    error, a file decoder error, or the file contained no CUESHEET"]
    #[doc = "    block, and \\a *cuesheet will be set to \\c NULL."]
    pub fn FLAC__metadata_get_cuesheet(
        filename: *const ::std::os::raw::c_char,
        cuesheet: *mut *mut FLAC__StreamMetadata,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Read a PICTURE metadata block of the given FLAC file.  This"]
    #[doc = "  function will try to skip any ID3v2 tag at the head of the file."]
    #[doc = "  Since there can be more than one PICTURE block in a file, this"]
    #[doc = "  function takes a number of parameters that act as constraints to"]
    #[doc = "  the search.  The PICTURE block with the largest area matching all"]
    #[doc = "  the constraints will be returned, or \\a *picture will be set to"]
    #[doc = "  \\c NULL if there was no such block."]
    #[doc = ""]
    #[doc = " \\param filename    The path to the FLAC file to read."]
    #[doc = " \\param picture     The address where the returned pointer will be"]
    #[doc = "                    stored.  The \\a picture object must be deleted by"]
    #[doc = "                    the caller using FLAC__metadata_object_delete()."]
    #[doc = " \\param type        The desired picture type.  Use \\c -1 to mean"]
    #[doc = "                    \"any type\"."]
    #[doc = " \\param mime_type   The desired MIME type, e.g. \"image/jpeg\".  The"]
    #[doc = "                    string will be matched exactly.  Use \\c NULL to"]
    #[doc = "                    mean \"any MIME type\"."]
    #[doc = " \\param description The desired description.  The string will be"]
    #[doc = "                    matched exactly.  Use \\c NULL to mean \"any"]
    #[doc = "                    description\"."]
    #[doc = " \\param max_width   The maximum width in pixels desired.  Use"]
    #[doc = "                    \\c (unsigned)(-1) to mean \"any width\"."]
    #[doc = " \\param max_height  The maximum height in pixels desired.  Use"]
    #[doc = "                    \\c (unsigned)(-1) to mean \"any height\"."]
    #[doc = " \\param max_depth   The maximum color depth in bits-per-pixel desired."]
    #[doc = "                    Use \\c (unsigned)(-1) to mean \"any depth\"."]
    #[doc = " \\param max_colors  The maximum number of colors desired.  Use"]
    #[doc = "                    \\c (unsigned)(-1) to mean \"any number of colors\"."]
    #[doc = " \\assert"]
    #[doc = "    \\code filename != NULL \\endcode"]
    #[doc = "    \\code picture != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c true if a valid PICTURE block was read from \\a filename,"]
    #[doc = "    and \\a *picture will be set to the address of the metadata"]
    #[doc = "    structure.  Returns \\c false if there was a memory allocation"]
    #[doc = "    error, a file decoder error, or the file contained no PICTURE"]
    #[doc = "    block, and \\a *picture will be set to \\c NULL."]
    pub fn FLAC__metadata_get_picture(
        filename: *const ::std::os::raw::c_char,
        picture: *mut *mut FLAC__StreamMetadata,
        type_: FLAC__StreamMetadata_Picture_Type,
        mime_type: *const ::std::os::raw::c_char,
        description: *const FLAC__byte,
        max_width: ::std::os::raw::c_uint,
        max_height: ::std::os::raw::c_uint,
        max_depth: ::std::os::raw::c_uint,
        max_colors: ::std::os::raw::c_uint,
    ) -> FLAC__bool;
}
#[doc = " \\defgroup flac_metadata_level1 FLAC/metadata.h: metadata level 1 interface"]
#[doc = "  \\ingroup flac_metadata"]
#[doc = ""]
#[doc = " \\brief"]
#[doc = " The level 1 interface provides read-write access to FLAC file metadata and"]
#[doc = " operates directly on the FLAC file."]
#[doc = ""]
#[doc = " The general usage of this interface is:"]
#[doc = ""]
#[doc = " - Create an iterator using FLAC__metadata_simple_iterator_new()"]
#[doc = " - Attach it to a file using FLAC__metadata_simple_iterator_init() and check"]
#[doc = "   the exit code.  Call FLAC__metadata_simple_iterator_is_writable() to"]
#[doc = "   see if the file is writable, or only read access is allowed."]
#[doc = " - Use FLAC__metadata_simple_iterator_next() and"]
#[doc = "   FLAC__metadata_simple_iterator_prev() to traverse the blocks."]
#[doc = "   This is does not read the actual blocks themselves."]
#[doc = "   FLAC__metadata_simple_iterator_next() is relatively fast."]
#[doc = "   FLAC__metadata_simple_iterator_prev() is slower since it needs to search"]
#[doc = "   forward from the front of the file."]
#[doc = " - Use FLAC__metadata_simple_iterator_get_block_type() or"]
#[doc = "   FLAC__metadata_simple_iterator_get_block() to access the actual data at"]
#[doc = "   the current iterator position.  The returned object is yours to modify"]
#[doc = "   and free."]
#[doc = " - Use FLAC__metadata_simple_iterator_set_block() to write a modified block"]
#[doc = "   back.  You must have write permission to the original file.  Make sure to"]
#[doc = "   read the whole comment to FLAC__metadata_simple_iterator_set_block()"]
#[doc = "   below."]
#[doc = " - Use FLAC__metadata_simple_iterator_insert_block_after() to add new blocks."]
#[doc = "   Use the object creation functions from"]
#[doc = "   \\link flac_metadata_object here \\endlink to generate new objects."]
#[doc = " - Use FLAC__metadata_simple_iterator_delete_block() to remove the block"]
#[doc = "   currently referred to by the iterator, or replace it with padding."]
#[doc = " - Destroy the iterator with FLAC__metadata_simple_iterator_delete() when"]
#[doc = "   finished."]
#[doc = ""]
#[doc = " \\note"]
#[doc = " The FLAC file remains open the whole time between"]
#[doc = " FLAC__metadata_simple_iterator_init() and"]
#[doc = " FLAC__metadata_simple_iterator_delete(), so make sure you are not altering"]
#[doc = " the file during this time."]
#[doc = ""]
#[doc = " \\note"]
#[doc = " Do not modify the \\a is_last, \\a length, or \\a type fields of returned"]
#[doc = " FLAC__StreamMetadata objects.  These are managed automatically."]
#[doc = ""]
#[doc = " \\note"]
#[doc = " If any of the modification functions"]
#[doc = " (FLAC__metadata_simple_iterator_set_block(),"]
#[doc = " FLAC__metadata_simple_iterator_delete_block(),"]
#[doc = " FLAC__metadata_simple_iterator_insert_block_after(), etc.) return \\c false,"]
#[doc = " you should delete the iterator as it may no longer be valid."]
#[doc = ""]
#[doc = " \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__Metadata_SimpleIterator {
    _unused: [u8; 0],
}
pub const FLAC__Metadata_SimpleIteratorStatus_FLAC__METADATA_SIMPLE_ITERATOR_STATUS_OK:
    FLAC__Metadata_SimpleIteratorStatus = 0;
pub const FLAC__Metadata_SimpleIteratorStatus_FLAC__METADATA_SIMPLE_ITERATOR_STATUS_ILLEGAL_INPUT : FLAC__Metadata_SimpleIteratorStatus = 1 ;
pub const FLAC__Metadata_SimpleIteratorStatus_FLAC__METADATA_SIMPLE_ITERATOR_STATUS_ERROR_OPENING_FILE : FLAC__Metadata_SimpleIteratorStatus = 2 ;
pub const FLAC__Metadata_SimpleIteratorStatus_FLAC__METADATA_SIMPLE_ITERATOR_STATUS_NOT_A_FLAC_FILE : FLAC__Metadata_SimpleIteratorStatus = 3 ;
pub const FLAC__Metadata_SimpleIteratorStatus_FLAC__METADATA_SIMPLE_ITERATOR_STATUS_NOT_WRITABLE:
    FLAC__Metadata_SimpleIteratorStatus = 4;
pub const FLAC__Metadata_SimpleIteratorStatus_FLAC__METADATA_SIMPLE_ITERATOR_STATUS_BAD_METADATA:
    FLAC__Metadata_SimpleIteratorStatus = 5;
pub const FLAC__Metadata_SimpleIteratorStatus_FLAC__METADATA_SIMPLE_ITERATOR_STATUS_READ_ERROR:
    FLAC__Metadata_SimpleIteratorStatus = 6;
pub const FLAC__Metadata_SimpleIteratorStatus_FLAC__METADATA_SIMPLE_ITERATOR_STATUS_SEEK_ERROR:
    FLAC__Metadata_SimpleIteratorStatus = 7;
pub const FLAC__Metadata_SimpleIteratorStatus_FLAC__METADATA_SIMPLE_ITERATOR_STATUS_WRITE_ERROR:
    FLAC__Metadata_SimpleIteratorStatus = 8;
pub const FLAC__Metadata_SimpleIteratorStatus_FLAC__METADATA_SIMPLE_ITERATOR_STATUS_RENAME_ERROR:
    FLAC__Metadata_SimpleIteratorStatus = 9;
pub const FLAC__Metadata_SimpleIteratorStatus_FLAC__METADATA_SIMPLE_ITERATOR_STATUS_UNLINK_ERROR:
    FLAC__Metadata_SimpleIteratorStatus = 10;
pub const FLAC__Metadata_SimpleIteratorStatus_FLAC__METADATA_SIMPLE_ITERATOR_STATUS_MEMORY_ALLOCATION_ERROR : FLAC__Metadata_SimpleIteratorStatus = 11 ;
pub const FLAC__Metadata_SimpleIteratorStatus_FLAC__METADATA_SIMPLE_ITERATOR_STATUS_INTERNAL_ERROR : FLAC__Metadata_SimpleIteratorStatus = 12 ;
#[doc = " Status type for FLAC__Metadata_SimpleIterator."]
#[doc = ""]
#[doc = "  The iterator\'s current status can be obtained by calling FLAC__metadata_simple_iterator_status()."]
pub type FLAC__Metadata_SimpleIteratorStatus = u32;
extern "C" {
    #[link_name = "\u{1}FLAC__Metadata_SimpleIteratorStatusString"]
    pub static mut FLAC__Metadata_SimpleIteratorStatusString:
        [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    #[doc = " Create a new iterator instance."]
    #[doc = ""]
    #[doc = " \\retval FLAC__Metadata_SimpleIterator*"]
    #[doc = "    \\c NULL if there was an error allocating memory, else the new instance."]
    pub fn FLAC__metadata_simple_iterator_new() -> *mut FLAC__Metadata_SimpleIterator;
}
extern "C" {
    #[doc = " Free an iterator instance.  Deletes the object pointed to by \\a iterator."]
    #[doc = ""]
    #[doc = " \\param iterator  A pointer to an existing iterator."]
    #[doc = " \\assert"]
    #[doc = "    \\code iterator != NULL \\endcode"]
    pub fn FLAC__metadata_simple_iterator_delete(iterator: *mut FLAC__Metadata_SimpleIterator);
}
extern "C" {
    #[doc = " Get the current status of the iterator.  Call this after a function"]
    #[doc = "  returns \\c false to get the reason for the error.  Also resets the status"]
    #[doc = "  to FLAC__METADATA_SIMPLE_ITERATOR_STATUS_OK."]
    #[doc = ""]
    #[doc = " \\param iterator  A pointer to an existing iterator."]
    #[doc = " \\assert"]
    #[doc = "    \\code iterator != NULL \\endcode"]
    #[doc = " \\retval FLAC__Metadata_SimpleIteratorStatus"]
    #[doc = "    The current status of the iterator."]
    pub fn FLAC__metadata_simple_iterator_status(
        iterator: *mut FLAC__Metadata_SimpleIterator,
    ) -> FLAC__Metadata_SimpleIteratorStatus;
}
extern "C" {
    #[doc = " Initialize the iterator to point to the first metadata block in the"]
    #[doc = "  given FLAC file."]
    #[doc = ""]
    #[doc = " \\param iterator             A pointer to an existing iterator."]
    #[doc = " \\param filename             The path to the FLAC file."]
    #[doc = " \\param read_only            If \\c true, the FLAC file will be opened"]
    #[doc = "                             in read-only mode; if \\c false, the FLAC"]
    #[doc = "                             file will be opened for edit even if no"]
    #[doc = "                             edits are performed."]
    #[doc = " \\param preserve_file_stats  If \\c true, the owner and modification"]
    #[doc = "                             time will be preserved even if the FLAC"]
    #[doc = "                             file is written to."]
    #[doc = " \\assert"]
    #[doc = "    \\code iterator != NULL \\endcode"]
    #[doc = "    \\code filename != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if a memory allocation error occurs, the file can\'t be"]
    #[doc = "    opened, or another error occurs, else \\c true."]
    pub fn FLAC__metadata_simple_iterator_init(
        iterator: *mut FLAC__Metadata_SimpleIterator,
        filename: *const ::std::os::raw::c_char,
        read_only: FLAC__bool,
        preserve_file_stats: FLAC__bool,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Returns \\c true if the FLAC file is writable.  If \\c false, calls to"]
    #[doc = "  FLAC__metadata_simple_iterator_set_block() and"]
    #[doc = "  FLAC__metadata_simple_iterator_insert_block_after() will fail."]
    #[doc = ""]
    #[doc = " \\param iterator             A pointer to an existing iterator."]
    #[doc = " \\assert"]
    #[doc = "    \\code iterator != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    See above."]
    pub fn FLAC__metadata_simple_iterator_is_writable(
        iterator: *const FLAC__Metadata_SimpleIterator,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Moves the iterator forward one metadata block, returning \\c false if"]
    #[doc = "  already at the end."]
    #[doc = ""]
    #[doc = " \\param iterator  A pointer to an existing initialized iterator."]
    #[doc = " \\assert"]
    #[doc = "    \\code iterator != NULL \\endcode"]
    #[doc = "    \\a iterator has been successfully initialized with"]
    #[doc = "    FLAC__metadata_simple_iterator_init()"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if already at the last metadata block of the chain, else"]
    #[doc = "    \\c true."]
    pub fn FLAC__metadata_simple_iterator_next(
        iterator: *mut FLAC__Metadata_SimpleIterator,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Moves the iterator backward one metadata block, returning \\c false if"]
    #[doc = "  already at the beginning."]
    #[doc = ""]
    #[doc = " \\param iterator  A pointer to an existing initialized iterator."]
    #[doc = " \\assert"]
    #[doc = "    \\code iterator != NULL \\endcode"]
    #[doc = "    \\a iterator has been successfully initialized with"]
    #[doc = "    FLAC__metadata_simple_iterator_init()"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if already at the first metadata block of the chain, else"]
    #[doc = "    \\c true."]
    pub fn FLAC__metadata_simple_iterator_prev(
        iterator: *mut FLAC__Metadata_SimpleIterator,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Returns a flag telling if the current metadata block is the last."]
    #[doc = ""]
    #[doc = " \\param iterator  A pointer to an existing initialized iterator."]
    #[doc = " \\assert"]
    #[doc = "    \\code iterator != NULL \\endcode"]
    #[doc = "    \\a iterator has been successfully initialized with"]
    #[doc = "    FLAC__metadata_simple_iterator_init()"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c true if the current metadata block is the last in the file,"]
    #[doc = "    else \\c false."]
    pub fn FLAC__metadata_simple_iterator_is_last(
        iterator: *const FLAC__Metadata_SimpleIterator,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Get the offset of the metadata block at the current position.  This"]
    #[doc = "  avoids reading the actual block data which can save time for large"]
    #[doc = "  blocks."]
    #[doc = ""]
    #[doc = " \\param iterator  A pointer to an existing initialized iterator."]
    #[doc = " \\assert"]
    #[doc = "    \\code iterator != NULL \\endcode"]
    #[doc = "    \\a iterator has been successfully initialized with"]
    #[doc = "    FLAC__metadata_simple_iterator_init()"]
    #[doc = " \\retval off_t"]
    #[doc = "    The offset of the metadata block at the current iterator position."]
    #[doc = "    This is the byte offset relative to the beginning of the file of"]
    #[doc = "    the current metadata block\'s header."]
    pub fn FLAC__metadata_simple_iterator_get_block_offset(
        iterator: *const FLAC__Metadata_SimpleIterator,
    ) -> off_t;
}
extern "C" {
    #[doc = " Get the type of the metadata block at the current position.  This"]
    #[doc = "  avoids reading the actual block data which can save time for large"]
    #[doc = "  blocks."]
    #[doc = ""]
    #[doc = " \\param iterator  A pointer to an existing initialized iterator."]
    #[doc = " \\assert"]
    #[doc = "    \\code iterator != NULL \\endcode"]
    #[doc = "    \\a iterator has been successfully initialized with"]
    #[doc = "    FLAC__metadata_simple_iterator_init()"]
    #[doc = " \\retval FLAC__MetadataType"]
    #[doc = "    The type of the metadata block at the current iterator position."]
    pub fn FLAC__metadata_simple_iterator_get_block_type(
        iterator: *const FLAC__Metadata_SimpleIterator,
    ) -> FLAC__MetadataType;
}
extern "C" {
    #[doc = " Get the length of the metadata block at the current position.  This"]
    #[doc = "  avoids reading the actual block data which can save time for large"]
    #[doc = "  blocks."]
    #[doc = ""]
    #[doc = " \\param iterator  A pointer to an existing initialized iterator."]
    #[doc = " \\assert"]
    #[doc = "    \\code iterator != NULL \\endcode"]
    #[doc = "    \\a iterator has been successfully initialized with"]
    #[doc = "    FLAC__metadata_simple_iterator_init()"]
    #[doc = " \\retval unsigned"]
    #[doc = "    The length of the metadata block at the current iterator position."]
    #[doc = "    The is same length as that in the"]
    #[doc = "    <a href=\"http://xiph.org/flac/format.html#metadata_block_header\">metadata block header</a>,"]
    #[doc = "    i.e. the length of the metadata body that follows the header."]
    pub fn FLAC__metadata_simple_iterator_get_block_length(
        iterator: *const FLAC__Metadata_SimpleIterator,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Get the application ID of the \\c APPLICATION block at the current"]
    #[doc = "  position.  This avoids reading the actual block data which can save"]
    #[doc = "  time for large blocks."]
    #[doc = ""]
    #[doc = " \\param iterator  A pointer to an existing initialized iterator."]
    #[doc = " \\param id        A pointer to a buffer of at least \\c 4 bytes where"]
    #[doc = "                  the ID will be stored."]
    #[doc = " \\assert"]
    #[doc = "    \\code iterator != NULL \\endcode"]
    #[doc = "    \\code id != NULL \\endcode"]
    #[doc = "    \\a iterator has been successfully initialized with"]
    #[doc = "    FLAC__metadata_simple_iterator_init()"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c true if the ID was successfully read, else \\c false, in which"]
    #[doc = "    case you should check FLAC__metadata_simple_iterator_status() to"]
    #[doc = "    find out why.  If the status is"]
    #[doc = "    \\c FLAC__METADATA_SIMPLE_ITERATOR_STATUS_ILLEGAL_INPUT, then the"]
    #[doc = "    current metadata block is not an \\c APPLICATION block.  Otherwise"]
    #[doc = "    if the status is"]
    #[doc = "    \\c FLAC__METADATA_SIMPLE_ITERATOR_STATUS_READ_ERROR or"]
    #[doc = "    \\c FLAC__METADATA_SIMPLE_ITERATOR_STATUS_SEEK_ERROR, an I/O error"]
    #[doc = "    occurred and the iterator can no longer be used."]
    pub fn FLAC__metadata_simple_iterator_get_application_id(
        iterator: *mut FLAC__Metadata_SimpleIterator,
        id: *mut FLAC__byte,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Get the metadata block at the current position.  You can modify the"]
    #[doc = "  block but must use FLAC__metadata_simple_iterator_set_block() to"]
    #[doc = "  write it back to the FLAC file."]
    #[doc = ""]
    #[doc = "  You must call FLAC__metadata_object_delete() on the returned object"]
    #[doc = "  when you are finished with it."]
    #[doc = ""]
    #[doc = " \\param iterator  A pointer to an existing initialized iterator."]
    #[doc = " \\assert"]
    #[doc = "    \\code iterator != NULL \\endcode"]
    #[doc = "    \\a iterator has been successfully initialized with"]
    #[doc = "    FLAC__metadata_simple_iterator_init()"]
    #[doc = " \\retval FLAC__StreamMetadata*"]
    #[doc = "    The current metadata block, or \\c NULL if there was a memory"]
    #[doc = "    allocation error."]
    pub fn FLAC__metadata_simple_iterator_get_block(
        iterator: *mut FLAC__Metadata_SimpleIterator,
    ) -> *mut FLAC__StreamMetadata;
}
extern "C" {
    #[doc = " Write a block back to the FLAC file.  This function tries to be"]
    #[doc = "  as efficient as possible; how the block is actually written is"]
    #[doc = "  shown by the following:"]
    #[doc = ""]
    #[doc = "  Existing block is a STREAMINFO block and the new block is a"]
    #[doc = "  STREAMINFO block: the new block is written in place.  Make sure"]
    #[doc = "  you know what you\'re doing when changing the values of a"]
    #[doc = "  STREAMINFO block."]
    #[doc = ""]
    #[doc = "  Existing block is a STREAMINFO block and the new block is a"]
    #[doc = "  not a STREAMINFO block: this is an error since the first block"]
    #[doc = "  must be a STREAMINFO block.  Returns \\c false without altering the"]
    #[doc = "  file."]
    #[doc = ""]
    #[doc = "  Existing block is not a STREAMINFO block and the new block is a"]
    #[doc = "  STREAMINFO block: this is an error since there may be only one"]
    #[doc = "  STREAMINFO block.  Returns \\c false without altering the file."]
    #[doc = ""]
    #[doc = "  Existing block and new block are the same length: the existing"]
    #[doc = "  block will be replaced by the new block, written in place."]
    #[doc = ""]
    #[doc = "  Existing block is longer than new block: if use_padding is \\c true,"]
    #[doc = "  the existing block will be overwritten in place with the new"]
    #[doc = "  block followed by a PADDING block, if possible, to make the total"]
    #[doc = "  size the same as the existing block.  Remember that a padding"]
    #[doc = "  block requires at least four bytes so if the difference in size"]
    #[doc = "  between the new block and existing block is less than that, the"]
    #[doc = "  entire file will have to be rewritten, using the new block\'s"]
    #[doc = "  exact size.  If use_padding is \\c false, the entire file will be"]
    #[doc = "  rewritten, replacing the existing block by the new block."]
    #[doc = ""]
    #[doc = "  Existing block is shorter than new block: if use_padding is \\c true,"]
    #[doc = "  the function will try and expand the new block into the following"]
    #[doc = "  PADDING block, if it exists and doing so won\'t shrink the PADDING"]
    #[doc = "  block to less than 4 bytes.  If there is no following PADDING"]
    #[doc = "  block, or it will shrink to less than 4 bytes, or use_padding is"]
    #[doc = "  \\c false, the entire file is rewritten, replacing the existing block"]
    #[doc = "  with the new block.  Note that in this case any following PADDING"]
    #[doc = "  block is preserved as is."]
    #[doc = ""]
    #[doc = "  After writing the block, the iterator will remain in the same"]
    #[doc = "  place, i.e. pointing to the new block."]
    #[doc = ""]
    #[doc = " \\param iterator     A pointer to an existing initialized iterator."]
    #[doc = " \\param block        The block to set."]
    #[doc = " \\param use_padding  See above."]
    #[doc = " \\assert"]
    #[doc = "    \\code iterator != NULL \\endcode"]
    #[doc = "    \\a iterator has been successfully initialized with"]
    #[doc = "    FLAC__metadata_simple_iterator_init()"]
    #[doc = "    \\code block != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c true if successful, else \\c false."]
    pub fn FLAC__metadata_simple_iterator_set_block(
        iterator: *mut FLAC__Metadata_SimpleIterator,
        block: *mut FLAC__StreamMetadata,
        use_padding: FLAC__bool,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " This is similar to FLAC__metadata_simple_iterator_set_block()"]
    #[doc = "  except that instead of writing over an existing block, it appends"]
    #[doc = "  a block after the existing block.  \\a use_padding is again used to"]
    #[doc = "  tell the function to try an expand into following padding in an"]
    #[doc = "  attempt to avoid rewriting the entire file."]
    #[doc = ""]
    #[doc = "  This function will fail and return \\c false if given a STREAMINFO"]
    #[doc = "  block."]
    #[doc = ""]
    #[doc = "  After writing the block, the iterator will be pointing to the"]
    #[doc = "  new block."]
    #[doc = ""]
    #[doc = " \\param iterator     A pointer to an existing initialized iterator."]
    #[doc = " \\param block        The block to set."]
    #[doc = " \\param use_padding  See above."]
    #[doc = " \\assert"]
    #[doc = "    \\code iterator != NULL \\endcode"]
    #[doc = "    \\a iterator has been successfully initialized with"]
    #[doc = "    FLAC__metadata_simple_iterator_init()"]
    #[doc = "    \\code block != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c true if successful, else \\c false."]
    pub fn FLAC__metadata_simple_iterator_insert_block_after(
        iterator: *mut FLAC__Metadata_SimpleIterator,
        block: *mut FLAC__StreamMetadata,
        use_padding: FLAC__bool,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Deletes the block at the current position.  This will cause the"]
    #[doc = "  entire FLAC file to be rewritten, unless \\a use_padding is \\c true,"]
    #[doc = "  in which case the block will be replaced by an equal-sized PADDING"]
    #[doc = "  block.  The iterator will be left pointing to the block before the"]
    #[doc = "  one just deleted."]
    #[doc = ""]
    #[doc = "  You may not delete the STREAMINFO block."]
    #[doc = ""]
    #[doc = " \\param iterator     A pointer to an existing initialized iterator."]
    #[doc = " \\param use_padding  See above."]
    #[doc = " \\assert"]
    #[doc = "    \\code iterator != NULL \\endcode"]
    #[doc = "    \\a iterator has been successfully initialized with"]
    #[doc = "    FLAC__metadata_simple_iterator_init()"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c true if successful, else \\c false."]
    pub fn FLAC__metadata_simple_iterator_delete_block(
        iterator: *mut FLAC__Metadata_SimpleIterator,
        use_padding: FLAC__bool,
    ) -> FLAC__bool;
}
#[doc = " \\defgroup flac_metadata_level2 FLAC/metadata.h: metadata level 2 interface"]
#[doc = "  \\ingroup flac_metadata"]
#[doc = ""]
#[doc = " \\brief"]
#[doc = " The level 2 interface provides read-write access to FLAC file metadata;"]
#[doc = " all metadata is read into memory, operated on in memory, and then written"]
#[doc = " to file, which is more efficient than level 1 when editing multiple blocks."]
#[doc = ""]
#[doc = " Currently Ogg FLAC is supported for read only, via"]
#[doc = " FLAC__metadata_chain_read_ogg() but a subsequent"]
#[doc = " FLAC__metadata_chain_write() will fail."]
#[doc = ""]
#[doc = " The general usage of this interface is:"]
#[doc = ""]
#[doc = " - Create a new chain using FLAC__metadata_chain_new().  A chain is a"]
#[doc = "   linked list of FLAC metadata blocks."]
#[doc = " - Read all metadata into the chain from a FLAC file using"]
#[doc = "   FLAC__metadata_chain_read() or FLAC__metadata_chain_read_ogg() and"]
#[doc = "   check the status."]
#[doc = " - Optionally, consolidate the padding using"]
#[doc = "   FLAC__metadata_chain_merge_padding() or"]
#[doc = "   FLAC__metadata_chain_sort_padding()."]
#[doc = " - Create a new iterator using FLAC__metadata_iterator_new()"]
#[doc = " - Initialize the iterator to point to the first element in the chain"]
#[doc = "   using FLAC__metadata_iterator_init()"]
#[doc = " - Traverse the chain using FLAC__metadata_iterator_next and"]
#[doc = "   FLAC__metadata_iterator_prev()."]
#[doc = " - Get a block for reading or modification using"]
#[doc = "   FLAC__metadata_iterator_get_block().  The pointer to the object"]
#[doc = "   inside the chain is returned, so the block is yours to modify."]
#[doc = "   Changes will be reflected in the FLAC file when you write the"]
#[doc = "   chain.  You can also add and delete blocks (see functions below)."]
#[doc = " - When done, write out the chain using FLAC__metadata_chain_write()."]
#[doc = "   Make sure to read the whole comment to the function below."]
#[doc = " - Delete the chain using FLAC__metadata_chain_delete()."]
#[doc = ""]
#[doc = " \\note"]
#[doc = " Even though the FLAC file is not open while the chain is being"]
#[doc = " manipulated, you must not alter the file externally during"]
#[doc = " this time.  The chain assumes the FLAC file will not change"]
#[doc = " between the time of FLAC__metadata_chain_read()/FLAC__metadata_chain_read_ogg()"]
#[doc = " and FLAC__metadata_chain_write()."]
#[doc = ""]
#[doc = " \\note"]
#[doc = " Do not modify the is_last, length, or type fields of returned"]
#[doc = " FLAC__StreamMetadata objects.  These are managed automatically."]
#[doc = ""]
#[doc = " \\note"]
#[doc = " The metadata objects returned by FLAC__metadata_iterator_get_block()"]
#[doc = " are owned by the chain; do not FLAC__metadata_object_delete() them."]
#[doc = " In the same way, blocks passed to FLAC__metadata_iterator_set_block()"]
#[doc = " become owned by the chain and they will be deleted when the chain is"]
#[doc = " deleted."]
#[doc = ""]
#[doc = " \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__Metadata_Chain {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__Metadata_Iterator {
    _unused: [u8; 0],
}
pub const FLAC__Metadata_ChainStatus_FLAC__METADATA_CHAIN_STATUS_OK: FLAC__Metadata_ChainStatus = 0;
pub const FLAC__Metadata_ChainStatus_FLAC__METADATA_CHAIN_STATUS_ILLEGAL_INPUT:
    FLAC__Metadata_ChainStatus = 1;
pub const FLAC__Metadata_ChainStatus_FLAC__METADATA_CHAIN_STATUS_ERROR_OPENING_FILE:
    FLAC__Metadata_ChainStatus = 2;
pub const FLAC__Metadata_ChainStatus_FLAC__METADATA_CHAIN_STATUS_NOT_A_FLAC_FILE:
    FLAC__Metadata_ChainStatus = 3;
pub const FLAC__Metadata_ChainStatus_FLAC__METADATA_CHAIN_STATUS_NOT_WRITABLE:
    FLAC__Metadata_ChainStatus = 4;
pub const FLAC__Metadata_ChainStatus_FLAC__METADATA_CHAIN_STATUS_BAD_METADATA:
    FLAC__Metadata_ChainStatus = 5;
pub const FLAC__Metadata_ChainStatus_FLAC__METADATA_CHAIN_STATUS_READ_ERROR:
    FLAC__Metadata_ChainStatus = 6;
pub const FLAC__Metadata_ChainStatus_FLAC__METADATA_CHAIN_STATUS_SEEK_ERROR:
    FLAC__Metadata_ChainStatus = 7;
pub const FLAC__Metadata_ChainStatus_FLAC__METADATA_CHAIN_STATUS_WRITE_ERROR:
    FLAC__Metadata_ChainStatus = 8;
pub const FLAC__Metadata_ChainStatus_FLAC__METADATA_CHAIN_STATUS_RENAME_ERROR:
    FLAC__Metadata_ChainStatus = 9;
pub const FLAC__Metadata_ChainStatus_FLAC__METADATA_CHAIN_STATUS_UNLINK_ERROR:
    FLAC__Metadata_ChainStatus = 10;
pub const FLAC__Metadata_ChainStatus_FLAC__METADATA_CHAIN_STATUS_MEMORY_ALLOCATION_ERROR:
    FLAC__Metadata_ChainStatus = 11;
pub const FLAC__Metadata_ChainStatus_FLAC__METADATA_CHAIN_STATUS_INTERNAL_ERROR:
    FLAC__Metadata_ChainStatus = 12;
pub const FLAC__Metadata_ChainStatus_FLAC__METADATA_CHAIN_STATUS_INVALID_CALLBACKS:
    FLAC__Metadata_ChainStatus = 13;
pub const FLAC__Metadata_ChainStatus_FLAC__METADATA_CHAIN_STATUS_READ_WRITE_MISMATCH:
    FLAC__Metadata_ChainStatus = 14;
pub const FLAC__Metadata_ChainStatus_FLAC__METADATA_CHAIN_STATUS_WRONG_WRITE_CALL:
    FLAC__Metadata_ChainStatus = 15;
pub type FLAC__Metadata_ChainStatus = u32;
extern "C" {
    #[link_name = "\u{1}FLAC__Metadata_ChainStatusString"]
    pub static mut FLAC__Metadata_ChainStatusString: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    #[doc = " Create a new chain instance."]
    #[doc = ""]
    #[doc = " \\retval FLAC__Metadata_Chain*"]
    #[doc = "    \\c NULL if there was an error allocating memory, else the new instance."]
    pub fn FLAC__metadata_chain_new() -> *mut FLAC__Metadata_Chain;
}
extern "C" {
    #[doc = " Free a chain instance.  Deletes the object pointed to by \\a chain."]
    #[doc = ""]
    #[doc = " \\param chain  A pointer to an existing chain."]
    #[doc = " \\assert"]
    #[doc = "    \\code chain != NULL \\endcode"]
    pub fn FLAC__metadata_chain_delete(chain: *mut FLAC__Metadata_Chain);
}
extern "C" {
    #[doc = " Get the current status of the chain.  Call this after a function"]
    #[doc = "  returns \\c false to get the reason for the error.  Also resets the"]
    #[doc = "  status to FLAC__METADATA_CHAIN_STATUS_OK."]
    #[doc = ""]
    #[doc = " \\param chain    A pointer to an existing chain."]
    #[doc = " \\assert"]
    #[doc = "    \\code chain != NULL \\endcode"]
    #[doc = " \\retval FLAC__Metadata_ChainStatus"]
    #[doc = "    The current status of the chain."]
    pub fn FLAC__metadata_chain_status(
        chain: *mut FLAC__Metadata_Chain,
    ) -> FLAC__Metadata_ChainStatus;
}
extern "C" {
    #[doc = " Read all metadata from a FLAC file into the chain."]
    #[doc = ""]
    #[doc = " \\param chain    A pointer to an existing chain."]
    #[doc = " \\param filename The path to the FLAC file to read."]
    #[doc = " \\assert"]
    #[doc = "    \\code chain != NULL \\endcode"]
    #[doc = "    \\code filename != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c true if a valid list of metadata blocks was read from"]
    #[doc = "    \\a filename, else \\c false.  On failure, check the status with"]
    #[doc = "    FLAC__metadata_chain_status()."]
    pub fn FLAC__metadata_chain_read(
        chain: *mut FLAC__Metadata_Chain,
        filename: *const ::std::os::raw::c_char,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Read all metadata from an Ogg FLAC file into the chain."]
    #[doc = ""]
    #[doc = " \\note Ogg FLAC metadata data writing is not supported yet and"]
    #[doc = " FLAC__metadata_chain_write() will fail."]
    #[doc = ""]
    #[doc = " \\param chain    A pointer to an existing chain."]
    #[doc = " \\param filename The path to the Ogg FLAC file to read."]
    #[doc = " \\assert"]
    #[doc = "    \\code chain != NULL \\endcode"]
    #[doc = "    \\code filename != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c true if a valid list of metadata blocks was read from"]
    #[doc = "    \\a filename, else \\c false.  On failure, check the status with"]
    #[doc = "    FLAC__metadata_chain_status()."]
    pub fn FLAC__metadata_chain_read_ogg(
        chain: *mut FLAC__Metadata_Chain,
        filename: *const ::std::os::raw::c_char,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Read all metadata from a FLAC stream into the chain via I/O callbacks."]
    #[doc = ""]
    #[doc = "  The \\a handle need only be open for reading, but must be seekable."]
    #[doc = "  The equivalent minimum stdio fopen() file mode is \\c \"r\" (or \\c \"rb\""]
    #[doc = "  for Windows)."]
    #[doc = ""]
    #[doc = " \\param chain    A pointer to an existing chain."]
    #[doc = " \\param handle   The I/O handle of the FLAC stream to read.  The"]
    #[doc = "                 handle will NOT be closed after the metadata is read;"]
    #[doc = "                 that is the duty of the caller."]
    #[doc = " \\param callbacks"]
    #[doc = "                 A set of callbacks to use for I/O.  The mandatory"]
    #[doc = "                 callbacks are \\a read, \\a seek, and \\a tell."]
    #[doc = " \\assert"]
    #[doc = "    \\code chain != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c true if a valid list of metadata blocks was read from"]
    #[doc = "    \\a handle, else \\c false.  On failure, check the status with"]
    #[doc = "    FLAC__metadata_chain_status()."]
    pub fn FLAC__metadata_chain_read_with_callbacks(
        chain: *mut FLAC__Metadata_Chain,
        handle: FLAC__IOHandle,
        callbacks: FLAC__IOCallbacks,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Read all metadata from an Ogg FLAC stream into the chain via I/O callbacks."]
    #[doc = ""]
    #[doc = "  The \\a handle need only be open for reading, but must be seekable."]
    #[doc = "  The equivalent minimum stdio fopen() file mode is \\c \"r\" (or \\c \"rb\""]
    #[doc = "  for Windows)."]
    #[doc = ""]
    #[doc = " \\note Ogg FLAC metadata data writing is not supported yet and"]
    #[doc = " FLAC__metadata_chain_write() will fail."]
    #[doc = ""]
    #[doc = " \\param chain    A pointer to an existing chain."]
    #[doc = " \\param handle   The I/O handle of the Ogg FLAC stream to read.  The"]
    #[doc = "                 handle will NOT be closed after the metadata is read;"]
    #[doc = "                 that is the duty of the caller."]
    #[doc = " \\param callbacks"]
    #[doc = "                 A set of callbacks to use for I/O.  The mandatory"]
    #[doc = "                 callbacks are \\a read, \\a seek, and \\a tell."]
    #[doc = " \\assert"]
    #[doc = "    \\code chain != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c true if a valid list of metadata blocks was read from"]
    #[doc = "    \\a handle, else \\c false.  On failure, check the status with"]
    #[doc = "    FLAC__metadata_chain_status()."]
    pub fn FLAC__metadata_chain_read_ogg_with_callbacks(
        chain: *mut FLAC__Metadata_Chain,
        handle: FLAC__IOHandle,
        callbacks: FLAC__IOCallbacks,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Checks if writing the given chain would require the use of a"]
    #[doc = "  temporary file, or if it could be written in place."]
    #[doc = ""]
    #[doc = "  Under certain conditions, padding can be utilized so that writing"]
    #[doc = "  edited metadata back to the FLAC file does not require rewriting the"]
    #[doc = "  entire file.  If rewriting is required, then a temporary workfile is"]
    #[doc = "  required.  When writing metadata using callbacks, you must check"]
    #[doc = "  this function to know whether to call"]
    #[doc = "  FLAC__metadata_chain_write_with_callbacks() or"]
    #[doc = "  FLAC__metadata_chain_write_with_callbacks_and_tempfile().  When"]
    #[doc = "  writing with FLAC__metadata_chain_write(), the temporary file is"]
    #[doc = "  handled internally."]
    #[doc = ""]
    #[doc = " \\param chain    A pointer to an existing chain."]
    #[doc = " \\param use_padding"]
    #[doc = "                 Whether or not padding will be allowed to be used"]
    #[doc = "                 during the write.  The value of \\a use_padding given"]
    #[doc = "                 here must match the value later passed to"]
    #[doc = "                 FLAC__metadata_chain_write_with_callbacks() or"]
    #[doc = "                 FLAC__metadata_chain_write_with_callbacks_with_tempfile()."]
    #[doc = " \\assert"]
    #[doc = "    \\code chain != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c true if writing the current chain would require a tempfile, or"]
    #[doc = "    \\c false if metadata can be written in place."]
    pub fn FLAC__metadata_chain_check_if_tempfile_needed(
        chain: *mut FLAC__Metadata_Chain,
        use_padding: FLAC__bool,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Write all metadata out to the FLAC file.  This function tries to be as"]
    #[doc = "  efficient as possible; how the metadata is actually written is shown by"]
    #[doc = "  the following:"]
    #[doc = ""]
    #[doc = "  If the current chain is the same size as the existing metadata, the new"]
    #[doc = "  data is written in place."]
    #[doc = ""]
    #[doc = "  If the current chain is longer than the existing metadata, and"]
    #[doc = "  \\a use_padding is \\c true, and the last block is a PADDING block of"]
    #[doc = "  sufficient length, the function will truncate the final padding block"]
    #[doc = "  so that the overall size of the metadata is the same as the existing"]
    #[doc = "  metadata, and then just rewrite the metadata.  Otherwise, if not all of"]
    #[doc = "  the above conditions are met, the entire FLAC file must be rewritten."]
    #[doc = "  If you want to use padding this way it is a good idea to call"]
    #[doc = "  FLAC__metadata_chain_sort_padding() first so that you have the maximum"]
    #[doc = "  amount of padding to work with, unless you need to preserve ordering"]
    #[doc = "  of the PADDING blocks for some reason."]
    #[doc = ""]
    #[doc = "  If the current chain is shorter than the existing metadata, and"]
    #[doc = "  \\a use_padding is \\c true, and the final block is a PADDING block, the padding"]
    #[doc = "  is extended to make the overall size the same as the existing data.  If"]
    #[doc = "  \\a use_padding is \\c true and the last block is not a PADDING block, a new"]
    #[doc = "  PADDING block is added to the end of the new data to make it the same"]
    #[doc = "  size as the existing data (if possible, see the note to"]
    #[doc = "  FLAC__metadata_simple_iterator_set_block() about the four byte limit)"]
    #[doc = "  and the new data is written in place.  If none of the above apply or"]
    #[doc = "  \\a use_padding is \\c false, the entire FLAC file is rewritten."]
    #[doc = ""]
    #[doc = "  If \\a preserve_file_stats is \\c true, the owner and modification time will"]
    #[doc = "  be preserved even if the FLAC file is written."]
    #[doc = ""]
    #[doc = "  For this write function to be used, the chain must have been read with"]
    #[doc = "  FLAC__metadata_chain_read()/FLAC__metadata_chain_read_ogg(), not"]
    #[doc = "  FLAC__metadata_chain_read_with_callbacks()/FLAC__metadata_chain_read_ogg_with_callbacks()."]
    #[doc = ""]
    #[doc = " \\param chain               A pointer to an existing chain."]
    #[doc = " \\param use_padding         See above."]
    #[doc = " \\param preserve_file_stats See above."]
    #[doc = " \\assert"]
    #[doc = "    \\code chain != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c true if the write succeeded, else \\c false.  On failure,"]
    #[doc = "    check the status with FLAC__metadata_chain_status()."]
    pub fn FLAC__metadata_chain_write(
        chain: *mut FLAC__Metadata_Chain,
        use_padding: FLAC__bool,
        preserve_file_stats: FLAC__bool,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Write all metadata out to a FLAC stream via callbacks."]
    #[doc = ""]
    #[doc = "  (See FLAC__metadata_chain_write() for the details on how padding is"]
    #[doc = "  used to write metadata in place if possible.)"]
    #[doc = ""]
    #[doc = "  The \\a handle must be open for updating and be seekable.  The"]
    #[doc = "  equivalent minimum stdio fopen() file mode is \\c \"r+\" (or \\c \"r+b\""]
    #[doc = "  for Windows)."]
    #[doc = ""]
    #[doc = "  For this write function to be used, the chain must have been read with"]
    #[doc = "  FLAC__metadata_chain_read_with_callbacks()/FLAC__metadata_chain_read_ogg_with_callbacks(),"]
    #[doc = "  not FLAC__metadata_chain_read()/FLAC__metadata_chain_read_ogg()."]
    #[doc = "  Also, FLAC__metadata_chain_check_if_tempfile_needed() must have returned"]
    #[doc = "  \\c false."]
    #[doc = ""]
    #[doc = " \\param chain        A pointer to an existing chain."]
    #[doc = " \\param use_padding  See FLAC__metadata_chain_write()"]
    #[doc = " \\param handle       The I/O handle of the FLAC stream to write.  The"]
    #[doc = "                     handle will NOT be closed after the metadata is"]
    #[doc = "                     written; that is the duty of the caller."]
    #[doc = " \\param callbacks    A set of callbacks to use for I/O.  The mandatory"]
    #[doc = "                     callbacks are \\a write and \\a seek."]
    #[doc = " \\assert"]
    #[doc = "    \\code chain != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c true if the write succeeded, else \\c false.  On failure,"]
    #[doc = "    check the status with FLAC__metadata_chain_status()."]
    pub fn FLAC__metadata_chain_write_with_callbacks(
        chain: *mut FLAC__Metadata_Chain,
        use_padding: FLAC__bool,
        handle: FLAC__IOHandle,
        callbacks: FLAC__IOCallbacks,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Write all metadata out to a FLAC stream via callbacks."]
    #[doc = ""]
    #[doc = "  (See FLAC__metadata_chain_write() for the details on how padding is"]
    #[doc = "  used to write metadata in place if possible.)"]
    #[doc = ""]
    #[doc = "  This version of the write-with-callbacks function must be used when"]
    #[doc = "  FLAC__metadata_chain_check_if_tempfile_needed() returns true.  In"]
    #[doc = "  this function, you must supply an I/O handle corresponding to the"]
    #[doc = "  FLAC file to edit, and a temporary handle to which the new FLAC"]
    #[doc = "  file will be written.  It is the caller\'s job to move this temporary"]
    #[doc = "  FLAC file on top of the original FLAC file to complete the metadata"]
    #[doc = "  edit."]
    #[doc = ""]
    #[doc = "  The \\a handle must be open for reading and be seekable.  The"]
    #[doc = "  equivalent minimum stdio fopen() file mode is \\c \"r\" (or \\c \"rb\""]
    #[doc = "  for Windows)."]
    #[doc = ""]
    #[doc = "  The \\a temp_handle must be open for writing.  The"]
    #[doc = "  equivalent minimum stdio fopen() file mode is \\c \"w\" (or \\c \"wb\""]
    #[doc = "  for Windows).  It should be an empty stream, or at least positioned"]
    #[doc = "  at the start-of-file (in which case it is the caller\'s duty to"]
    #[doc = "  truncate it on return)."]
    #[doc = ""]
    #[doc = "  For this write function to be used, the chain must have been read with"]
    #[doc = "  FLAC__metadata_chain_read_with_callbacks()/FLAC__metadata_chain_read_ogg_with_callbacks(),"]
    #[doc = "  not FLAC__metadata_chain_read()/FLAC__metadata_chain_read_ogg()."]
    #[doc = "  Also, FLAC__metadata_chain_check_if_tempfile_needed() must have returned"]
    #[doc = "  \\c true."]
    #[doc = ""]
    #[doc = " \\param chain        A pointer to an existing chain."]
    #[doc = " \\param use_padding  See FLAC__metadata_chain_write()"]
    #[doc = " \\param handle       The I/O handle of the original FLAC stream to read."]
    #[doc = "                     The handle will NOT be closed after the metadata is"]
    #[doc = "                     written; that is the duty of the caller."]
    #[doc = " \\param callbacks    A set of callbacks to use for I/O on \\a handle."]
    #[doc = "                     The mandatory callbacks are \\a read, \\a seek, and"]
    #[doc = "                     \\a eof."]
    #[doc = " \\param temp_handle  The I/O handle of the FLAC stream to write.  The"]
    #[doc = "                     handle will NOT be closed after the metadata is"]
    #[doc = "                     written; that is the duty of the caller."]
    #[doc = " \\param temp_callbacks"]
    #[doc = "                     A set of callbacks to use for I/O on temp_handle."]
    #[doc = "                     The only mandatory callback is \\a write."]
    #[doc = " \\assert"]
    #[doc = "    \\code chain != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c true if the write succeeded, else \\c false.  On failure,"]
    #[doc = "    check the status with FLAC__metadata_chain_status()."]
    pub fn FLAC__metadata_chain_write_with_callbacks_and_tempfile(
        chain: *mut FLAC__Metadata_Chain,
        use_padding: FLAC__bool,
        handle: FLAC__IOHandle,
        callbacks: FLAC__IOCallbacks,
        temp_handle: FLAC__IOHandle,
        temp_callbacks: FLAC__IOCallbacks,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Merge adjacent PADDING blocks into a single block."]
    #[doc = ""]
    #[doc = " \\note This function does not write to the FLAC file, it only"]
    #[doc = " modifies the chain."]
    #[doc = ""]
    #[doc = " \\warning Any iterator on the current chain will become invalid after this"]
    #[doc = " call.  You should delete the iterator and get a new one."]
    #[doc = ""]
    #[doc = " \\param chain               A pointer to an existing chain."]
    #[doc = " \\assert"]
    #[doc = "    \\code chain != NULL \\endcode"]
    pub fn FLAC__metadata_chain_merge_padding(chain: *mut FLAC__Metadata_Chain);
}
extern "C" {
    #[doc = " This function will move all PADDING blocks to the end on the metadata,"]
    #[doc = "  then merge them into a single block."]
    #[doc = ""]
    #[doc = " \\note This function does not write to the FLAC file, it only"]
    #[doc = " modifies the chain."]
    #[doc = ""]
    #[doc = " \\warning Any iterator on the current chain will become invalid after this"]
    #[doc = " call.  You should delete the iterator and get a new one."]
    #[doc = ""]
    #[doc = " \\param chain  A pointer to an existing chain."]
    #[doc = " \\assert"]
    #[doc = "    \\code chain != NULL \\endcode"]
    pub fn FLAC__metadata_chain_sort_padding(chain: *mut FLAC__Metadata_Chain);
}
extern "C" {
    #[doc = " Create a new iterator instance."]
    #[doc = ""]
    #[doc = " \\retval FLAC__Metadata_Iterator*"]
    #[doc = "    \\c NULL if there was an error allocating memory, else the new instance."]
    pub fn FLAC__metadata_iterator_new() -> *mut FLAC__Metadata_Iterator;
}
extern "C" {
    #[doc = " Free an iterator instance.  Deletes the object pointed to by \\a iterator."]
    #[doc = ""]
    #[doc = " \\param iterator  A pointer to an existing iterator."]
    #[doc = " \\assert"]
    #[doc = "    \\code iterator != NULL \\endcode"]
    pub fn FLAC__metadata_iterator_delete(iterator: *mut FLAC__Metadata_Iterator);
}
extern "C" {
    #[doc = " Initialize the iterator to point to the first metadata block in the"]
    #[doc = "  given chain."]
    #[doc = ""]
    #[doc = " \\param iterator  A pointer to an existing iterator."]
    #[doc = " \\param chain     A pointer to an existing and initialized (read) chain."]
    #[doc = " \\assert"]
    #[doc = "    \\code iterator != NULL \\endcode"]
    #[doc = "    \\code chain != NULL \\endcode"]
    pub fn FLAC__metadata_iterator_init(
        iterator: *mut FLAC__Metadata_Iterator,
        chain: *mut FLAC__Metadata_Chain,
    );
}
extern "C" {
    #[doc = " Moves the iterator forward one metadata block, returning \\c false if"]
    #[doc = "  already at the end."]
    #[doc = ""]
    #[doc = " \\param iterator  A pointer to an existing initialized iterator."]
    #[doc = " \\assert"]
    #[doc = "    \\code iterator != NULL \\endcode"]
    #[doc = "    \\a iterator has been successfully initialized with"]
    #[doc = "    FLAC__metadata_iterator_init()"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if already at the last metadata block of the chain, else"]
    #[doc = "    \\c true."]
    pub fn FLAC__metadata_iterator_next(iterator: *mut FLAC__Metadata_Iterator) -> FLAC__bool;
}
extern "C" {
    #[doc = " Moves the iterator backward one metadata block, returning \\c false if"]
    #[doc = "  already at the beginning."]
    #[doc = ""]
    #[doc = " \\param iterator  A pointer to an existing initialized iterator."]
    #[doc = " \\assert"]
    #[doc = "    \\code iterator != NULL \\endcode"]
    #[doc = "    \\a iterator has been successfully initialized with"]
    #[doc = "    FLAC__metadata_iterator_init()"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if already at the first metadata block of the chain, else"]
    #[doc = "    \\c true."]
    pub fn FLAC__metadata_iterator_prev(iterator: *mut FLAC__Metadata_Iterator) -> FLAC__bool;
}
extern "C" {
    #[doc = " Get the type of the metadata block at the current position."]
    #[doc = ""]
    #[doc = " \\param iterator  A pointer to an existing initialized iterator."]
    #[doc = " \\assert"]
    #[doc = "    \\code iterator != NULL \\endcode"]
    #[doc = "    \\a iterator has been successfully initialized with"]
    #[doc = "    FLAC__metadata_iterator_init()"]
    #[doc = " \\retval FLAC__MetadataType"]
    #[doc = "    The type of the metadata block at the current iterator position."]
    pub fn FLAC__metadata_iterator_get_block_type(
        iterator: *const FLAC__Metadata_Iterator,
    ) -> FLAC__MetadataType;
}
extern "C" {
    #[doc = " Get the metadata block at the current position.  You can modify"]
    #[doc = "  the block in place but must write the chain before the changes"]
    #[doc = "  are reflected to the FLAC file.  You do not need to call"]
    #[doc = "  FLAC__metadata_iterator_set_block() to reflect the changes;"]
    #[doc = "  the pointer returned by FLAC__metadata_iterator_get_block()"]
    #[doc = "  points directly into the chain."]
    #[doc = ""]
    #[doc = " \\warning"]
    #[doc = " Do not call FLAC__metadata_object_delete() on the returned object;"]
    #[doc = " to delete a block use FLAC__metadata_iterator_delete_block()."]
    #[doc = ""]
    #[doc = " \\param iterator  A pointer to an existing initialized iterator."]
    #[doc = " \\assert"]
    #[doc = "    \\code iterator != NULL \\endcode"]
    #[doc = "    \\a iterator has been successfully initialized with"]
    #[doc = "    FLAC__metadata_iterator_init()"]
    #[doc = " \\retval FLAC__StreamMetadata*"]
    #[doc = "    The current metadata block."]
    pub fn FLAC__metadata_iterator_get_block(
        iterator: *mut FLAC__Metadata_Iterator,
    ) -> *mut FLAC__StreamMetadata;
}
extern "C" {
    #[doc = " Set the metadata block at the current position, replacing the existing"]
    #[doc = "  block.  The new block passed in becomes owned by the chain and it will be"]
    #[doc = "  deleted when the chain is deleted."]
    #[doc = ""]
    #[doc = " \\param iterator  A pointer to an existing initialized iterator."]
    #[doc = " \\param block     A pointer to a metadata block."]
    #[doc = " \\assert"]
    #[doc = "    \\code iterator != NULL \\endcode"]
    #[doc = "    \\a iterator has been successfully initialized with"]
    #[doc = "    FLAC__metadata_iterator_init()"]
    #[doc = "    \\code block != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if the conditions in the above description are not met, or"]
    #[doc = "    a memory allocation error occurs, otherwise \\c true."]
    pub fn FLAC__metadata_iterator_set_block(
        iterator: *mut FLAC__Metadata_Iterator,
        block: *mut FLAC__StreamMetadata,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Removes the current block from the chain.  If \\a replace_with_padding is"]
    #[doc = "  \\c true, the block will instead be replaced with a padding block of equal"]
    #[doc = "  size.  You can not delete the STREAMINFO block.  The iterator will be"]
    #[doc = "  left pointing to the block before the one just \"deleted\", even if"]
    #[doc = "  \\a replace_with_padding is \\c true."]
    #[doc = ""]
    #[doc = " \\param iterator              A pointer to an existing initialized iterator."]
    #[doc = " \\param replace_with_padding  See above."]
    #[doc = " \\assert"]
    #[doc = "    \\code iterator != NULL \\endcode"]
    #[doc = "    \\a iterator has been successfully initialized with"]
    #[doc = "    FLAC__metadata_iterator_init()"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if the conditions in the above description are not met,"]
    #[doc = "    otherwise \\c true."]
    pub fn FLAC__metadata_iterator_delete_block(
        iterator: *mut FLAC__Metadata_Iterator,
        replace_with_padding: FLAC__bool,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Insert a new block before the current block.  You cannot insert a block"]
    #[doc = "  before the first STREAMINFO block.  You cannot insert a STREAMINFO block"]
    #[doc = "  as there can be only one, the one that already exists at the head when you"]
    #[doc = "  read in a chain.  The chain takes ownership of the new block and it will be"]
    #[doc = "  deleted when the chain is deleted.  The iterator will be left pointing to"]
    #[doc = "  the new block."]
    #[doc = ""]
    #[doc = " \\param iterator  A pointer to an existing initialized iterator."]
    #[doc = " \\param block     A pointer to a metadata block to insert."]
    #[doc = " \\assert"]
    #[doc = "    \\code iterator != NULL \\endcode"]
    #[doc = "    \\a iterator has been successfully initialized with"]
    #[doc = "    FLAC__metadata_iterator_init()"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if the conditions in the above description are not met, or"]
    #[doc = "    a memory allocation error occurs, otherwise \\c true."]
    pub fn FLAC__metadata_iterator_insert_block_before(
        iterator: *mut FLAC__Metadata_Iterator,
        block: *mut FLAC__StreamMetadata,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Insert a new block after the current block.  You cannot insert a STREAMINFO"]
    #[doc = "  block as there can be only one, the one that already exists at the head when"]
    #[doc = "  you read in a chain.  The chain takes ownership of the new block and it will"]
    #[doc = "  be deleted when the chain is deleted.  The iterator will be left pointing to"]
    #[doc = "  the new block."]
    #[doc = ""]
    #[doc = " \\param iterator  A pointer to an existing initialized iterator."]
    #[doc = " \\param block     A pointer to a metadata block to insert."]
    #[doc = " \\assert"]
    #[doc = "    \\code iterator != NULL \\endcode"]
    #[doc = "    \\a iterator has been successfully initialized with"]
    #[doc = "    FLAC__metadata_iterator_init()"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if the conditions in the above description are not met, or"]
    #[doc = "    a memory allocation error occurs, otherwise \\c true."]
    pub fn FLAC__metadata_iterator_insert_block_after(
        iterator: *mut FLAC__Metadata_Iterator,
        block: *mut FLAC__StreamMetadata,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Create a new metadata object instance of the given type."]
    #[doc = ""]
    #[doc = "  The object will be \"empty\"; i.e. values and data pointers will be \\c 0,"]
    #[doc = "  with the exception of FLAC__METADATA_TYPE_VORBIS_COMMENT, which will have"]
    #[doc = "  the vendor string set (but zero comments)."]
    #[doc = ""]
    #[doc = "  Do not pass in a value greater than or equal to"]
    #[doc = "  \\a FLAC__METADATA_TYPE_UNDEFINED unless you really know what you\'re"]
    #[doc = "  doing."]
    #[doc = ""]
    #[doc = " \\param type  Type of object to create"]
    #[doc = " \\retval FLAC__StreamMetadata*"]
    #[doc = "    \\c NULL if there was an error allocating memory or the type code is"]
    #[doc = "    greater than FLAC__MAX_METADATA_TYPE_CODE, else the new instance."]
    pub fn FLAC__metadata_object_new(type_: FLAC__MetadataType) -> *mut FLAC__StreamMetadata;
}
extern "C" {
    #[doc = " Create a copy of an existing metadata object."]
    #[doc = ""]
    #[doc = "  The copy is a \"deep\" copy, i.e. dynamically allocated data within the"]
    #[doc = "  object is also copied.  The caller takes ownership of the new block and"]
    #[doc = "  is responsible for freeing it with FLAC__metadata_object_delete()."]
    #[doc = ""]
    #[doc = " \\param object  Pointer to object to copy."]
    #[doc = " \\assert"]
    #[doc = "    \\code object != NULL \\endcode"]
    #[doc = " \\retval FLAC__StreamMetadata*"]
    #[doc = "    \\c NULL if there was an error allocating memory, else the new instance."]
    pub fn FLAC__metadata_object_clone(
        object: *const FLAC__StreamMetadata,
    ) -> *mut FLAC__StreamMetadata;
}
extern "C" {
    #[doc = " Free a metadata object.  Deletes the object pointed to by \\a object."]
    #[doc = ""]
    #[doc = "  The delete is a \"deep\" delete, i.e. dynamically allocated data within the"]
    #[doc = "  object is also deleted."]
    #[doc = ""]
    #[doc = " \\param object  A pointer to an existing object."]
    #[doc = " \\assert"]
    #[doc = "    \\code object != NULL \\endcode"]
    pub fn FLAC__metadata_object_delete(object: *mut FLAC__StreamMetadata);
}
extern "C" {
    #[doc = " Compares two metadata objects."]
    #[doc = ""]
    #[doc = "  The compare is \"deep\", i.e. dynamically allocated data within the"]
    #[doc = "  object is also compared."]
    #[doc = ""]
    #[doc = " \\param block1  A pointer to an existing object."]
    #[doc = " \\param block2  A pointer to an existing object."]
    #[doc = " \\assert"]
    #[doc = "    \\code block1 != NULL \\endcode"]
    #[doc = "    \\code block2 != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c true if objects are identical, else \\c false."]
    pub fn FLAC__metadata_object_is_equal(
        block1: *const FLAC__StreamMetadata,
        block2: *const FLAC__StreamMetadata,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Sets the application data of an APPLICATION block."]
    #[doc = ""]
    #[doc = "  If \\a copy is \\c true, a copy of the data is stored; otherwise, the object"]
    #[doc = "  takes ownership of the pointer.  The existing data will be freed if this"]
    #[doc = "  function is successful, otherwise the original data will remain if \\a copy"]
    #[doc = "  is \\c true and malloc() fails."]
    #[doc = ""]
    #[doc = " \\note It is safe to pass a const pointer to \\a data if \\a copy is \\c true."]
    #[doc = ""]
    #[doc = " \\param object  A pointer to an existing APPLICATION object."]
    #[doc = " \\param data    A pointer to the data to set."]
    #[doc = " \\param length  The length of \\a data in bytes."]
    #[doc = " \\param copy    See above."]
    #[doc = " \\assert"]
    #[doc = "    \\code object != NULL \\endcode"]
    #[doc = "    \\code object->type == FLAC__METADATA_TYPE_APPLICATION \\endcode"]
    #[doc = "    \\code (data != NULL && length > 0) ||"]
    #[doc = " (data == NULL && length == 0 && copy == false) \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if \\a copy is \\c true and malloc() fails, else \\c true."]
    pub fn FLAC__metadata_object_application_set_data(
        object: *mut FLAC__StreamMetadata,
        data: *mut FLAC__byte,
        length: ::std::os::raw::c_uint,
        copy: FLAC__bool,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Resize the seekpoint array."]
    #[doc = ""]
    #[doc = "  If the size shrinks, elements will truncated; if it grows, new placeholder"]
    #[doc = "  points will be added to the end."]
    #[doc = ""]
    #[doc = " \\param object          A pointer to an existing SEEKTABLE object."]
    #[doc = " \\param new_num_points  The desired length of the array; may be \\c 0."]
    #[doc = " \\assert"]
    #[doc = "    \\code object != NULL \\endcode"]
    #[doc = "    \\code object->type == FLAC__METADATA_TYPE_SEEKTABLE \\endcode"]
    #[doc = "    \\code (object->data.seek_table.points == NULL && object->data.seek_table.num_points == 0) ||"]
    #[doc = " (object->data.seek_table.points != NULL && object->data.seek_table.num_points > 0) \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if memory allocation error, else \\c true."]
    pub fn FLAC__metadata_object_seektable_resize_points(
        object: *mut FLAC__StreamMetadata,
        new_num_points: ::std::os::raw::c_uint,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Set a seekpoint in a seektable."]
    #[doc = ""]
    #[doc = " \\param object     A pointer to an existing SEEKTABLE object."]
    #[doc = " \\param point_num  Index into seekpoint array to set."]
    #[doc = " \\param point      The point to set."]
    #[doc = " \\assert"]
    #[doc = "    \\code object != NULL \\endcode"]
    #[doc = "    \\code object->type == FLAC__METADATA_TYPE_SEEKTABLE \\endcode"]
    #[doc = "    \\code object->data.seek_table.num_points > point_num \\endcode"]
    pub fn FLAC__metadata_object_seektable_set_point(
        object: *mut FLAC__StreamMetadata,
        point_num: ::std::os::raw::c_uint,
        point: FLAC__StreamMetadata_SeekPoint,
    );
}
extern "C" {
    #[doc = " Insert a seekpoint into a seektable."]
    #[doc = ""]
    #[doc = " \\param object     A pointer to an existing SEEKTABLE object."]
    #[doc = " \\param point_num  Index into seekpoint array to set."]
    #[doc = " \\param point      The point to set."]
    #[doc = " \\assert"]
    #[doc = "    \\code object != NULL \\endcode"]
    #[doc = "    \\code object->type == FLAC__METADATA_TYPE_SEEKTABLE \\endcode"]
    #[doc = "    \\code object->data.seek_table.num_points >= point_num \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if memory allocation error, else \\c true."]
    pub fn FLAC__metadata_object_seektable_insert_point(
        object: *mut FLAC__StreamMetadata,
        point_num: ::std::os::raw::c_uint,
        point: FLAC__StreamMetadata_SeekPoint,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Delete a seekpoint from a seektable."]
    #[doc = ""]
    #[doc = " \\param object     A pointer to an existing SEEKTABLE object."]
    #[doc = " \\param point_num  Index into seekpoint array to set."]
    #[doc = " \\assert"]
    #[doc = "    \\code object != NULL \\endcode"]
    #[doc = "    \\code object->type == FLAC__METADATA_TYPE_SEEKTABLE \\endcode"]
    #[doc = "    \\code object->data.seek_table.num_points > point_num \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if memory allocation error, else \\c true."]
    pub fn FLAC__metadata_object_seektable_delete_point(
        object: *mut FLAC__StreamMetadata,
        point_num: ::std::os::raw::c_uint,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Check a seektable to see if it conforms to the FLAC specification."]
    #[doc = "  See the format specification for limits on the contents of the"]
    #[doc = "  seektable."]
    #[doc = ""]
    #[doc = " \\param object  A pointer to an existing SEEKTABLE object."]
    #[doc = " \\assert"]
    #[doc = "    \\code object != NULL \\endcode"]
    #[doc = "    \\code object->type == FLAC__METADATA_TYPE_SEEKTABLE \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if seek table is illegal, else \\c true."]
    pub fn FLAC__metadata_object_seektable_is_legal(
        object: *const FLAC__StreamMetadata,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Append a number of placeholder points to the end of a seek table."]
    #[doc = ""]
    #[doc = " \\note"]
    #[doc = " As with the other ..._seektable_template_... functions, you should"]
    #[doc = " call FLAC__metadata_object_seektable_template_sort() when finished"]
    #[doc = " to make the seek table legal."]
    #[doc = ""]
    #[doc = " \\param object  A pointer to an existing SEEKTABLE object."]
    #[doc = " \\param num     The number of placeholder points to append."]
    #[doc = " \\assert"]
    #[doc = "    \\code object != NULL \\endcode"]
    #[doc = "    \\code object->type == FLAC__METADATA_TYPE_SEEKTABLE \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if memory allocation fails, else \\c true."]
    pub fn FLAC__metadata_object_seektable_template_append_placeholders(
        object: *mut FLAC__StreamMetadata,
        num: ::std::os::raw::c_uint,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Append a specific seek point template to the end of a seek table."]
    #[doc = ""]
    #[doc = " \\note"]
    #[doc = " As with the other ..._seektable_template_... functions, you should"]
    #[doc = " call FLAC__metadata_object_seektable_template_sort() when finished"]
    #[doc = " to make the seek table legal."]
    #[doc = ""]
    #[doc = " \\param object  A pointer to an existing SEEKTABLE object."]
    #[doc = " \\param sample_number  The sample number of the seek point template."]
    #[doc = " \\assert"]
    #[doc = "    \\code object != NULL \\endcode"]
    #[doc = "    \\code object->type == FLAC__METADATA_TYPE_SEEKTABLE \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if memory allocation fails, else \\c true."]
    pub fn FLAC__metadata_object_seektable_template_append_point(
        object: *mut FLAC__StreamMetadata,
        sample_number: FLAC__uint64,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Append specific seek point templates to the end of a seek table."]
    #[doc = ""]
    #[doc = " \\note"]
    #[doc = " As with the other ..._seektable_template_... functions, you should"]
    #[doc = " call FLAC__metadata_object_seektable_template_sort() when finished"]
    #[doc = " to make the seek table legal."]
    #[doc = ""]
    #[doc = " \\param object  A pointer to an existing SEEKTABLE object."]
    #[doc = " \\param sample_numbers  An array of sample numbers for the seek points."]
    #[doc = " \\param num     The number of seek point templates to append."]
    #[doc = " \\assert"]
    #[doc = "    \\code object != NULL \\endcode"]
    #[doc = "    \\code object->type == FLAC__METADATA_TYPE_SEEKTABLE \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if memory allocation fails, else \\c true."]
    pub fn FLAC__metadata_object_seektable_template_append_points(
        object: *mut FLAC__StreamMetadata,
        sample_numbers: *mut FLAC__uint64,
        num: ::std::os::raw::c_uint,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Append a set of evenly-spaced seek point templates to the end of a"]
    #[doc = "  seek table."]
    #[doc = ""]
    #[doc = " \\note"]
    #[doc = " As with the other ..._seektable_template_... functions, you should"]
    #[doc = " call FLAC__metadata_object_seektable_template_sort() when finished"]
    #[doc = " to make the seek table legal."]
    #[doc = ""]
    #[doc = " \\param object  A pointer to an existing SEEKTABLE object."]
    #[doc = " \\param num     The number of placeholder points to append."]
    #[doc = " \\param total_samples  The total number of samples to be encoded;"]
    #[doc = "                       the seekpoints will be spaced approximately"]
    #[doc = "                       \\a total_samples / \\a num samples apart."]
    #[doc = " \\assert"]
    #[doc = "    \\code object != NULL \\endcode"]
    #[doc = "    \\code object->type == FLAC__METADATA_TYPE_SEEKTABLE \\endcode"]
    #[doc = "    \\code total_samples > 0 \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if memory allocation fails, else \\c true."]
    pub fn FLAC__metadata_object_seektable_template_append_spaced_points(
        object: *mut FLAC__StreamMetadata,
        num: ::std::os::raw::c_uint,
        total_samples: FLAC__uint64,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Append a set of evenly-spaced seek point templates to the end of a"]
    #[doc = "  seek table."]
    #[doc = ""]
    #[doc = " \\note"]
    #[doc = " As with the other ..._seektable_template_... functions, you should"]
    #[doc = " call FLAC__metadata_object_seektable_template_sort() when finished"]
    #[doc = " to make the seek table legal."]
    #[doc = ""]
    #[doc = " \\param object  A pointer to an existing SEEKTABLE object."]
    #[doc = " \\param samples The number of samples apart to space the placeholder"]
    #[doc = "                points.  The first point will be at sample \\c 0, the"]
    #[doc = "                second at sample \\a samples, then 2*\\a samples, and"]
    #[doc = "                so on.  As long as \\a samples and \\a total_samples"]
    #[doc = "                are greater than \\c 0, there will always be at least"]
    #[doc = "                one seekpoint at sample \\c 0."]
    #[doc = " \\param total_samples  The total number of samples to be encoded;"]
    #[doc = "                       the seekpoints will be spaced"]
    #[doc = "                       \\a samples samples apart."]
    #[doc = " \\assert"]
    #[doc = "    \\code object != NULL \\endcode"]
    #[doc = "    \\code object->type == FLAC__METADATA_TYPE_SEEKTABLE \\endcode"]
    #[doc = "    \\code samples > 0 \\endcode"]
    #[doc = "    \\code total_samples > 0 \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if memory allocation fails, else \\c true."]
    pub fn FLAC__metadata_object_seektable_template_append_spaced_points_by_samples(
        object: *mut FLAC__StreamMetadata,
        samples: ::std::os::raw::c_uint,
        total_samples: FLAC__uint64,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Sort a seek table\'s seek points according to the format specification,"]
    #[doc = "  removing duplicates."]
    #[doc = ""]
    #[doc = " \\param object   A pointer to a seek table to be sorted."]
    #[doc = " \\param compact  If \\c false, behaves like FLAC__format_seektable_sort()."]
    #[doc = "                 If \\c true, duplicates are deleted and the seek table is"]
    #[doc = "                 shrunk appropriately; the number of placeholder points"]
    #[doc = "                 present in the seek table will be the same after the call"]
    #[doc = "                 as before."]
    #[doc = " \\assert"]
    #[doc = "    \\code object != NULL \\endcode"]
    #[doc = "    \\code object->type == FLAC__METADATA_TYPE_SEEKTABLE \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if realloc() fails, else \\c true."]
    pub fn FLAC__metadata_object_seektable_template_sort(
        object: *mut FLAC__StreamMetadata,
        compact: FLAC__bool,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Sets the vendor string in a VORBIS_COMMENT block."]
    #[doc = ""]
    #[doc = "  For convenience, a trailing NUL is added to the entry if it doesn\'t have"]
    #[doc = "  one already."]
    #[doc = ""]
    #[doc = "  If \\a copy is \\c true, a copy of the entry is stored; otherwise, the object"]
    #[doc = "  takes ownership of the \\c entry.entry pointer."]
    #[doc = ""]
    #[doc = "  \\note If this function returns \\c false, the caller still owns the"]
    #[doc = "  pointer."]
    #[doc = ""]
    #[doc = " \\param object  A pointer to an existing VORBIS_COMMENT object."]
    #[doc = " \\param entry   The entry to set the vendor string to."]
    #[doc = " \\param copy    See above."]
    #[doc = " \\assert"]
    #[doc = "    \\code object != NULL \\endcode"]
    #[doc = "    \\code object->type == FLAC__METADATA_TYPE_VORBIS_COMMENT \\endcode"]
    #[doc = "    \\code (entry.entry != NULL && entry.length > 0) ||"]
    #[doc = " (entry.entry == NULL && entry.length == 0) \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if memory allocation fails or \\a entry does not comply with the"]
    #[doc = "    Vorbis comment specification, else \\c true."]
    pub fn FLAC__metadata_object_vorbiscomment_set_vendor_string(
        object: *mut FLAC__StreamMetadata,
        entry: FLAC__StreamMetadata_VorbisComment_Entry,
        copy: FLAC__bool,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Resize the comment array."]
    #[doc = ""]
    #[doc = "  If the size shrinks, elements will truncated; if it grows, new empty"]
    #[doc = "  fields will be added to the end."]
    #[doc = ""]
    #[doc = " \\param object            A pointer to an existing VORBIS_COMMENT object."]
    #[doc = " \\param new_num_comments  The desired length of the array; may be \\c 0."]
    #[doc = " \\assert"]
    #[doc = "    \\code object != NULL \\endcode"]
    #[doc = "    \\code object->type == FLAC__METADATA_TYPE_VORBIS_COMMENT \\endcode"]
    #[doc = "    \\code (object->data.vorbis_comment.comments == NULL && object->data.vorbis_comment.num_comments == 0) ||"]
    #[doc = " (object->data.vorbis_comment.comments != NULL && object->data.vorbis_comment.num_comments > 0) \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if memory allocation fails, else \\c true."]
    pub fn FLAC__metadata_object_vorbiscomment_resize_comments(
        object: *mut FLAC__StreamMetadata,
        new_num_comments: ::std::os::raw::c_uint,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Sets a comment in a VORBIS_COMMENT block."]
    #[doc = ""]
    #[doc = "  For convenience, a trailing NUL is added to the entry if it doesn\'t have"]
    #[doc = "  one already."]
    #[doc = ""]
    #[doc = "  If \\a copy is \\c true, a copy of the entry is stored; otherwise, the object"]
    #[doc = "  takes ownership of the \\c entry.entry pointer."]
    #[doc = ""]
    #[doc = "  \\note If this function returns \\c false, the caller still owns the"]
    #[doc = "  pointer."]
    #[doc = ""]
    #[doc = " \\param object       A pointer to an existing VORBIS_COMMENT object."]
    #[doc = " \\param comment_num  Index into comment array to set."]
    #[doc = " \\param entry        The entry to set the comment to."]
    #[doc = " \\param copy         See above."]
    #[doc = " \\assert"]
    #[doc = "    \\code object != NULL \\endcode"]
    #[doc = "    \\code object->type == FLAC__METADATA_TYPE_VORBIS_COMMENT \\endcode"]
    #[doc = "    \\code comment_num < object->data.vorbis_comment.num_comments \\endcode"]
    #[doc = "    \\code (entry.entry != NULL && entry.length > 0) ||"]
    #[doc = " (entry.entry == NULL && entry.length == 0) \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if memory allocation fails or \\a entry does not comply with the"]
    #[doc = "    Vorbis comment specification, else \\c true."]
    pub fn FLAC__metadata_object_vorbiscomment_set_comment(
        object: *mut FLAC__StreamMetadata,
        comment_num: ::std::os::raw::c_uint,
        entry: FLAC__StreamMetadata_VorbisComment_Entry,
        copy: FLAC__bool,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Insert a comment in a VORBIS_COMMENT block at the given index."]
    #[doc = ""]
    #[doc = "  For convenience, a trailing NUL is added to the entry if it doesn\'t have"]
    #[doc = "  one already."]
    #[doc = ""]
    #[doc = "  If \\a copy is \\c true, a copy of the entry is stored; otherwise, the object"]
    #[doc = "  takes ownership of the \\c entry.entry pointer."]
    #[doc = ""]
    #[doc = "  \\note If this function returns \\c false, the caller still owns the"]
    #[doc = "  pointer."]
    #[doc = ""]
    #[doc = " \\param object       A pointer to an existing VORBIS_COMMENT object."]
    #[doc = " \\param comment_num  The index at which to insert the comment.  The comments"]
    #[doc = "                     at and after \\a comment_num move right one position."]
    #[doc = "                     To append a comment to the end, set \\a comment_num to"]
    #[doc = "                     \\c object->data.vorbis_comment.num_comments ."]
    #[doc = " \\param entry        The comment to insert."]
    #[doc = " \\param copy         See above."]
    #[doc = " \\assert"]
    #[doc = "    \\code object != NULL \\endcode"]
    #[doc = "    \\code object->type == FLAC__METADATA_TYPE_VORBIS_COMMENT \\endcode"]
    #[doc = "    \\code object->data.vorbis_comment.num_comments >= comment_num \\endcode"]
    #[doc = "    \\code (entry.entry != NULL && entry.length > 0) ||"]
    #[doc = " (entry.entry == NULL && entry.length == 0 && copy == false) \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if memory allocation fails or \\a entry does not comply with the"]
    #[doc = "    Vorbis comment specification, else \\c true."]
    pub fn FLAC__metadata_object_vorbiscomment_insert_comment(
        object: *mut FLAC__StreamMetadata,
        comment_num: ::std::os::raw::c_uint,
        entry: FLAC__StreamMetadata_VorbisComment_Entry,
        copy: FLAC__bool,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Appends a comment to a VORBIS_COMMENT block."]
    #[doc = ""]
    #[doc = "  For convenience, a trailing NUL is added to the entry if it doesn\'t have"]
    #[doc = "  one already."]
    #[doc = ""]
    #[doc = "  If \\a copy is \\c true, a copy of the entry is stored; otherwise, the object"]
    #[doc = "  takes ownership of the \\c entry.entry pointer."]
    #[doc = ""]
    #[doc = "  \\note If this function returns \\c false, the caller still owns the"]
    #[doc = "  pointer."]
    #[doc = ""]
    #[doc = " \\param object       A pointer to an existing VORBIS_COMMENT object."]
    #[doc = " \\param entry        The comment to insert."]
    #[doc = " \\param copy         See above."]
    #[doc = " \\assert"]
    #[doc = "    \\code object != NULL \\endcode"]
    #[doc = "    \\code object->type == FLAC__METADATA_TYPE_VORBIS_COMMENT \\endcode"]
    #[doc = "    \\code (entry.entry != NULL && entry.length > 0) ||"]
    #[doc = " (entry.entry == NULL && entry.length == 0 && copy == false) \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if memory allocation fails or \\a entry does not comply with the"]
    #[doc = "    Vorbis comment specification, else \\c true."]
    pub fn FLAC__metadata_object_vorbiscomment_append_comment(
        object: *mut FLAC__StreamMetadata,
        entry: FLAC__StreamMetadata_VorbisComment_Entry,
        copy: FLAC__bool,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Replaces comments in a VORBIS_COMMENT block with a new one."]
    #[doc = ""]
    #[doc = "  For convenience, a trailing NUL is added to the entry if it doesn\'t have"]
    #[doc = "  one already."]
    #[doc = ""]
    #[doc = "  Depending on the value of \\a all, either all or just the first comment"]
    #[doc = "  whose field name(s) match the given entry\'s name will be replaced by the"]
    #[doc = "  given entry.  If no comments match, \\a entry will simply be appended."]
    #[doc = ""]
    #[doc = "  If \\a copy is \\c true, a copy of the entry is stored; otherwise, the object"]
    #[doc = "  takes ownership of the \\c entry.entry pointer."]
    #[doc = ""]
    #[doc = "  \\note If this function returns \\c false, the caller still owns the"]
    #[doc = "  pointer."]
    #[doc = ""]
    #[doc = " \\param object       A pointer to an existing VORBIS_COMMENT object."]
    #[doc = " \\param entry        The comment to insert."]
    #[doc = " \\param all          If \\c true, all comments whose field name matches"]
    #[doc = "                     \\a entry\'s field name will be removed, and \\a entry will"]
    #[doc = "                     be inserted at the position of the first matching"]
    #[doc = "                     comment.  If \\c false, only the first comment whose"]
    #[doc = "                     field name matches \\a entry\'s field name will be"]
    #[doc = "                     replaced with \\a entry."]
    #[doc = " \\param copy         See above."]
    #[doc = " \\assert"]
    #[doc = "    \\code object != NULL \\endcode"]
    #[doc = "    \\code object->type == FLAC__METADATA_TYPE_VORBIS_COMMENT \\endcode"]
    #[doc = "    \\code (entry.entry != NULL && entry.length > 0) ||"]
    #[doc = " (entry.entry == NULL && entry.length == 0 && copy == false) \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if memory allocation fails or \\a entry does not comply with the"]
    #[doc = "    Vorbis comment specification, else \\c true."]
    pub fn FLAC__metadata_object_vorbiscomment_replace_comment(
        object: *mut FLAC__StreamMetadata,
        entry: FLAC__StreamMetadata_VorbisComment_Entry,
        all: FLAC__bool,
        copy: FLAC__bool,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Delete a comment in a VORBIS_COMMENT block at the given index."]
    #[doc = ""]
    #[doc = " \\param object       A pointer to an existing VORBIS_COMMENT object."]
    #[doc = " \\param comment_num  The index of the comment to delete."]
    #[doc = " \\assert"]
    #[doc = "    \\code object != NULL \\endcode"]
    #[doc = "    \\code object->type == FLAC__METADATA_TYPE_VORBIS_COMMENT \\endcode"]
    #[doc = "    \\code object->data.vorbis_comment.num_comments > comment_num \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if realloc() fails, else \\c true."]
    pub fn FLAC__metadata_object_vorbiscomment_delete_comment(
        object: *mut FLAC__StreamMetadata,
        comment_num: ::std::os::raw::c_uint,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Creates a Vorbis comment entry from NUL-terminated name and value strings."]
    #[doc = ""]
    #[doc = "  On return, the filled-in \\a entry->entry pointer will point to malloc()ed"]
    #[doc = "  memory and shall be owned by the caller.  For convenience the entry will"]
    #[doc = "  have a terminating NUL."]
    #[doc = ""]
    #[doc = " \\param entry              A pointer to a Vorbis comment entry.  The entry\'s"]
    #[doc = "                           \\c entry pointer should not point to allocated"]
    #[doc = "                           memory as it will be overwritten."]
    #[doc = " \\param field_name         The field name in ASCII, \\c NUL terminated."]
    #[doc = " \\param field_value        The field value in UTF-8, \\c NUL terminated."]
    #[doc = " \\assert"]
    #[doc = "    \\code entry != NULL \\endcode"]
    #[doc = "    \\code field_name != NULL \\endcode"]
    #[doc = "    \\code field_value != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if malloc() fails, or if \\a field_name or \\a field_value does"]
    #[doc = "    not comply with the Vorbis comment specification, else \\c true."]
    pub fn FLAC__metadata_object_vorbiscomment_entry_from_name_value_pair(
        entry: *mut FLAC__StreamMetadata_VorbisComment_Entry,
        field_name: *const ::std::os::raw::c_char,
        field_value: *const ::std::os::raw::c_char,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Splits a Vorbis comment entry into NUL-terminated name and value strings."]
    #[doc = ""]
    #[doc = "  The returned pointers to name and value will be allocated by malloc()"]
    #[doc = "  and shall be owned by the caller."]
    #[doc = ""]
    #[doc = " \\param entry              An existing Vorbis comment entry."]
    #[doc = " \\param field_name         The address of where the returned pointer to the"]
    #[doc = "                           field name will be stored."]
    #[doc = " \\param field_value        The address of where the returned pointer to the"]
    #[doc = "                           field value will be stored."]
    #[doc = " \\assert"]
    #[doc = "    \\code (entry.entry != NULL && entry.length > 0) \\endcode"]
    #[doc = "    \\code memchr(entry.entry, \'=\', entry.length) != NULL \\endcode"]
    #[doc = "    \\code field_name != NULL \\endcode"]
    #[doc = "    \\code field_value != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if memory allocation fails or \\a entry does not comply with the"]
    #[doc = "    Vorbis comment specification, else \\c true."]
    pub fn FLAC__metadata_object_vorbiscomment_entry_to_name_value_pair(
        entry: FLAC__StreamMetadata_VorbisComment_Entry,
        field_name: *mut *mut ::std::os::raw::c_char,
        field_value: *mut *mut ::std::os::raw::c_char,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Check if the given Vorbis comment entry\'s field name matches the given"]
    #[doc = "  field name."]
    #[doc = ""]
    #[doc = " \\param entry              An existing Vorbis comment entry."]
    #[doc = " \\param field_name         The field name to check."]
    #[doc = " \\param field_name_length  The length of \\a field_name, not including the"]
    #[doc = "                           terminating \\c NUL."]
    #[doc = " \\assert"]
    #[doc = "    \\code (entry.entry != NULL && entry.length > 0) \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c true if the field names match, else \\c false"]
    pub fn FLAC__metadata_object_vorbiscomment_entry_matches(
        entry: FLAC__StreamMetadata_VorbisComment_Entry,
        field_name: *const ::std::os::raw::c_char,
        field_name_length: ::std::os::raw::c_uint,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Find a Vorbis comment with the given field name."]
    #[doc = ""]
    #[doc = "  The search begins at entry number \\a offset; use an offset of 0 to"]
    #[doc = "  search from the beginning of the comment array."]
    #[doc = ""]
    #[doc = " \\param object      A pointer to an existing VORBIS_COMMENT object."]
    #[doc = " \\param offset      The offset into the comment array from where to start"]
    #[doc = "                    the search."]
    #[doc = " \\param field_name  The field name of the comment to find."]
    #[doc = " \\assert"]
    #[doc = "    \\code object != NULL \\endcode"]
    #[doc = "    \\code object->type == FLAC__METADATA_TYPE_VORBIS_COMMENT \\endcode"]
    #[doc = "    \\code field_name != NULL \\endcode"]
    #[doc = " \\retval int"]
    #[doc = "    The offset in the comment array of the first comment whose field"]
    #[doc = "    name matches \\a field_name, or \\c -1 if no match was found."]
    pub fn FLAC__metadata_object_vorbiscomment_find_entry_from(
        object: *const FLAC__StreamMetadata,
        offset: ::std::os::raw::c_uint,
        field_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove first Vorbis comment matching the given field name."]
    #[doc = ""]
    #[doc = " \\param object      A pointer to an existing VORBIS_COMMENT object."]
    #[doc = " \\param field_name  The field name of comment to delete."]
    #[doc = " \\assert"]
    #[doc = "    \\code object != NULL \\endcode"]
    #[doc = "    \\code object->type == FLAC__METADATA_TYPE_VORBIS_COMMENT \\endcode"]
    #[doc = " \\retval int"]
    #[doc = "    \\c -1 for memory allocation error, \\c 0 for no matching entries,"]
    #[doc = "    \\c 1 for one matching entry deleted."]
    pub fn FLAC__metadata_object_vorbiscomment_remove_entry_matching(
        object: *mut FLAC__StreamMetadata,
        field_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove all Vorbis comments matching the given field name."]
    #[doc = ""]
    #[doc = " \\param object      A pointer to an existing VORBIS_COMMENT object."]
    #[doc = " \\param field_name  The field name of comments to delete."]
    #[doc = " \\assert"]
    #[doc = "    \\code object != NULL \\endcode"]
    #[doc = "    \\code object->type == FLAC__METADATA_TYPE_VORBIS_COMMENT \\endcode"]
    #[doc = " \\retval int"]
    #[doc = "    \\c -1 for memory allocation error, \\c 0 for no matching entries,"]
    #[doc = "    else the number of matching entries deleted."]
    pub fn FLAC__metadata_object_vorbiscomment_remove_entries_matching(
        object: *mut FLAC__StreamMetadata,
        field_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create a new CUESHEET track instance."]
    #[doc = ""]
    #[doc = "  The object will be \"empty\"; i.e. values and data pointers will be \\c 0."]
    #[doc = ""]
    #[doc = " \\retval FLAC__StreamMetadata_CueSheet_Track*"]
    #[doc = "    \\c NULL if there was an error allocating memory, else the new instance."]
    pub fn FLAC__metadata_object_cuesheet_track_new() -> *mut FLAC__StreamMetadata_CueSheet_Track;
}
extern "C" {
    #[doc = " Create a copy of an existing CUESHEET track object."]
    #[doc = ""]
    #[doc = "  The copy is a \"deep\" copy, i.e. dynamically allocated data within the"]
    #[doc = "  object is also copied.  The caller takes ownership of the new object and"]
    #[doc = "  is responsible for freeing it with"]
    #[doc = "  FLAC__metadata_object_cuesheet_track_delete()."]
    #[doc = ""]
    #[doc = " \\param object  Pointer to object to copy."]
    #[doc = " \\assert"]
    #[doc = "    \\code object != NULL \\endcode"]
    #[doc = " \\retval FLAC__StreamMetadata_CueSheet_Track*"]
    #[doc = "    \\c NULL if there was an error allocating memory, else the new instance."]
    pub fn FLAC__metadata_object_cuesheet_track_clone(
        object: *const FLAC__StreamMetadata_CueSheet_Track,
    ) -> *mut FLAC__StreamMetadata_CueSheet_Track;
}
extern "C" {
    #[doc = " Delete a CUESHEET track object"]
    #[doc = ""]
    #[doc = " \\param object       A pointer to an existing CUESHEET track object."]
    #[doc = " \\assert"]
    #[doc = "    \\code object != NULL \\endcode"]
    pub fn FLAC__metadata_object_cuesheet_track_delete(
        object: *mut FLAC__StreamMetadata_CueSheet_Track,
    );
}
extern "C" {
    #[doc = " Resize a track\'s index point array."]
    #[doc = ""]
    #[doc = "  If the size shrinks, elements will truncated; if it grows, new blank"]
    #[doc = "  indices will be added to the end."]
    #[doc = ""]
    #[doc = " \\param object           A pointer to an existing CUESHEET object."]
    #[doc = " \\param track_num        The index of the track to modify.  NOTE: this is not"]
    #[doc = "                         necessarily the same as the track\'s \\a number field."]
    #[doc = " \\param new_num_indices  The desired length of the array; may be \\c 0."]
    #[doc = " \\assert"]
    #[doc = "    \\code object != NULL \\endcode"]
    #[doc = "    \\code object->type == FLAC__METADATA_TYPE_CUESHEET \\endcode"]
    #[doc = "    \\code object->data.cue_sheet.num_tracks > track_num \\endcode"]
    #[doc = "    \\code (object->data.cue_sheet.tracks[track_num].indices == NULL && object->data.cue_sheet.tracks[track_num].num_indices == 0) ||"]
    #[doc = " (object->data.cue_sheet.tracks[track_num].indices != NULL && object->data.cue_sheet.tracks[track_num].num_indices > 0) \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if memory allocation error, else \\c true."]
    pub fn FLAC__metadata_object_cuesheet_track_resize_indices(
        object: *mut FLAC__StreamMetadata,
        track_num: ::std::os::raw::c_uint,
        new_num_indices: ::std::os::raw::c_uint,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Insert an index point in a CUESHEET track at the given index."]
    #[doc = ""]
    #[doc = " \\param object       A pointer to an existing CUESHEET object."]
    #[doc = " \\param track_num    The index of the track to modify.  NOTE: this is not"]
    #[doc = "                     necessarily the same as the track\'s \\a number field."]
    #[doc = " \\param index_num    The index into the track\'s index array at which to"]
    #[doc = "                     insert the index point.  NOTE: this is not necessarily"]
    #[doc = "                     the same as the index point\'s \\a number field.  The"]
    #[doc = "                     indices at and after \\a index_num move right one"]
    #[doc = "                     position.  To append an index point to the end, set"]
    #[doc = "                     \\a index_num to"]
    #[doc = "                     \\c object->data.cue_sheet.tracks[track_num].num_indices ."]
    #[doc = " \\param index        The index point to insert."]
    #[doc = " \\assert"]
    #[doc = "    \\code object != NULL \\endcode"]
    #[doc = "    \\code object->type == FLAC__METADATA_TYPE_CUESHEET \\endcode"]
    #[doc = "    \\code object->data.cue_sheet.num_tracks > track_num \\endcode"]
    #[doc = "    \\code object->data.cue_sheet.tracks[track_num].num_indices >= index_num \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if realloc() fails, else \\c true."]
    pub fn FLAC__metadata_object_cuesheet_track_insert_index(
        object: *mut FLAC__StreamMetadata,
        track_num: ::std::os::raw::c_uint,
        index_num: ::std::os::raw::c_uint,
        index: FLAC__StreamMetadata_CueSheet_Index,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Insert a blank index point in a CUESHEET track at the given index."]
    #[doc = ""]
    #[doc = "  A blank index point is one in which all field values are zero."]
    #[doc = ""]
    #[doc = " \\param object       A pointer to an existing CUESHEET object."]
    #[doc = " \\param track_num    The index of the track to modify.  NOTE: this is not"]
    #[doc = "                     necessarily the same as the track\'s \\a number field."]
    #[doc = " \\param index_num    The index into the track\'s index array at which to"]
    #[doc = "                     insert the index point.  NOTE: this is not necessarily"]
    #[doc = "                     the same as the index point\'s \\a number field.  The"]
    #[doc = "                     indices at and after \\a index_num move right one"]
    #[doc = "                     position.  To append an index point to the end, set"]
    #[doc = "                     \\a index_num to"]
    #[doc = "                     \\c object->data.cue_sheet.tracks[track_num].num_indices ."]
    #[doc = " \\assert"]
    #[doc = "    \\code object != NULL \\endcode"]
    #[doc = "    \\code object->type == FLAC__METADATA_TYPE_CUESHEET \\endcode"]
    #[doc = "    \\code object->data.cue_sheet.num_tracks > track_num \\endcode"]
    #[doc = "    \\code object->data.cue_sheet.tracks[track_num].num_indices >= index_num \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if realloc() fails, else \\c true."]
    pub fn FLAC__metadata_object_cuesheet_track_insert_blank_index(
        object: *mut FLAC__StreamMetadata,
        track_num: ::std::os::raw::c_uint,
        index_num: ::std::os::raw::c_uint,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Delete an index point in a CUESHEET track at the given index."]
    #[doc = ""]
    #[doc = " \\param object       A pointer to an existing CUESHEET object."]
    #[doc = " \\param track_num    The index into the track array of the track to"]
    #[doc = "                     modify.  NOTE: this is not necessarily the same"]
    #[doc = "                     as the track\'s \\a number field."]
    #[doc = " \\param index_num    The index into the track\'s index array of the index"]
    #[doc = "                     to delete.  NOTE: this is not necessarily the same"]
    #[doc = "                     as the index\'s \\a number field."]
    #[doc = " \\assert"]
    #[doc = "    \\code object != NULL \\endcode"]
    #[doc = "    \\code object->type == FLAC__METADATA_TYPE_CUESHEET \\endcode"]
    #[doc = "    \\code object->data.cue_sheet.num_tracks > track_num \\endcode"]
    #[doc = "    \\code object->data.cue_sheet.tracks[track_num].num_indices > index_num \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if realloc() fails, else \\c true."]
    pub fn FLAC__metadata_object_cuesheet_track_delete_index(
        object: *mut FLAC__StreamMetadata,
        track_num: ::std::os::raw::c_uint,
        index_num: ::std::os::raw::c_uint,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Resize the track array."]
    #[doc = ""]
    #[doc = "  If the size shrinks, elements will truncated; if it grows, new blank"]
    #[doc = "  tracks will be added to the end."]
    #[doc = ""]
    #[doc = " \\param object            A pointer to an existing CUESHEET object."]
    #[doc = " \\param new_num_tracks    The desired length of the array; may be \\c 0."]
    #[doc = " \\assert"]
    #[doc = "    \\code object != NULL \\endcode"]
    #[doc = "    \\code object->type == FLAC__METADATA_TYPE_CUESHEET \\endcode"]
    #[doc = "    \\code (object->data.cue_sheet.tracks == NULL && object->data.cue_sheet.num_tracks == 0) ||"]
    #[doc = " (object->data.cue_sheet.tracks != NULL && object->data.cue_sheet.num_tracks > 0) \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if memory allocation error, else \\c true."]
    pub fn FLAC__metadata_object_cuesheet_resize_tracks(
        object: *mut FLAC__StreamMetadata,
        new_num_tracks: ::std::os::raw::c_uint,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Sets a track in a CUESHEET block."]
    #[doc = ""]
    #[doc = "  If \\a copy is \\c true, a copy of the track is stored; otherwise, the object"]
    #[doc = "  takes ownership of the \\a track pointer."]
    #[doc = ""]
    #[doc = " \\param object       A pointer to an existing CUESHEET object."]
    #[doc = " \\param track_num    Index into track array to set.  NOTE: this is not"]
    #[doc = "                     necessarily the same as the track\'s \\a number field."]
    #[doc = " \\param track        The track to set the track to.  You may safely pass in"]
    #[doc = "                     a const pointer if \\a copy is \\c true."]
    #[doc = " \\param copy         See above."]
    #[doc = " \\assert"]
    #[doc = "    \\code object != NULL \\endcode"]
    #[doc = "    \\code object->type == FLAC__METADATA_TYPE_CUESHEET \\endcode"]
    #[doc = "    \\code track_num < object->data.cue_sheet.num_tracks \\endcode"]
    #[doc = "    \\code (track->indices != NULL && track->num_indices > 0) ||"]
    #[doc = " (track->indices == NULL && track->num_indices == 0) \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if \\a copy is \\c true and malloc() fails, else \\c true."]
    pub fn FLAC__metadata_object_cuesheet_set_track(
        object: *mut FLAC__StreamMetadata,
        track_num: ::std::os::raw::c_uint,
        track: *mut FLAC__StreamMetadata_CueSheet_Track,
        copy: FLAC__bool,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Insert a track in a CUESHEET block at the given index."]
    #[doc = ""]
    #[doc = "  If \\a copy is \\c true, a copy of the track is stored; otherwise, the object"]
    #[doc = "  takes ownership of the \\a track pointer."]
    #[doc = ""]
    #[doc = " \\param object       A pointer to an existing CUESHEET object."]
    #[doc = " \\param track_num    The index at which to insert the track.  NOTE: this"]
    #[doc = "                     is not necessarily the same as the track\'s \\a number"]
    #[doc = "                     field.  The tracks at and after \\a track_num move right"]
    #[doc = "                     one position.  To append a track to the end, set"]
    #[doc = "                     \\a track_num to \\c object->data.cue_sheet.num_tracks ."]
    #[doc = " \\param track        The track to insert.  You may safely pass in a const"]
    #[doc = "                     pointer if \\a copy is \\c true."]
    #[doc = " \\param copy         See above."]
    #[doc = " \\assert"]
    #[doc = "    \\code object != NULL \\endcode"]
    #[doc = "    \\code object->type == FLAC__METADATA_TYPE_CUESHEET \\endcode"]
    #[doc = "    \\code object->data.cue_sheet.num_tracks >= track_num \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if \\a copy is \\c true and malloc() fails, else \\c true."]
    pub fn FLAC__metadata_object_cuesheet_insert_track(
        object: *mut FLAC__StreamMetadata,
        track_num: ::std::os::raw::c_uint,
        track: *mut FLAC__StreamMetadata_CueSheet_Track,
        copy: FLAC__bool,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Insert a blank track in a CUESHEET block at the given index."]
    #[doc = ""]
    #[doc = "  A blank track is one in which all field values are zero."]
    #[doc = ""]
    #[doc = " \\param object       A pointer to an existing CUESHEET object."]
    #[doc = " \\param track_num    The index at which to insert the track.  NOTE: this"]
    #[doc = "                     is not necessarily the same as the track\'s \\a number"]
    #[doc = "                     field.  The tracks at and after \\a track_num move right"]
    #[doc = "                     one position.  To append a track to the end, set"]
    #[doc = "                     \\a track_num to \\c object->data.cue_sheet.num_tracks ."]
    #[doc = " \\assert"]
    #[doc = "    \\code object != NULL \\endcode"]
    #[doc = "    \\code object->type == FLAC__METADATA_TYPE_CUESHEET \\endcode"]
    #[doc = "    \\code object->data.cue_sheet.num_tracks >= track_num \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if \\a copy is \\c true and malloc() fails, else \\c true."]
    pub fn FLAC__metadata_object_cuesheet_insert_blank_track(
        object: *mut FLAC__StreamMetadata,
        track_num: ::std::os::raw::c_uint,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Delete a track in a CUESHEET block at the given index."]
    #[doc = ""]
    #[doc = " \\param object       A pointer to an existing CUESHEET object."]
    #[doc = " \\param track_num    The index into the track array of the track to"]
    #[doc = "                     delete.  NOTE: this is not necessarily the same"]
    #[doc = "                     as the track\'s \\a number field."]
    #[doc = " \\assert"]
    #[doc = "    \\code object != NULL \\endcode"]
    #[doc = "    \\code object->type == FLAC__METADATA_TYPE_CUESHEET \\endcode"]
    #[doc = "    \\code object->data.cue_sheet.num_tracks > track_num \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if realloc() fails, else \\c true."]
    pub fn FLAC__metadata_object_cuesheet_delete_track(
        object: *mut FLAC__StreamMetadata,
        track_num: ::std::os::raw::c_uint,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Check a cue sheet to see if it conforms to the FLAC specification."]
    #[doc = "  See the format specification for limits on the contents of the"]
    #[doc = "  cue sheet."]
    #[doc = ""]
    #[doc = " \\param object     A pointer to an existing CUESHEET object."]
    #[doc = " \\param check_cd_da_subset  If \\c true, check CUESHEET against more"]
    #[doc = "                   stringent requirements for a CD-DA (audio) disc."]
    #[doc = " \\param violation  Address of a pointer to a string.  If there is a"]
    #[doc = "                   violation, a pointer to a string explanation of the"]
    #[doc = "                   violation will be returned here. \\a violation may be"]
    #[doc = "                   \\c NULL if you don\'t need the returned string.  Do not"]
    #[doc = "                   free the returned string; it will always point to static"]
    #[doc = "                   data."]
    #[doc = " \\assert"]
    #[doc = "    \\code object != NULL \\endcode"]
    #[doc = "    \\code object->type == FLAC__METADATA_TYPE_CUESHEET \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if cue sheet is illegal, else \\c true."]
    pub fn FLAC__metadata_object_cuesheet_is_legal(
        object: *const FLAC__StreamMetadata,
        check_cd_da_subset: FLAC__bool,
        violation: *mut *const ::std::os::raw::c_char,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Calculate and return the CDDB/freedb ID for a cue sheet.  The function"]
    #[doc = "  assumes the cue sheet corresponds to a CD; the result is undefined"]
    #[doc = "  if the cuesheet\'s is_cd bit is not set."]
    #[doc = ""]
    #[doc = " \\param object     A pointer to an existing CUESHEET object."]
    #[doc = " \\assert"]
    #[doc = "    \\code object != NULL \\endcode"]
    #[doc = "    \\code object->type == FLAC__METADATA_TYPE_CUESHEET \\endcode"]
    #[doc = " \\retval FLAC__uint32"]
    #[doc = "    The unsigned integer representation of the CDDB/freedb ID"]
    pub fn FLAC__metadata_object_cuesheet_calculate_cddb_id(
        object: *const FLAC__StreamMetadata,
    ) -> FLAC__uint32;
}
extern "C" {
    #[doc = " Sets the MIME type of a PICTURE block."]
    #[doc = ""]
    #[doc = "  If \\a copy is \\c true, a copy of the string is stored; otherwise, the object"]
    #[doc = "  takes ownership of the pointer.  The existing string will be freed if this"]
    #[doc = "  function is successful, otherwise the original string will remain if \\a copy"]
    #[doc = "  is \\c true and malloc() fails."]
    #[doc = ""]
    #[doc = " \\note It is safe to pass a const pointer to \\a mime_type if \\a copy is \\c true."]
    #[doc = ""]
    #[doc = " \\param object      A pointer to an existing PICTURE object."]
    #[doc = " \\param mime_type   A pointer to the MIME type string.  The string must be"]
    #[doc = "                    ASCII characters 0x20-0x7e, NUL-terminated.  No validation"]
    #[doc = "                    is done."]
    #[doc = " \\param copy        See above."]
    #[doc = " \\assert"]
    #[doc = "    \\code object != NULL \\endcode"]
    #[doc = "    \\code object->type == FLAC__METADATA_TYPE_PICTURE \\endcode"]
    #[doc = "    \\code (mime_type != NULL) \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if \\a copy is \\c true and malloc() fails, else \\c true."]
    pub fn FLAC__metadata_object_picture_set_mime_type(
        object: *mut FLAC__StreamMetadata,
        mime_type: *mut ::std::os::raw::c_char,
        copy: FLAC__bool,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Sets the description of a PICTURE block."]
    #[doc = ""]
    #[doc = "  If \\a copy is \\c true, a copy of the string is stored; otherwise, the object"]
    #[doc = "  takes ownership of the pointer.  The existing string will be freed if this"]
    #[doc = "  function is successful, otherwise the original string will remain if \\a copy"]
    #[doc = "  is \\c true and malloc() fails."]
    #[doc = ""]
    #[doc = " \\note It is safe to pass a const pointer to \\a description if \\a copy is \\c true."]
    #[doc = ""]
    #[doc = " \\param object      A pointer to an existing PICTURE object."]
    #[doc = " \\param description A pointer to the description string.  The string must be"]
    #[doc = "                    valid UTF-8, NUL-terminated.  No validation is done."]
    #[doc = " \\param copy        See above."]
    #[doc = " \\assert"]
    #[doc = "    \\code object != NULL \\endcode"]
    #[doc = "    \\code object->type == FLAC__METADATA_TYPE_PICTURE \\endcode"]
    #[doc = "    \\code (description != NULL) \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if \\a copy is \\c true and malloc() fails, else \\c true."]
    pub fn FLAC__metadata_object_picture_set_description(
        object: *mut FLAC__StreamMetadata,
        description: *mut FLAC__byte,
        copy: FLAC__bool,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Sets the picture data of a PICTURE block."]
    #[doc = ""]
    #[doc = "  If \\a copy is \\c true, a copy of the data is stored; otherwise, the object"]
    #[doc = "  takes ownership of the pointer.  Also sets the \\a data_length field of the"]
    #[doc = "  metadata object to what is passed in as the \\a length parameter.  The"]
    #[doc = "  existing data will be freed if this function is successful, otherwise the"]
    #[doc = "  original data and data_length will remain if \\a copy is \\c true and"]
    #[doc = "  malloc() fails."]
    #[doc = ""]
    #[doc = " \\note It is safe to pass a const pointer to \\a data if \\a copy is \\c true."]
    #[doc = ""]
    #[doc = " \\param object  A pointer to an existing PICTURE object."]
    #[doc = " \\param data    A pointer to the data to set."]
    #[doc = " \\param length  The length of \\a data in bytes."]
    #[doc = " \\param copy    See above."]
    #[doc = " \\assert"]
    #[doc = "    \\code object != NULL \\endcode"]
    #[doc = "    \\code object->type == FLAC__METADATA_TYPE_PICTURE \\endcode"]
    #[doc = "    \\code (data != NULL && length > 0) ||"]
    #[doc = " (data == NULL && length == 0 && copy == false) \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if \\a copy is \\c true and malloc() fails, else \\c true."]
    pub fn FLAC__metadata_object_picture_set_data(
        object: *mut FLAC__StreamMetadata,
        data: *mut FLAC__byte,
        length: FLAC__uint32,
        copy: FLAC__bool,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Check a PICTURE block to see if it conforms to the FLAC specification."]
    #[doc = "  See the format specification for limits on the contents of the"]
    #[doc = "  PICTURE block."]
    #[doc = ""]
    #[doc = " \\param object     A pointer to existing PICTURE block to be checked."]
    #[doc = " \\param violation  Address of a pointer to a string.  If there is a"]
    #[doc = "                   violation, a pointer to a string explanation of the"]
    #[doc = "                   violation will be returned here. \\a violation may be"]
    #[doc = "                   \\c NULL if you don\'t need the returned string.  Do not"]
    #[doc = "                   free the returned string; it will always point to static"]
    #[doc = "                   data."]
    #[doc = " \\assert"]
    #[doc = "    \\code object != NULL \\endcode"]
    #[doc = "    \\code object->type == FLAC__METADATA_TYPE_PICTURE \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if PICTURE block is illegal, else \\c true."]
    pub fn FLAC__metadata_object_picture_is_legal(
        object: *const FLAC__StreamMetadata,
        violation: *mut *const ::std::os::raw::c_char,
    ) -> FLAC__bool;
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
pub type fpos_t = __fpos_t;
extern "C" {
    #[link_name = "\u{1}stdin"]
    pub static mut stdin: *mut FILE;
}
extern "C" {
    #[link_name = "\u{1}stdout"]
    pub static mut stdout: *mut FILE;
}
extern "C" {
    #[link_name = "\u{1}stderr"]
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: usize,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}sys_nerr"]
    pub static mut sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}sys_errlist"]
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub const FLAC__StreamDecoderState_FLAC__STREAM_DECODER_SEARCH_FOR_METADATA:
    FLAC__StreamDecoderState = 0;
pub const FLAC__StreamDecoderState_FLAC__STREAM_DECODER_READ_METADATA: FLAC__StreamDecoderState = 1;
pub const FLAC__StreamDecoderState_FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC:
    FLAC__StreamDecoderState = 2;
pub const FLAC__StreamDecoderState_FLAC__STREAM_DECODER_READ_FRAME: FLAC__StreamDecoderState = 3;
pub const FLAC__StreamDecoderState_FLAC__STREAM_DECODER_END_OF_STREAM: FLAC__StreamDecoderState = 4;
pub const FLAC__StreamDecoderState_FLAC__STREAM_DECODER_OGG_ERROR: FLAC__StreamDecoderState = 5;
pub const FLAC__StreamDecoderState_FLAC__STREAM_DECODER_SEEK_ERROR: FLAC__StreamDecoderState = 6;
pub const FLAC__StreamDecoderState_FLAC__STREAM_DECODER_ABORTED: FLAC__StreamDecoderState = 7;
pub const FLAC__StreamDecoderState_FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR:
    FLAC__StreamDecoderState = 8;
pub const FLAC__StreamDecoderState_FLAC__STREAM_DECODER_UNINITIALIZED: FLAC__StreamDecoderState = 9;
#[doc = " State values for a FLAC__StreamDecoder"]
#[doc = ""]
#[doc = " The decoder\'s state can be obtained by calling FLAC__stream_decoder_get_state()."]
pub type FLAC__StreamDecoderState = u32;
extern "C" {
    #[link_name = "\u{1}FLAC__StreamDecoderStateString"]
    pub static mut FLAC__StreamDecoderStateString: [*const ::std::os::raw::c_char; 0usize];
}
pub const FLAC__StreamDecoderInitStatus_FLAC__STREAM_DECODER_INIT_STATUS_OK:
    FLAC__StreamDecoderInitStatus = 0;
pub const FLAC__StreamDecoderInitStatus_FLAC__STREAM_DECODER_INIT_STATUS_UNSUPPORTED_CONTAINER:
    FLAC__StreamDecoderInitStatus = 1;
pub const FLAC__StreamDecoderInitStatus_FLAC__STREAM_DECODER_INIT_STATUS_INVALID_CALLBACKS:
    FLAC__StreamDecoderInitStatus = 2;
pub const FLAC__StreamDecoderInitStatus_FLAC__STREAM_DECODER_INIT_STATUS_MEMORY_ALLOCATION_ERROR:
    FLAC__StreamDecoderInitStatus = 3;
pub const FLAC__StreamDecoderInitStatus_FLAC__STREAM_DECODER_INIT_STATUS_ERROR_OPENING_FILE:
    FLAC__StreamDecoderInitStatus = 4;
pub const FLAC__StreamDecoderInitStatus_FLAC__STREAM_DECODER_INIT_STATUS_ALREADY_INITIALIZED:
    FLAC__StreamDecoderInitStatus = 5;
#[doc = " Possible return values for the FLAC__stream_decoder_init_*() functions."]
pub type FLAC__StreamDecoderInitStatus = u32;
extern "C" {
    #[link_name = "\u{1}FLAC__StreamDecoderInitStatusString"]
    pub static mut FLAC__StreamDecoderInitStatusString: [*const ::std::os::raw::c_char; 0usize];
}
pub const FLAC__StreamDecoderReadStatus_FLAC__STREAM_DECODER_READ_STATUS_CONTINUE:
    FLAC__StreamDecoderReadStatus = 0;
pub const FLAC__StreamDecoderReadStatus_FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM:
    FLAC__StreamDecoderReadStatus = 1;
pub const FLAC__StreamDecoderReadStatus_FLAC__STREAM_DECODER_READ_STATUS_ABORT:
    FLAC__StreamDecoderReadStatus = 2;
#[doc = " Return values for the FLAC__StreamDecoder read callback."]
pub type FLAC__StreamDecoderReadStatus = u32;
extern "C" {
    #[link_name = "\u{1}FLAC__StreamDecoderReadStatusString"]
    pub static mut FLAC__StreamDecoderReadStatusString: [*const ::std::os::raw::c_char; 0usize];
}
pub const FLAC__StreamDecoderSeekStatus_FLAC__STREAM_DECODER_SEEK_STATUS_OK:
    FLAC__StreamDecoderSeekStatus = 0;
pub const FLAC__StreamDecoderSeekStatus_FLAC__STREAM_DECODER_SEEK_STATUS_ERROR:
    FLAC__StreamDecoderSeekStatus = 1;
pub const FLAC__StreamDecoderSeekStatus_FLAC__STREAM_DECODER_SEEK_STATUS_UNSUPPORTED:
    FLAC__StreamDecoderSeekStatus = 2;
#[doc = " Return values for the FLAC__StreamDecoder seek callback."]
pub type FLAC__StreamDecoderSeekStatus = u32;
extern "C" {
    #[link_name = "\u{1}FLAC__StreamDecoderSeekStatusString"]
    pub static mut FLAC__StreamDecoderSeekStatusString: [*const ::std::os::raw::c_char; 0usize];
}
pub const FLAC__StreamDecoderTellStatus_FLAC__STREAM_DECODER_TELL_STATUS_OK:
    FLAC__StreamDecoderTellStatus = 0;
pub const FLAC__StreamDecoderTellStatus_FLAC__STREAM_DECODER_TELL_STATUS_ERROR:
    FLAC__StreamDecoderTellStatus = 1;
pub const FLAC__StreamDecoderTellStatus_FLAC__STREAM_DECODER_TELL_STATUS_UNSUPPORTED:
    FLAC__StreamDecoderTellStatus = 2;
#[doc = " Return values for the FLAC__StreamDecoder tell callback."]
pub type FLAC__StreamDecoderTellStatus = u32;
extern "C" {
    #[link_name = "\u{1}FLAC__StreamDecoderTellStatusString"]
    pub static mut FLAC__StreamDecoderTellStatusString: [*const ::std::os::raw::c_char; 0usize];
}
pub const FLAC__StreamDecoderLengthStatus_FLAC__STREAM_DECODER_LENGTH_STATUS_OK:
    FLAC__StreamDecoderLengthStatus = 0;
pub const FLAC__StreamDecoderLengthStatus_FLAC__STREAM_DECODER_LENGTH_STATUS_ERROR:
    FLAC__StreamDecoderLengthStatus = 1;
pub const FLAC__StreamDecoderLengthStatus_FLAC__STREAM_DECODER_LENGTH_STATUS_UNSUPPORTED:
    FLAC__StreamDecoderLengthStatus = 2;
#[doc = " Return values for the FLAC__StreamDecoder length callback."]
pub type FLAC__StreamDecoderLengthStatus = u32;
extern "C" {
    #[link_name = "\u{1}FLAC__StreamDecoderLengthStatusString"]
    pub static mut FLAC__StreamDecoderLengthStatusString: [*const ::std::os::raw::c_char; 0usize];
}
pub const FLAC__StreamDecoderWriteStatus_FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE:
    FLAC__StreamDecoderWriteStatus = 0;
pub const FLAC__StreamDecoderWriteStatus_FLAC__STREAM_DECODER_WRITE_STATUS_ABORT:
    FLAC__StreamDecoderWriteStatus = 1;
#[doc = " Return values for the FLAC__StreamDecoder write callback."]
pub type FLAC__StreamDecoderWriteStatus = u32;
extern "C" {
    #[link_name = "\u{1}FLAC__StreamDecoderWriteStatusString"]
    pub static mut FLAC__StreamDecoderWriteStatusString: [*const ::std::os::raw::c_char; 0usize];
}
pub const FLAC__StreamDecoderErrorStatus_FLAC__STREAM_DECODER_ERROR_STATUS_LOST_SYNC:
    FLAC__StreamDecoderErrorStatus = 0;
pub const FLAC__StreamDecoderErrorStatus_FLAC__STREAM_DECODER_ERROR_STATUS_BAD_HEADER:
    FLAC__StreamDecoderErrorStatus = 1;
pub const FLAC__StreamDecoderErrorStatus_FLAC__STREAM_DECODER_ERROR_STATUS_FRAME_CRC_MISMATCH:
    FLAC__StreamDecoderErrorStatus = 2;
pub const FLAC__StreamDecoderErrorStatus_FLAC__STREAM_DECODER_ERROR_STATUS_UNPARSEABLE_STREAM:
    FLAC__StreamDecoderErrorStatus = 3;
#[doc = " Possible values passed back to the FLAC__StreamDecoder error callback."]
#[doc = "  \\c FLAC__STREAM_DECODER_ERROR_STATUS_LOST_SYNC is the generic catch-"]
#[doc = "  all.  The rest could be caused by bad sync (false synchronization on"]
#[doc = "  data that is not the start of a frame) or corrupted data.  The error"]
#[doc = "  itself is the decoder\'s best guess at what happened assuming a correct"]
#[doc = "  sync.  For example \\c FLAC__STREAM_DECODER_ERROR_STATUS_BAD_HEADER"]
#[doc = "  could be caused by a correct sync on the start of a frame, but some"]
#[doc = "  data in the frame header was corrupted.  Or it could be the result of"]
#[doc = "  syncing on a point the stream that looked like the starting of a frame"]
#[doc = "  but was not.  \\c FLAC__STREAM_DECODER_ERROR_STATUS_UNPARSEABLE_STREAM"]
#[doc = "  could be because the decoder encountered a valid frame made by a future"]
#[doc = "  version of the encoder which it cannot parse, or because of a false"]
#[doc = "  sync making it appear as though an encountered frame was generated by"]
#[doc = "  a future encoder."]
pub type FLAC__StreamDecoderErrorStatus = u32;
extern "C" {
    #[link_name = "\u{1}FLAC__StreamDecoderErrorStatusString"]
    pub static mut FLAC__StreamDecoderErrorStatusString: [*const ::std::os::raw::c_char; 0usize];
}
#[doc = " class FLAC__StreamDecoder"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__StreamDecoderProtected {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__StreamDecoderPrivate {
    _unused: [u8; 0],
}
#[doc = " The opaque structure definition for the stream decoder type."]
#[doc = "  See the \\link flac_stream_decoder stream decoder module \\endlink"]
#[doc = "  for a detailed description."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__StreamDecoder {
    pub protected_: *mut FLAC__StreamDecoderProtected,
    pub private_: *mut FLAC__StreamDecoderPrivate,
}
#[doc = " Signature for the read callback."]
#[doc = ""]
#[doc = "  A function pointer matching this signature must be passed to"]
#[doc = "  FLAC__stream_decoder_init*_stream(). The supplied function will be"]
#[doc = "  called when the decoder needs more input data.  The address of the"]
#[doc = "  buffer to be filled is supplied, along with the number of bytes the"]
#[doc = "  buffer can hold.  The callback may choose to supply less data and"]
#[doc = "  modify the byte count but must be careful not to overflow the buffer."]
#[doc = "  The callback then returns a status code chosen from"]
#[doc = "  FLAC__StreamDecoderReadStatus."]
#[doc = ""]
#[doc = " Here is an example of a read callback for stdio streams:"]
#[doc = " \\code"]
#[doc = " FLAC__StreamDecoderReadStatus read_cb(const FLAC__StreamDecoder *decoder, FLAC__byte buffer[], size_t *bytes, void *client_data)"]
#[doc = " {"]
#[doc = "   FILE *file = ((MyClientData*)client_data)->file;"]
#[doc = "   if(*bytes > 0) {"]
#[doc = "     *bytes = fread(buffer, sizeof(FLAC__byte), *bytes, file);"]
#[doc = "     if(ferror(file))"]
#[doc = "       return FLAC__STREAM_DECODER_READ_STATUS_ABORT;"]
#[doc = "     else if(*bytes == 0)"]
#[doc = "       return FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM;"]
#[doc = "     else"]
#[doc = "       return FLAC__STREAM_DECODER_READ_STATUS_CONTINUE;"]
#[doc = "   }"]
#[doc = "   else"]
#[doc = "     return FLAC__STREAM_DECODER_READ_STATUS_ABORT;"]
#[doc = " }"]
#[doc = " \\endcode"]
#[doc = ""]
#[doc = " \\note In general, FLAC__StreamDecoder functions which change the"]
#[doc = " state should not be called on the \\a decoder while in the callback."]
#[doc = ""]
#[doc = " \\param  decoder  The decoder instance calling the callback."]
#[doc = " \\param  buffer   A pointer to a location for the callee to store"]
#[doc = "                  data to be decoded."]
#[doc = " \\param  bytes    A pointer to the size of the buffer.  On entry"]
#[doc = "                  to the callback, it contains the maximum number"]
#[doc = "                  of bytes that may be stored in \\a buffer.  The"]
#[doc = "                  callee must set it to the actual number of bytes"]
#[doc = "                  stored (0 in case of error or end-of-stream) before"]
#[doc = "                  returning."]
#[doc = " \\param  client_data  The callee\'s client data set through"]
#[doc = "                      FLAC__stream_decoder_init_*()."]
#[doc = " \\retval FLAC__StreamDecoderReadStatus"]
#[doc = "    The callee\'s return status.  Note that the callback should return"]
#[doc = "    \\c FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM if and only if"]
#[doc = "    zero bytes were read and there is no more data to be read."]
pub type FLAC__StreamDecoderReadCallback = ::std::option::Option<
    unsafe extern "C" fn(
        decoder: *const FLAC__StreamDecoder,
        buffer: *mut FLAC__byte,
        bytes: *mut usize,
        client_data: *mut ::std::os::raw::c_void,
    ) -> FLAC__StreamDecoderReadStatus,
>;
#[doc = " Signature for the seek callback."]
#[doc = ""]
#[doc = "  A function pointer matching this signature may be passed to"]
#[doc = "  FLAC__stream_decoder_init*_stream().  The supplied function will be"]
#[doc = "  called when the decoder needs to seek the input stream.  The decoder"]
#[doc = "  will pass the absolute byte offset to seek to, 0 meaning the"]
#[doc = "  beginning of the stream."]
#[doc = ""]
#[doc = " Here is an example of a seek callback for stdio streams:"]
#[doc = " \\code"]
#[doc = " FLAC__StreamDecoderSeekStatus seek_cb(const FLAC__StreamDecoder *decoder, FLAC__uint64 absolute_byte_offset, void *client_data)"]
#[doc = " {"]
#[doc = "   FILE *file = ((MyClientData*)client_data)->file;"]
#[doc = "   if(file == stdin)"]
#[doc = "     return FLAC__STREAM_DECODER_SEEK_STATUS_UNSUPPORTED;"]
#[doc = "   else if(fseeko(file, (off_t)absolute_byte_offset, SEEK_SET) < 0)"]
#[doc = "     return FLAC__STREAM_DECODER_SEEK_STATUS_ERROR;"]
#[doc = "   else"]
#[doc = "     return FLAC__STREAM_DECODER_SEEK_STATUS_OK;"]
#[doc = " }"]
#[doc = " \\endcode"]
#[doc = ""]
#[doc = " \\note In general, FLAC__StreamDecoder functions which change the"]
#[doc = " state should not be called on the \\a decoder while in the callback."]
#[doc = ""]
#[doc = " \\param  decoder  The decoder instance calling the callback."]
#[doc = " \\param  absolute_byte_offset  The offset from the beginning of the stream"]
#[doc = "                               to seek to."]
#[doc = " \\param  client_data  The callee\'s client data set through"]
#[doc = "                      FLAC__stream_decoder_init_*()."]
#[doc = " \\retval FLAC__StreamDecoderSeekStatus"]
#[doc = "    The callee\'s return status."]
pub type FLAC__StreamDecoderSeekCallback = ::std::option::Option<
    unsafe extern "C" fn(
        decoder: *const FLAC__StreamDecoder,
        absolute_byte_offset: FLAC__uint64,
        client_data: *mut ::std::os::raw::c_void,
    ) -> FLAC__StreamDecoderSeekStatus,
>;
#[doc = " Signature for the tell callback."]
#[doc = ""]
#[doc = "  A function pointer matching this signature may be passed to"]
#[doc = "  FLAC__stream_decoder_init*_stream().  The supplied function will be"]
#[doc = "  called when the decoder wants to know the current position of the"]
#[doc = "  stream.  The callback should return the byte offset from the"]
#[doc = "  beginning of the stream."]
#[doc = ""]
#[doc = " Here is an example of a tell callback for stdio streams:"]
#[doc = " \\code"]
#[doc = " FLAC__StreamDecoderTellStatus tell_cb(const FLAC__StreamDecoder *decoder, FLAC__uint64 *absolute_byte_offset, void *client_data)"]
#[doc = " {"]
#[doc = "   FILE *file = ((MyClientData*)client_data)->file;"]
#[doc = "   off_t pos;"]
#[doc = "   if(file == stdin)"]
#[doc = "     return FLAC__STREAM_DECODER_TELL_STATUS_UNSUPPORTED;"]
#[doc = "   else if((pos = ftello(file)) < 0)"]
#[doc = "     return FLAC__STREAM_DECODER_TELL_STATUS_ERROR;"]
#[doc = "   else {"]
#[doc = "     *absolute_byte_offset = (FLAC__uint64)pos;"]
#[doc = "     return FLAC__STREAM_DECODER_TELL_STATUS_OK;"]
#[doc = "   }"]
#[doc = " }"]
#[doc = " \\endcode"]
#[doc = ""]
#[doc = " \\note In general, FLAC__StreamDecoder functions which change the"]
#[doc = " state should not be called on the \\a decoder while in the callback."]
#[doc = ""]
#[doc = " \\param  decoder  The decoder instance calling the callback."]
#[doc = " \\param  absolute_byte_offset  A pointer to storage for the current offset"]
#[doc = "                               from the beginning of the stream."]
#[doc = " \\param  client_data  The callee\'s client data set through"]
#[doc = "                      FLAC__stream_decoder_init_*()."]
#[doc = " \\retval FLAC__StreamDecoderTellStatus"]
#[doc = "    The callee\'s return status."]
pub type FLAC__StreamDecoderTellCallback = ::std::option::Option<
    unsafe extern "C" fn(
        decoder: *const FLAC__StreamDecoder,
        absolute_byte_offset: *mut FLAC__uint64,
        client_data: *mut ::std::os::raw::c_void,
    ) -> FLAC__StreamDecoderTellStatus,
>;
#[doc = " Signature for the length callback."]
#[doc = ""]
#[doc = "  A function pointer matching this signature may be passed to"]
#[doc = "  FLAC__stream_decoder_init*_stream().  The supplied function will be"]
#[doc = "  called when the decoder wants to know the total length of the stream"]
#[doc = "  in bytes."]
#[doc = ""]
#[doc = " Here is an example of a length callback for stdio streams:"]
#[doc = " \\code"]
#[doc = " FLAC__StreamDecoderLengthStatus length_cb(const FLAC__StreamDecoder *decoder, FLAC__uint64 *stream_length, void *client_data)"]
#[doc = " {"]
#[doc = "   FILE *file = ((MyClientData*)client_data)->file;"]
#[doc = "   struct stat filestats;"]
#[doc = ""]
#[doc = "   if(file == stdin)"]
#[doc = "     return FLAC__STREAM_DECODER_LENGTH_STATUS_UNSUPPORTED;"]
#[doc = "   else if(fstat(fileno(file), &filestats) != 0)"]
#[doc = "     return FLAC__STREAM_DECODER_LENGTH_STATUS_ERROR;"]
#[doc = "   else {"]
#[doc = "     *stream_length = (FLAC__uint64)filestats.st_size;"]
#[doc = "     return FLAC__STREAM_DECODER_LENGTH_STATUS_OK;"]
#[doc = "   }"]
#[doc = " }"]
#[doc = " \\endcode"]
#[doc = ""]
#[doc = " \\note In general, FLAC__StreamDecoder functions which change the"]
#[doc = " state should not be called on the \\a decoder while in the callback."]
#[doc = ""]
#[doc = " \\param  decoder  The decoder instance calling the callback."]
#[doc = " \\param  stream_length  A pointer to storage for the length of the stream"]
#[doc = "                        in bytes."]
#[doc = " \\param  client_data  The callee\'s client data set through"]
#[doc = "                      FLAC__stream_decoder_init_*()."]
#[doc = " \\retval FLAC__StreamDecoderLengthStatus"]
#[doc = "    The callee\'s return status."]
pub type FLAC__StreamDecoderLengthCallback = ::std::option::Option<
    unsafe extern "C" fn(
        decoder: *const FLAC__StreamDecoder,
        stream_length: *mut FLAC__uint64,
        client_data: *mut ::std::os::raw::c_void,
    ) -> FLAC__StreamDecoderLengthStatus,
>;
#[doc = " Signature for the EOF callback."]
#[doc = ""]
#[doc = "  A function pointer matching this signature may be passed to"]
#[doc = "  FLAC__stream_decoder_init*_stream().  The supplied function will be"]
#[doc = "  called when the decoder needs to know if the end of the stream has"]
#[doc = "  been reached."]
#[doc = ""]
#[doc = " Here is an example of a EOF callback for stdio streams:"]
#[doc = " FLAC__bool eof_cb(const FLAC__StreamDecoder *decoder, void *client_data)"]
#[doc = " \\code"]
#[doc = " {"]
#[doc = "   FILE *file = ((MyClientData*)client_data)->file;"]
#[doc = "   return feof(file)? true : false;"]
#[doc = " }"]
#[doc = " \\endcode"]
#[doc = ""]
#[doc = " \\note In general, FLAC__StreamDecoder functions which change the"]
#[doc = " state should not be called on the \\a decoder while in the callback."]
#[doc = ""]
#[doc = " \\param  decoder  The decoder instance calling the callback."]
#[doc = " \\param  client_data  The callee\'s client data set through"]
#[doc = "                      FLAC__stream_decoder_init_*()."]
#[doc = " \\retval FLAC__bool"]
#[doc = "    \\c true if the currently at the end of the stream, else \\c false."]
pub type FLAC__StreamDecoderEofCallback = ::std::option::Option<
    unsafe extern "C" fn(
        decoder: *const FLAC__StreamDecoder,
        client_data: *mut ::std::os::raw::c_void,
    ) -> FLAC__bool,
>;
#[doc = " Signature for the write callback."]
#[doc = ""]
#[doc = "  A function pointer matching this signature must be passed to one of"]
#[doc = "  the FLAC__stream_decoder_init_*() functions."]
#[doc = "  The supplied function will be called when the decoder has decoded a"]
#[doc = "  single audio frame.  The decoder will pass the frame metadata as well"]
#[doc = "  as an array of pointers (one for each channel) pointing to the"]
#[doc = "  decoded audio."]
#[doc = ""]
#[doc = " \\note In general, FLAC__StreamDecoder functions which change the"]
#[doc = " state should not be called on the \\a decoder while in the callback."]
#[doc = ""]
#[doc = " \\param  decoder  The decoder instance calling the callback."]
#[doc = " \\param  frame    The description of the decoded frame.  See"]
#[doc = "                  FLAC__Frame."]
#[doc = " \\param  buffer   An array of pointers to decoded channels of data."]
#[doc = "                  Each pointer will point to an array of signed"]
#[doc = "                  samples of length \\a frame->header.blocksize."]
#[doc = "                  Channels will be ordered according to the FLAC"]
#[doc = "                  specification; see the documentation for the"]
#[doc = "                  <A HREF=\"../format.html#frame_header\">frame header</A>."]
#[doc = " \\param  client_data  The callee\'s client data set through"]
#[doc = "                      FLAC__stream_decoder_init_*()."]
#[doc = " \\retval FLAC__StreamDecoderWriteStatus"]
#[doc = "    The callee\'s return status."]
pub type FLAC__StreamDecoderWriteCallback = ::std::option::Option<
    unsafe extern "C" fn(
        decoder: *const FLAC__StreamDecoder,
        frame: *const FLAC__Frame,
        buffer: *const *const FLAC__int32,
        client_data: *mut ::std::os::raw::c_void,
    ) -> FLAC__StreamDecoderWriteStatus,
>;
#[doc = " Signature for the metadata callback."]
#[doc = ""]
#[doc = "  A function pointer matching this signature must be passed to one of"]
#[doc = "  the FLAC__stream_decoder_init_*() functions."]
#[doc = "  The supplied function will be called when the decoder has decoded a"]
#[doc = "  metadata block.  In a valid FLAC file there will always be one"]
#[doc = "  \\c STREAMINFO block, followed by zero or more other metadata blocks."]
#[doc = "  These will be supplied by the decoder in the same order as they"]
#[doc = "  appear in the stream and always before the first audio frame (i.e."]
#[doc = "  write callback).  The metadata block that is passed in must not be"]
#[doc = "  modified, and it doesn\'t live beyond the callback, so you should make"]
#[doc = "  a copy of it with FLAC__metadata_object_clone() if you will need it"]
#[doc = "  elsewhere.  Since metadata blocks can potentially be large, by"]
#[doc = "  default the decoder only calls the metadata callback for the"]
#[doc = "  \\c STREAMINFO block; you can instruct the decoder to pass or filter"]
#[doc = "  other blocks with FLAC__stream_decoder_set_metadata_*() calls."]
#[doc = ""]
#[doc = " \\note In general, FLAC__StreamDecoder functions which change the"]
#[doc = " state should not be called on the \\a decoder while in the callback."]
#[doc = ""]
#[doc = " \\param  decoder  The decoder instance calling the callback."]
#[doc = " \\param  metadata The decoded metadata block."]
#[doc = " \\param  client_data  The callee\'s client data set through"]
#[doc = "                      FLAC__stream_decoder_init_*()."]
pub type FLAC__StreamDecoderMetadataCallback = ::std::option::Option<
    unsafe extern "C" fn(
        decoder: *const FLAC__StreamDecoder,
        metadata: *const FLAC__StreamMetadata,
        client_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Signature for the error callback."]
#[doc = ""]
#[doc = "  A function pointer matching this signature must be passed to one of"]
#[doc = "  the FLAC__stream_decoder_init_*() functions."]
#[doc = "  The supplied function will be called whenever an error occurs during"]
#[doc = "  decoding."]
#[doc = ""]
#[doc = " \\note In general, FLAC__StreamDecoder functions which change the"]
#[doc = " state should not be called on the \\a decoder while in the callback."]
#[doc = ""]
#[doc = " \\param  decoder  The decoder instance calling the callback."]
#[doc = " \\param  status   The error encountered by the decoder."]
#[doc = " \\param  client_data  The callee\'s client data set through"]
#[doc = "                      FLAC__stream_decoder_init_*()."]
pub type FLAC__StreamDecoderErrorCallback = ::std::option::Option<
    unsafe extern "C" fn(
        decoder: *const FLAC__StreamDecoder,
        status: FLAC__StreamDecoderErrorStatus,
        client_data: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " Create a new stream decoder instance.  The instance is created with"]
    #[doc = "  default settings; see the individual FLAC__stream_decoder_set_*()"]
    #[doc = "  functions for each setting\'s default."]
    #[doc = ""]
    #[doc = " \\retval FLAC__StreamDecoder*"]
    #[doc = "    \\c NULL if there was an error allocating memory, else the new instance."]
    pub fn FLAC__stream_decoder_new() -> *mut FLAC__StreamDecoder;
}
extern "C" {
    #[doc = " Free a decoder instance.  Deletes the object pointed to by \\a decoder."]
    #[doc = ""]
    #[doc = " \\param decoder  A pointer to an existing decoder."]
    #[doc = " \\assert"]
    #[doc = "    \\code decoder != NULL \\endcode"]
    pub fn FLAC__stream_decoder_delete(decoder: *mut FLAC__StreamDecoder);
}
extern "C" {
    #[doc = " Set the serial number for the FLAC stream within the Ogg container."]
    #[doc = "  The default behavior is to use the serial number of the first Ogg"]
    #[doc = "  page.  Setting a serial number here will explicitly specify which"]
    #[doc = "  stream is to be decoded."]
    #[doc = ""]
    #[doc = " \\note"]
    #[doc = " This does not need to be set for native FLAC decoding."]
    #[doc = ""]
    #[doc = " \\default \\c use serial number of first page"]
    #[doc = " \\param  decoder        A decoder instance to set."]
    #[doc = " \\param  serial_number  See above."]
    #[doc = " \\assert"]
    #[doc = "    \\code decoder != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if the decoder is already initialized, else \\c true."]
    pub fn FLAC__stream_decoder_set_ogg_serial_number(
        decoder: *mut FLAC__StreamDecoder,
        serial_number: ::std::os::raw::c_long,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Set the \"MD5 signature checking\" flag.  If \\c true, the decoder will"]
    #[doc = "  compute the MD5 signature of the unencoded audio data while decoding"]
    #[doc = "  and compare it to the signature from the STREAMINFO block, if it"]
    #[doc = "  exists, during FLAC__stream_decoder_finish()."]
    #[doc = ""]
    #[doc = "  MD5 signature checking will be turned off (until the next"]
    #[doc = "  FLAC__stream_decoder_reset()) if there is no signature in the"]
    #[doc = "  STREAMINFO block or when a seek is attempted."]
    #[doc = ""]
    #[doc = "  Clients that do not use the MD5 check should leave this off to speed"]
    #[doc = "  up decoding."]
    #[doc = ""]
    #[doc = " \\default \\c false"]
    #[doc = " \\param  decoder  A decoder instance to set."]
    #[doc = " \\param  value    Flag value (see above)."]
    #[doc = " \\assert"]
    #[doc = "    \\code decoder != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if the decoder is already initialized, else \\c true."]
    pub fn FLAC__stream_decoder_set_md5_checking(
        decoder: *mut FLAC__StreamDecoder,
        value: FLAC__bool,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Direct the decoder to pass on all metadata blocks of type \\a type."]
    #[doc = ""]
    #[doc = " \\default By default, only the \\c STREAMINFO block is returned via the"]
    #[doc = "          metadata callback."]
    #[doc = " \\param  decoder  A decoder instance to set."]
    #[doc = " \\param  type     See above."]
    #[doc = " \\assert"]
    #[doc = "    \\code decoder != NULL \\endcode"]
    #[doc = "    \\a type is valid"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if the decoder is already initialized, else \\c true."]
    pub fn FLAC__stream_decoder_set_metadata_respond(
        decoder: *mut FLAC__StreamDecoder,
        type_: FLAC__MetadataType,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Direct the decoder to pass on all APPLICATION metadata blocks of the"]
    #[doc = "  given \\a id."]
    #[doc = ""]
    #[doc = " \\default By default, only the \\c STREAMINFO block is returned via the"]
    #[doc = "          metadata callback."]
    #[doc = " \\param  decoder  A decoder instance to set."]
    #[doc = " \\param  id       See above."]
    #[doc = " \\assert"]
    #[doc = "    \\code decoder != NULL \\endcode"]
    #[doc = "    \\code id != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if the decoder is already initialized, else \\c true."]
    pub fn FLAC__stream_decoder_set_metadata_respond_application(
        decoder: *mut FLAC__StreamDecoder,
        id: *const FLAC__byte,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Direct the decoder to pass on all metadata blocks of any type."]
    #[doc = ""]
    #[doc = " \\default By default, only the \\c STREAMINFO block is returned via the"]
    #[doc = "          metadata callback."]
    #[doc = " \\param  decoder  A decoder instance to set."]
    #[doc = " \\assert"]
    #[doc = "    \\code decoder != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if the decoder is already initialized, else \\c true."]
    pub fn FLAC__stream_decoder_set_metadata_respond_all(
        decoder: *mut FLAC__StreamDecoder,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Direct the decoder to filter out all metadata blocks of type \\a type."]
    #[doc = ""]
    #[doc = " \\default By default, only the \\c STREAMINFO block is returned via the"]
    #[doc = "          metadata callback."]
    #[doc = " \\param  decoder  A decoder instance to set."]
    #[doc = " \\param  type     See above."]
    #[doc = " \\assert"]
    #[doc = "    \\code decoder != NULL \\endcode"]
    #[doc = "    \\a type is valid"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if the decoder is already initialized, else \\c true."]
    pub fn FLAC__stream_decoder_set_metadata_ignore(
        decoder: *mut FLAC__StreamDecoder,
        type_: FLAC__MetadataType,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Direct the decoder to filter out all APPLICATION metadata blocks of"]
    #[doc = "  the given \\a id."]
    #[doc = ""]
    #[doc = " \\default By default, only the \\c STREAMINFO block is returned via the"]
    #[doc = "          metadata callback."]
    #[doc = " \\param  decoder  A decoder instance to set."]
    #[doc = " \\param  id       See above."]
    #[doc = " \\assert"]
    #[doc = "    \\code decoder != NULL \\endcode"]
    #[doc = "    \\code id != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if the decoder is already initialized, else \\c true."]
    pub fn FLAC__stream_decoder_set_metadata_ignore_application(
        decoder: *mut FLAC__StreamDecoder,
        id: *const FLAC__byte,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Direct the decoder to filter out all metadata blocks of any type."]
    #[doc = ""]
    #[doc = " \\default By default, only the \\c STREAMINFO block is returned via the"]
    #[doc = "          metadata callback."]
    #[doc = " \\param  decoder  A decoder instance to set."]
    #[doc = " \\assert"]
    #[doc = "    \\code decoder != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if the decoder is already initialized, else \\c true."]
    pub fn FLAC__stream_decoder_set_metadata_ignore_all(
        decoder: *mut FLAC__StreamDecoder,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Get the current decoder state."]
    #[doc = ""]
    #[doc = " \\param  decoder  A decoder instance to query."]
    #[doc = " \\assert"]
    #[doc = "    \\code decoder != NULL \\endcode"]
    #[doc = " \\retval FLAC__StreamDecoderState"]
    #[doc = "    The current decoder state."]
    pub fn FLAC__stream_decoder_get_state(
        decoder: *const FLAC__StreamDecoder,
    ) -> FLAC__StreamDecoderState;
}
extern "C" {
    #[doc = " Get the current decoder state as a C string."]
    #[doc = ""]
    #[doc = " \\param  decoder  A decoder instance to query."]
    #[doc = " \\assert"]
    #[doc = "    \\code decoder != NULL \\endcode"]
    #[doc = " \\retval const char *"]
    #[doc = "    The decoder state as a C string.  Do not modify the contents."]
    pub fn FLAC__stream_decoder_get_resolved_state_string(
        decoder: *const FLAC__StreamDecoder,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the \"MD5 signature checking\" flag."]
    #[doc = "  This is the value of the setting, not whether or not the decoder is"]
    #[doc = "  currently checking the MD5 (remember, it can be turned off automatically"]
    #[doc = "  by a seek).  When the decoder is reset the flag will be restored to the"]
    #[doc = "  value returned by this function."]
    #[doc = ""]
    #[doc = " \\param  decoder  A decoder instance to query."]
    #[doc = " \\assert"]
    #[doc = "    \\code decoder != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    See above."]
    pub fn FLAC__stream_decoder_get_md5_checking(decoder: *const FLAC__StreamDecoder)
        -> FLAC__bool;
}
extern "C" {
    #[doc = " Get the total number of samples in the stream being decoded."]
    #[doc = "  Will only be valid after decoding has started and will contain the"]
    #[doc = "  value from the \\c STREAMINFO block.  A value of \\c 0 means \"unknown\"."]
    #[doc = ""]
    #[doc = " \\param  decoder  A decoder instance to query."]
    #[doc = " \\assert"]
    #[doc = "    \\code decoder != NULL \\endcode"]
    #[doc = " \\retval unsigned"]
    #[doc = "    See above."]
    pub fn FLAC__stream_decoder_get_total_samples(
        decoder: *const FLAC__StreamDecoder,
    ) -> FLAC__uint64;
}
extern "C" {
    #[doc = " Get the current number of channels in the stream being decoded."]
    #[doc = "  Will only be valid after decoding has started and will contain the"]
    #[doc = "  value from the most recently decoded frame header."]
    #[doc = ""]
    #[doc = " \\param  decoder  A decoder instance to query."]
    #[doc = " \\assert"]
    #[doc = "    \\code decoder != NULL \\endcode"]
    #[doc = " \\retval unsigned"]
    #[doc = "    See above."]
    pub fn FLAC__stream_decoder_get_channels(
        decoder: *const FLAC__StreamDecoder,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Get the current channel assignment in the stream being decoded."]
    #[doc = "  Will only be valid after decoding has started and will contain the"]
    #[doc = "  value from the most recently decoded frame header."]
    #[doc = ""]
    #[doc = " \\param  decoder  A decoder instance to query."]
    #[doc = " \\assert"]
    #[doc = "    \\code decoder != NULL \\endcode"]
    #[doc = " \\retval FLAC__ChannelAssignment"]
    #[doc = "    See above."]
    pub fn FLAC__stream_decoder_get_channel_assignment(
        decoder: *const FLAC__StreamDecoder,
    ) -> FLAC__ChannelAssignment;
}
extern "C" {
    #[doc = " Get the current sample resolution in the stream being decoded."]
    #[doc = "  Will only be valid after decoding has started and will contain the"]
    #[doc = "  value from the most recently decoded frame header."]
    #[doc = ""]
    #[doc = " \\param  decoder  A decoder instance to query."]
    #[doc = " \\assert"]
    #[doc = "    \\code decoder != NULL \\endcode"]
    #[doc = " \\retval unsigned"]
    #[doc = "    See above."]
    pub fn FLAC__stream_decoder_get_bits_per_sample(
        decoder: *const FLAC__StreamDecoder,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Get the current sample rate in Hz of the stream being decoded."]
    #[doc = "  Will only be valid after decoding has started and will contain the"]
    #[doc = "  value from the most recently decoded frame header."]
    #[doc = ""]
    #[doc = " \\param  decoder  A decoder instance to query."]
    #[doc = " \\assert"]
    #[doc = "    \\code decoder != NULL \\endcode"]
    #[doc = " \\retval unsigned"]
    #[doc = "    See above."]
    pub fn FLAC__stream_decoder_get_sample_rate(
        decoder: *const FLAC__StreamDecoder,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Get the current blocksize of the stream being decoded."]
    #[doc = "  Will only be valid after decoding has started and will contain the"]
    #[doc = "  value from the most recently decoded frame header."]
    #[doc = ""]
    #[doc = " \\param  decoder  A decoder instance to query."]
    #[doc = " \\assert"]
    #[doc = "    \\code decoder != NULL \\endcode"]
    #[doc = " \\retval unsigned"]
    #[doc = "    See above."]
    pub fn FLAC__stream_decoder_get_blocksize(
        decoder: *const FLAC__StreamDecoder,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Returns the decoder\'s current read position within the stream."]
    #[doc = "  The position is the byte offset from the start of the stream."]
    #[doc = "  Bytes before this position have been fully decoded.  Note that"]
    #[doc = "  there may still be undecoded bytes in the decoder\'s read FIFO."]
    #[doc = "  The returned position is correct even after a seek."]
    #[doc = ""]
    #[doc = "  \\warning This function currently only works for native FLAC,"]
    #[doc = "           not Ogg FLAC streams."]
    #[doc = ""]
    #[doc = " \\param  decoder   A decoder instance to query."]
    #[doc = " \\param  position  Address at which to return the desired position."]
    #[doc = " \\assert"]
    #[doc = "    \\code decoder != NULL \\endcode"]
    #[doc = "    \\code position != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c true if successful, \\c false if the stream is not native FLAC,"]
    #[doc = "    or there was an error from the \'tell\' callback or it returned"]
    #[doc = "    \\c FLAC__STREAM_DECODER_TELL_STATUS_UNSUPPORTED."]
    pub fn FLAC__stream_decoder_get_decode_position(
        decoder: *const FLAC__StreamDecoder,
        position: *mut FLAC__uint64,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Initialize the decoder instance to decode native FLAC streams."]
    #[doc = ""]
    #[doc = "  This flavor of initialization sets up the decoder to decode from a"]
    #[doc = "  native FLAC stream. I/O is performed via callbacks to the client."]
    #[doc = "  For decoding from a plain file via filename or open FILE*,"]
    #[doc = "  FLAC__stream_decoder_init_file() and FLAC__stream_decoder_init_FILE()"]
    #[doc = "  provide a simpler interface."]
    #[doc = ""]
    #[doc = "  This function should be called after FLAC__stream_decoder_new() and"]
    #[doc = "  FLAC__stream_decoder_set_*() but before any of the"]
    #[doc = "  FLAC__stream_decoder_process_*() functions.  Will set and return the"]
    #[doc = "  decoder state, which will be FLAC__STREAM_DECODER_SEARCH_FOR_METADATA"]
    #[doc = "  if initialization succeeded."]
    #[doc = ""]
    #[doc = " \\param  decoder            An uninitialized decoder instance."]
    #[doc = " \\param  read_callback      See FLAC__StreamDecoderReadCallback.  This"]
    #[doc = "                            pointer must not be \\c NULL."]
    #[doc = " \\param  seek_callback      See FLAC__StreamDecoderSeekCallback.  This"]
    #[doc = "                            pointer may be \\c NULL if seeking is not"]
    #[doc = "                            supported.  If \\a seek_callback is not \\c NULL then a"]
    #[doc = "                            \\a tell_callback, \\a length_callback, and \\a eof_callback must also be supplied."]
    #[doc = "                            Alternatively, a dummy seek callback that just"]
    #[doc = "                            returns \\c FLAC__STREAM_DECODER_SEEK_STATUS_UNSUPPORTED"]
    #[doc = "                            may also be supplied, all though this is slightly"]
    #[doc = "                            less efficient for the decoder."]
    #[doc = " \\param  tell_callback      See FLAC__StreamDecoderTellCallback.  This"]
    #[doc = "                            pointer may be \\c NULL if not supported by the client.  If"]
    #[doc = "                            \\a seek_callback is not \\c NULL then a"]
    #[doc = "                            \\a tell_callback must also be supplied."]
    #[doc = "                            Alternatively, a dummy tell callback that just"]
    #[doc = "                            returns \\c FLAC__STREAM_DECODER_TELL_STATUS_UNSUPPORTED"]
    #[doc = "                            may also be supplied, all though this is slightly"]
    #[doc = "                            less efficient for the decoder."]
    #[doc = " \\param  length_callback    See FLAC__StreamDecoderLengthCallback.  This"]
    #[doc = "                            pointer may be \\c NULL if not supported by the client.  If"]
    #[doc = "                            \\a seek_callback is not \\c NULL then a"]
    #[doc = "                            \\a length_callback must also be supplied."]
    #[doc = "                            Alternatively, a dummy length callback that just"]
    #[doc = "                            returns \\c FLAC__STREAM_DECODER_LENGTH_STATUS_UNSUPPORTED"]
    #[doc = "                            may also be supplied, all though this is slightly"]
    #[doc = "                            less efficient for the decoder."]
    #[doc = " \\param  eof_callback       See FLAC__StreamDecoderEofCallback.  This"]
    #[doc = "                            pointer may be \\c NULL if not supported by the client.  If"]
    #[doc = "                            \\a seek_callback is not \\c NULL then a"]
    #[doc = "                            \\a eof_callback must also be supplied."]
    #[doc = "                            Alternatively, a dummy length callback that just"]
    #[doc = "                            returns \\c false"]
    #[doc = "                            may also be supplied, all though this is slightly"]
    #[doc = "                            less efficient for the decoder."]
    #[doc = " \\param  write_callback     See FLAC__StreamDecoderWriteCallback.  This"]
    #[doc = "                            pointer must not be \\c NULL."]
    #[doc = " \\param  metadata_callback  See FLAC__StreamDecoderMetadataCallback.  This"]
    #[doc = "                            pointer may be \\c NULL if the callback is not"]
    #[doc = "                            desired."]
    #[doc = " \\param  error_callback     See FLAC__StreamDecoderErrorCallback.  This"]
    #[doc = "                            pointer must not be \\c NULL."]
    #[doc = " \\param  client_data        This value will be supplied to callbacks in their"]
    #[doc = "                            \\a client_data argument."]
    #[doc = " \\assert"]
    #[doc = "    \\code decoder != NULL \\endcode"]
    #[doc = " \\retval FLAC__StreamDecoderInitStatus"]
    #[doc = "    \\c FLAC__STREAM_DECODER_INIT_STATUS_OK if initialization was successful;"]
    #[doc = "    see FLAC__StreamDecoderInitStatus for the meanings of other return values."]
    pub fn FLAC__stream_decoder_init_stream(
        decoder: *mut FLAC__StreamDecoder,
        read_callback: FLAC__StreamDecoderReadCallback,
        seek_callback: FLAC__StreamDecoderSeekCallback,
        tell_callback: FLAC__StreamDecoderTellCallback,
        length_callback: FLAC__StreamDecoderLengthCallback,
        eof_callback: FLAC__StreamDecoderEofCallback,
        write_callback: FLAC__StreamDecoderWriteCallback,
        metadata_callback: FLAC__StreamDecoderMetadataCallback,
        error_callback: FLAC__StreamDecoderErrorCallback,
        client_data: *mut ::std::os::raw::c_void,
    ) -> FLAC__StreamDecoderInitStatus;
}
extern "C" {
    #[doc = " Initialize the decoder instance to decode Ogg FLAC streams."]
    #[doc = ""]
    #[doc = "  This flavor of initialization sets up the decoder to decode from a"]
    #[doc = "  FLAC stream in an Ogg container. I/O is performed via callbacks to the"]
    #[doc = "  client.  For decoding from a plain file via filename or open FILE*,"]
    #[doc = "  FLAC__stream_decoder_init_ogg_file() and FLAC__stream_decoder_init_ogg_FILE()"]
    #[doc = "  provide a simpler interface."]
    #[doc = ""]
    #[doc = "  This function should be called after FLAC__stream_decoder_new() and"]
    #[doc = "  FLAC__stream_decoder_set_*() but before any of the"]
    #[doc = "  FLAC__stream_decoder_process_*() functions.  Will set and return the"]
    #[doc = "  decoder state, which will be FLAC__STREAM_DECODER_SEARCH_FOR_METADATA"]
    #[doc = "  if initialization succeeded."]
    #[doc = ""]
    #[doc = "  \\note Support for Ogg FLAC in the library is optional.  If this"]
    #[doc = "  library has been built without support for Ogg FLAC, this function"]
    #[doc = "  will return \\c FLAC__STREAM_DECODER_INIT_STATUS_UNSUPPORTED_CONTAINER."]
    #[doc = ""]
    #[doc = " \\param  decoder            An uninitialized decoder instance."]
    #[doc = " \\param  read_callback      See FLAC__StreamDecoderReadCallback.  This"]
    #[doc = "                            pointer must not be \\c NULL."]
    #[doc = " \\param  seek_callback      See FLAC__StreamDecoderSeekCallback.  This"]
    #[doc = "                            pointer may be \\c NULL if seeking is not"]
    #[doc = "                            supported.  If \\a seek_callback is not \\c NULL then a"]
    #[doc = "                            \\a tell_callback, \\a length_callback, and \\a eof_callback must also be supplied."]
    #[doc = "                            Alternatively, a dummy seek callback that just"]
    #[doc = "                            returns \\c FLAC__STREAM_DECODER_SEEK_STATUS_UNSUPPORTED"]
    #[doc = "                            may also be supplied, all though this is slightly"]
    #[doc = "                            less efficient for the decoder."]
    #[doc = " \\param  tell_callback      See FLAC__StreamDecoderTellCallback.  This"]
    #[doc = "                            pointer may be \\c NULL if not supported by the client.  If"]
    #[doc = "                            \\a seek_callback is not \\c NULL then a"]
    #[doc = "                            \\a tell_callback must also be supplied."]
    #[doc = "                            Alternatively, a dummy tell callback that just"]
    #[doc = "                            returns \\c FLAC__STREAM_DECODER_TELL_STATUS_UNSUPPORTED"]
    #[doc = "                            may also be supplied, all though this is slightly"]
    #[doc = "                            less efficient for the decoder."]
    #[doc = " \\param  length_callback    See FLAC__StreamDecoderLengthCallback.  This"]
    #[doc = "                            pointer may be \\c NULL if not supported by the client.  If"]
    #[doc = "                            \\a seek_callback is not \\c NULL then a"]
    #[doc = "                            \\a length_callback must also be supplied."]
    #[doc = "                            Alternatively, a dummy length callback that just"]
    #[doc = "                            returns \\c FLAC__STREAM_DECODER_LENGTH_STATUS_UNSUPPORTED"]
    #[doc = "                            may also be supplied, all though this is slightly"]
    #[doc = "                            less efficient for the decoder."]
    #[doc = " \\param  eof_callback       See FLAC__StreamDecoderEofCallback.  This"]
    #[doc = "                            pointer may be \\c NULL if not supported by the client.  If"]
    #[doc = "                            \\a seek_callback is not \\c NULL then a"]
    #[doc = "                            \\a eof_callback must also be supplied."]
    #[doc = "                            Alternatively, a dummy length callback that just"]
    #[doc = "                            returns \\c false"]
    #[doc = "                            may also be supplied, all though this is slightly"]
    #[doc = "                            less efficient for the decoder."]
    #[doc = " \\param  write_callback     See FLAC__StreamDecoderWriteCallback.  This"]
    #[doc = "                            pointer must not be \\c NULL."]
    #[doc = " \\param  metadata_callback  See FLAC__StreamDecoderMetadataCallback.  This"]
    #[doc = "                            pointer may be \\c NULL if the callback is not"]
    #[doc = "                            desired."]
    #[doc = " \\param  error_callback     See FLAC__StreamDecoderErrorCallback.  This"]
    #[doc = "                            pointer must not be \\c NULL."]
    #[doc = " \\param  client_data        This value will be supplied to callbacks in their"]
    #[doc = "                            \\a client_data argument."]
    #[doc = " \\assert"]
    #[doc = "    \\code decoder != NULL \\endcode"]
    #[doc = " \\retval FLAC__StreamDecoderInitStatus"]
    #[doc = "    \\c FLAC__STREAM_DECODER_INIT_STATUS_OK if initialization was successful;"]
    #[doc = "    see FLAC__StreamDecoderInitStatus for the meanings of other return values."]
    pub fn FLAC__stream_decoder_init_ogg_stream(
        decoder: *mut FLAC__StreamDecoder,
        read_callback: FLAC__StreamDecoderReadCallback,
        seek_callback: FLAC__StreamDecoderSeekCallback,
        tell_callback: FLAC__StreamDecoderTellCallback,
        length_callback: FLAC__StreamDecoderLengthCallback,
        eof_callback: FLAC__StreamDecoderEofCallback,
        write_callback: FLAC__StreamDecoderWriteCallback,
        metadata_callback: FLAC__StreamDecoderMetadataCallback,
        error_callback: FLAC__StreamDecoderErrorCallback,
        client_data: *mut ::std::os::raw::c_void,
    ) -> FLAC__StreamDecoderInitStatus;
}
extern "C" {
    #[doc = " Initialize the decoder instance to decode native FLAC files."]
    #[doc = ""]
    #[doc = "  This flavor of initialization sets up the decoder to decode from a"]
    #[doc = "  plain native FLAC file.  For non-stdio streams, you must use"]
    #[doc = "  FLAC__stream_decoder_init_stream() and provide callbacks for the I/O."]
    #[doc = ""]
    #[doc = "  This function should be called after FLAC__stream_decoder_new() and"]
    #[doc = "  FLAC__stream_decoder_set_*() but before any of the"]
    #[doc = "  FLAC__stream_decoder_process_*() functions.  Will set and return the"]
    #[doc = "  decoder state, which will be FLAC__STREAM_DECODER_SEARCH_FOR_METADATA"]
    #[doc = "  if initialization succeeded."]
    #[doc = ""]
    #[doc = " \\param  decoder            An uninitialized decoder instance."]
    #[doc = " \\param  file               An open FLAC file.  The file should have been"]
    #[doc = "                            opened with mode \\c \"rb\" and rewound.  The file"]
    #[doc = "                            becomes owned by the decoder and should not be"]
    #[doc = "                            manipulated by the client while decoding."]
    #[doc = "                            Unless \\a file is \\c stdin, it will be closed"]
    #[doc = "                            when FLAC__stream_decoder_finish() is called."]
    #[doc = "                            Note however that seeking will not work when"]
    #[doc = "                            decoding from \\c stdout since it is not seekable."]
    #[doc = " \\param  write_callback     See FLAC__StreamDecoderWriteCallback.  This"]
    #[doc = "                            pointer must not be \\c NULL."]
    #[doc = " \\param  metadata_callback  See FLAC__StreamDecoderMetadataCallback.  This"]
    #[doc = "                            pointer may be \\c NULL if the callback is not"]
    #[doc = "                            desired."]
    #[doc = " \\param  error_callback     See FLAC__StreamDecoderErrorCallback.  This"]
    #[doc = "                            pointer must not be \\c NULL."]
    #[doc = " \\param  client_data        This value will be supplied to callbacks in their"]
    #[doc = "                            \\a client_data argument."]
    #[doc = " \\assert"]
    #[doc = "    \\code decoder != NULL \\endcode"]
    #[doc = "    \\code file != NULL \\endcode"]
    #[doc = " \\retval FLAC__StreamDecoderInitStatus"]
    #[doc = "    \\c FLAC__STREAM_DECODER_INIT_STATUS_OK if initialization was successful;"]
    #[doc = "    see FLAC__StreamDecoderInitStatus for the meanings of other return values."]
    pub fn FLAC__stream_decoder_init_FILE(
        decoder: *mut FLAC__StreamDecoder,
        file: *mut FILE,
        write_callback: FLAC__StreamDecoderWriteCallback,
        metadata_callback: FLAC__StreamDecoderMetadataCallback,
        error_callback: FLAC__StreamDecoderErrorCallback,
        client_data: *mut ::std::os::raw::c_void,
    ) -> FLAC__StreamDecoderInitStatus;
}
extern "C" {
    #[doc = " Initialize the decoder instance to decode Ogg FLAC files."]
    #[doc = ""]
    #[doc = "  This flavor of initialization sets up the decoder to decode from a"]
    #[doc = "  plain Ogg FLAC file.  For non-stdio streams, you must use"]
    #[doc = "  FLAC__stream_decoder_init_ogg_stream() and provide callbacks for the I/O."]
    #[doc = ""]
    #[doc = "  This function should be called after FLAC__stream_decoder_new() and"]
    #[doc = "  FLAC__stream_decoder_set_*() but before any of the"]
    #[doc = "  FLAC__stream_decoder_process_*() functions.  Will set and return the"]
    #[doc = "  decoder state, which will be FLAC__STREAM_DECODER_SEARCH_FOR_METADATA"]
    #[doc = "  if initialization succeeded."]
    #[doc = ""]
    #[doc = "  \\note Support for Ogg FLAC in the library is optional.  If this"]
    #[doc = "  library has been built without support for Ogg FLAC, this function"]
    #[doc = "  will return \\c FLAC__STREAM_DECODER_INIT_STATUS_UNSUPPORTED_CONTAINER."]
    #[doc = ""]
    #[doc = " \\param  decoder            An uninitialized decoder instance."]
    #[doc = " \\param  file               An open FLAC file.  The file should have been"]
    #[doc = "                            opened with mode \\c \"rb\" and rewound.  The file"]
    #[doc = "                            becomes owned by the decoder and should not be"]
    #[doc = "                            manipulated by the client while decoding."]
    #[doc = "                            Unless \\a file is \\c stdin, it will be closed"]
    #[doc = "                            when FLAC__stream_decoder_finish() is called."]
    #[doc = "                            Note however that seeking will not work when"]
    #[doc = "                            decoding from \\c stdout since it is not seekable."]
    #[doc = " \\param  write_callback     See FLAC__StreamDecoderWriteCallback.  This"]
    #[doc = "                            pointer must not be \\c NULL."]
    #[doc = " \\param  metadata_callback  See FLAC__StreamDecoderMetadataCallback.  This"]
    #[doc = "                            pointer may be \\c NULL if the callback is not"]
    #[doc = "                            desired."]
    #[doc = " \\param  error_callback     See FLAC__StreamDecoderErrorCallback.  This"]
    #[doc = "                            pointer must not be \\c NULL."]
    #[doc = " \\param  client_data        This value will be supplied to callbacks in their"]
    #[doc = "                            \\a client_data argument."]
    #[doc = " \\assert"]
    #[doc = "    \\code decoder != NULL \\endcode"]
    #[doc = "    \\code file != NULL \\endcode"]
    #[doc = " \\retval FLAC__StreamDecoderInitStatus"]
    #[doc = "    \\c FLAC__STREAM_DECODER_INIT_STATUS_OK if initialization was successful;"]
    #[doc = "    see FLAC__StreamDecoderInitStatus for the meanings of other return values."]
    pub fn FLAC__stream_decoder_init_ogg_FILE(
        decoder: *mut FLAC__StreamDecoder,
        file: *mut FILE,
        write_callback: FLAC__StreamDecoderWriteCallback,
        metadata_callback: FLAC__StreamDecoderMetadataCallback,
        error_callback: FLAC__StreamDecoderErrorCallback,
        client_data: *mut ::std::os::raw::c_void,
    ) -> FLAC__StreamDecoderInitStatus;
}
extern "C" {
    #[doc = " Initialize the decoder instance to decode native FLAC files."]
    #[doc = ""]
    #[doc = "  This flavor of initialization sets up the decoder to decode from a plain"]
    #[doc = "  native FLAC file.  If POSIX fopen() semantics are not sufficient, (for"]
    #[doc = "  example, with Unicode filenames on Windows), you must use"]
    #[doc = "  FLAC__stream_decoder_init_FILE(), or FLAC__stream_decoder_init_stream()"]
    #[doc = "  and provide callbacks for the I/O."]
    #[doc = ""]
    #[doc = "  This function should be called after FLAC__stream_decoder_new() and"]
    #[doc = "  FLAC__stream_decoder_set_*() but before any of the"]
    #[doc = "  FLAC__stream_decoder_process_*() functions.  Will set and return the"]
    #[doc = "  decoder state, which will be FLAC__STREAM_DECODER_SEARCH_FOR_METADATA"]
    #[doc = "  if initialization succeeded."]
    #[doc = ""]
    #[doc = " \\param  decoder            An uninitialized decoder instance."]
    #[doc = " \\param  filename           The name of the file to decode from.  The file will"]
    #[doc = "                            be opened with fopen().  Use \\c NULL to decode from"]
    #[doc = "                            \\c stdin.  Note that \\c stdin is not seekable."]
    #[doc = " \\param  write_callback     See FLAC__StreamDecoderWriteCallback.  This"]
    #[doc = "                            pointer must not be \\c NULL."]
    #[doc = " \\param  metadata_callback  See FLAC__StreamDecoderMetadataCallback.  This"]
    #[doc = "                            pointer may be \\c NULL if the callback is not"]
    #[doc = "                            desired."]
    #[doc = " \\param  error_callback     See FLAC__StreamDecoderErrorCallback.  This"]
    #[doc = "                            pointer must not be \\c NULL."]
    #[doc = " \\param  client_data        This value will be supplied to callbacks in their"]
    #[doc = "                            \\a client_data argument."]
    #[doc = " \\assert"]
    #[doc = "    \\code decoder != NULL \\endcode"]
    #[doc = " \\retval FLAC__StreamDecoderInitStatus"]
    #[doc = "    \\c FLAC__STREAM_DECODER_INIT_STATUS_OK if initialization was successful;"]
    #[doc = "    see FLAC__StreamDecoderInitStatus for the meanings of other return values."]
    pub fn FLAC__stream_decoder_init_file(
        decoder: *mut FLAC__StreamDecoder,
        filename: *const ::std::os::raw::c_char,
        write_callback: FLAC__StreamDecoderWriteCallback,
        metadata_callback: FLAC__StreamDecoderMetadataCallback,
        error_callback: FLAC__StreamDecoderErrorCallback,
        client_data: *mut ::std::os::raw::c_void,
    ) -> FLAC__StreamDecoderInitStatus;
}
extern "C" {
    #[doc = " Initialize the decoder instance to decode Ogg FLAC files."]
    #[doc = ""]
    #[doc = "  This flavor of initialization sets up the decoder to decode from a plain"]
    #[doc = "  Ogg FLAC file.  If POSIX fopen() semantics are not sufficient, (for"]
    #[doc = "  example, with Unicode filenames on Windows), you must use"]
    #[doc = "  FLAC__stream_decoder_init_ogg_FILE(), or FLAC__stream_decoder_init_ogg_stream()"]
    #[doc = "  and provide callbacks for the I/O."]
    #[doc = ""]
    #[doc = "  This function should be called after FLAC__stream_decoder_new() and"]
    #[doc = "  FLAC__stream_decoder_set_*() but before any of the"]
    #[doc = "  FLAC__stream_decoder_process_*() functions.  Will set and return the"]
    #[doc = "  decoder state, which will be FLAC__STREAM_DECODER_SEARCH_FOR_METADATA"]
    #[doc = "  if initialization succeeded."]
    #[doc = ""]
    #[doc = "  \\note Support for Ogg FLAC in the library is optional.  If this"]
    #[doc = "  library has been built without support for Ogg FLAC, this function"]
    #[doc = "  will return \\c FLAC__STREAM_DECODER_INIT_STATUS_UNSUPPORTED_CONTAINER."]
    #[doc = ""]
    #[doc = " \\param  decoder            An uninitialized decoder instance."]
    #[doc = " \\param  filename           The name of the file to decode from.  The file will"]
    #[doc = "                            be opened with fopen().  Use \\c NULL to decode from"]
    #[doc = "                            \\c stdin.  Note that \\c stdin is not seekable."]
    #[doc = " \\param  write_callback     See FLAC__StreamDecoderWriteCallback.  This"]
    #[doc = "                            pointer must not be \\c NULL."]
    #[doc = " \\param  metadata_callback  See FLAC__StreamDecoderMetadataCallback.  This"]
    #[doc = "                            pointer may be \\c NULL if the callback is not"]
    #[doc = "                            desired."]
    #[doc = " \\param  error_callback     See FLAC__StreamDecoderErrorCallback.  This"]
    #[doc = "                            pointer must not be \\c NULL."]
    #[doc = " \\param  client_data        This value will be supplied to callbacks in their"]
    #[doc = "                            \\a client_data argument."]
    #[doc = " \\assert"]
    #[doc = "    \\code decoder != NULL \\endcode"]
    #[doc = " \\retval FLAC__StreamDecoderInitStatus"]
    #[doc = "    \\c FLAC__STREAM_DECODER_INIT_STATUS_OK if initialization was successful;"]
    #[doc = "    see FLAC__StreamDecoderInitStatus for the meanings of other return values."]
    pub fn FLAC__stream_decoder_init_ogg_file(
        decoder: *mut FLAC__StreamDecoder,
        filename: *const ::std::os::raw::c_char,
        write_callback: FLAC__StreamDecoderWriteCallback,
        metadata_callback: FLAC__StreamDecoderMetadataCallback,
        error_callback: FLAC__StreamDecoderErrorCallback,
        client_data: *mut ::std::os::raw::c_void,
    ) -> FLAC__StreamDecoderInitStatus;
}
extern "C" {
    #[doc = " Finish the decoding process."]
    #[doc = "  Flushes the decoding buffer, releases resources, resets the decoder"]
    #[doc = "  settings to their defaults, and returns the decoder state to"]
    #[doc = "  FLAC__STREAM_DECODER_UNINITIALIZED."]
    #[doc = ""]
    #[doc = "  In the event of a prematurely-terminated decode, it is not strictly"]
    #[doc = "  necessary to call this immediately before FLAC__stream_decoder_delete()"]
    #[doc = "  but it is good practice to match every FLAC__stream_decoder_init_*()"]
    #[doc = "  with a FLAC__stream_decoder_finish()."]
    #[doc = ""]
    #[doc = " \\param  decoder  An uninitialized decoder instance."]
    #[doc = " \\assert"]
    #[doc = "    \\code decoder != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if MD5 checking is on AND a STREAMINFO block was available"]
    #[doc = "    AND the MD5 signature in the STREAMINFO block was non-zero AND the"]
    #[doc = "    signature does not match the one computed by the decoder; else"]
    #[doc = "    \\c true."]
    pub fn FLAC__stream_decoder_finish(decoder: *mut FLAC__StreamDecoder) -> FLAC__bool;
}
extern "C" {
    #[doc = " Flush the stream input."]
    #[doc = "  The decoder\'s input buffer will be cleared and the state set to"]
    #[doc = "  \\c FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC.  This will also turn"]
    #[doc = "  off MD5 checking."]
    #[doc = ""]
    #[doc = " \\param  decoder  A decoder instance."]
    #[doc = " \\assert"]
    #[doc = "    \\code decoder != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c true if successful, else \\c false if a memory allocation"]
    #[doc = "    error occurs (in which case the state will be set to"]
    #[doc = "    \\c FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR)."]
    pub fn FLAC__stream_decoder_flush(decoder: *mut FLAC__StreamDecoder) -> FLAC__bool;
}
extern "C" {
    #[doc = " Reset the decoding process."]
    #[doc = "  The decoder\'s input buffer will be cleared and the state set to"]
    #[doc = "  \\c FLAC__STREAM_DECODER_SEARCH_FOR_METADATA.  This is similar to"]
    #[doc = "  FLAC__stream_decoder_finish() except that the settings are"]
    #[doc = "  preserved; there is no need to call FLAC__stream_decoder_init_*()"]
    #[doc = "  before decoding again.  MD5 checking will be restored to its original"]
    #[doc = "  setting."]
    #[doc = ""]
    #[doc = "  If the decoder is seekable, or was initialized with"]
    #[doc = "  FLAC__stream_decoder_init*_FILE() or FLAC__stream_decoder_init*_file(),"]
    #[doc = "  the decoder will also attempt to seek to the beginning of the file."]
    #[doc = "  If this rewind fails, this function will return \\c false.  It follows"]
    #[doc = "  that FLAC__stream_decoder_reset() cannot be used when decoding from"]
    #[doc = "  \\c stdin."]
    #[doc = ""]
    #[doc = "  If the decoder was initialized with FLAC__stream_encoder_init*_stream()"]
    #[doc = "  and is not seekable (i.e. no seek callback was provided or the seek"]
    #[doc = "  callback returns \\c FLAC__STREAM_DECODER_SEEK_STATUS_UNSUPPORTED), it"]
    #[doc = "  is the duty of the client to start feeding data from the beginning of"]
    #[doc = "  the stream on the next FLAC__stream_decoder_process() or"]
    #[doc = "  FLAC__stream_decoder_process_interleaved() call."]
    #[doc = ""]
    #[doc = " \\param  decoder  A decoder instance."]
    #[doc = " \\assert"]
    #[doc = "    \\code decoder != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c true if successful, else \\c false if a memory allocation occurs"]
    #[doc = "    (in which case the state will be set to"]
    #[doc = "    \\c FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR) or a seek error"]
    #[doc = "    occurs (the state will be unchanged)."]
    pub fn FLAC__stream_decoder_reset(decoder: *mut FLAC__StreamDecoder) -> FLAC__bool;
}
extern "C" {
    #[doc = " Decode one metadata block or audio frame."]
    #[doc = "  This version instructs the decoder to decode a either a single metadata"]
    #[doc = "  block or a single frame and stop, unless the callbacks return a fatal"]
    #[doc = "  error or the read callback returns"]
    #[doc = "  \\c FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM."]
    #[doc = ""]
    #[doc = "  As the decoder needs more input it will call the read callback."]
    #[doc = "  Depending on what was decoded, the metadata or write callback will be"]
    #[doc = "  called with the decoded metadata block or audio frame."]
    #[doc = ""]
    #[doc = "  Unless there is a fatal read error or end of stream, this function"]
    #[doc = "  will return once one whole frame is decoded.  In other words, if the"]
    #[doc = "  stream is not synchronized or points to a corrupt frame header, the"]
    #[doc = "  decoder will continue to try and resync until it gets to a valid"]
    #[doc = "  frame, then decode one frame, then return.  If the decoder points to"]
    #[doc = "  a frame whose frame CRC in the frame footer does not match the"]
    #[doc = "  computed frame CRC, this function will issue a"]
    #[doc = "  FLAC__STREAM_DECODER_ERROR_STATUS_FRAME_CRC_MISMATCH error to the"]
    #[doc = "  error callback, and return, having decoded one complete, although"]
    #[doc = "  corrupt, frame.  (Such corrupted frames are sent as silence of the"]
    #[doc = "  correct length to the write callback.)"]
    #[doc = ""]
    #[doc = " \\param  decoder  An initialized decoder instance."]
    #[doc = " \\assert"]
    #[doc = "    \\code decoder != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if any fatal read, write, or memory allocation error"]
    #[doc = "    occurred (meaning decoding must stop), else \\c true; for more"]
    #[doc = "    information about the decoder, check the decoder state with"]
    #[doc = "    FLAC__stream_decoder_get_state()."]
    pub fn FLAC__stream_decoder_process_single(decoder: *mut FLAC__StreamDecoder) -> FLAC__bool;
}
extern "C" {
    #[doc = " Decode until the end of the metadata."]
    #[doc = "  This version instructs the decoder to decode from the current position"]
    #[doc = "  and continue until all the metadata has been read, or until the"]
    #[doc = "  callbacks return a fatal error or the read callback returns"]
    #[doc = "  \\c FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM."]
    #[doc = ""]
    #[doc = "  As the decoder needs more input it will call the read callback."]
    #[doc = "  As each metadata block is decoded, the metadata callback will be called"]
    #[doc = "  with the decoded metadata."]
    #[doc = ""]
    #[doc = " \\param  decoder  An initialized decoder instance."]
    #[doc = " \\assert"]
    #[doc = "    \\code decoder != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if any fatal read, write, or memory allocation error"]
    #[doc = "    occurred (meaning decoding must stop), else \\c true; for more"]
    #[doc = "    information about the decoder, check the decoder state with"]
    #[doc = "    FLAC__stream_decoder_get_state()."]
    pub fn FLAC__stream_decoder_process_until_end_of_metadata(
        decoder: *mut FLAC__StreamDecoder,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Decode until the end of the stream."]
    #[doc = "  This version instructs the decoder to decode from the current position"]
    #[doc = "  and continue until the end of stream (the read callback returns"]
    #[doc = "  \\c FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM), or until the"]
    #[doc = "  callbacks return a fatal error."]
    #[doc = ""]
    #[doc = "  As the decoder needs more input it will call the read callback."]
    #[doc = "  As each metadata block and frame is decoded, the metadata or write"]
    #[doc = "  callback will be called with the decoded metadata or frame."]
    #[doc = ""]
    #[doc = " \\param  decoder  An initialized decoder instance."]
    #[doc = " \\assert"]
    #[doc = "    \\code decoder != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if any fatal read, write, or memory allocation error"]
    #[doc = "    occurred (meaning decoding must stop), else \\c true; for more"]
    #[doc = "    information about the decoder, check the decoder state with"]
    #[doc = "    FLAC__stream_decoder_get_state()."]
    pub fn FLAC__stream_decoder_process_until_end_of_stream(
        decoder: *mut FLAC__StreamDecoder,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Skip one audio frame."]
    #[doc = "  This version instructs the decoder to \'skip\' a single frame and stop,"]
    #[doc = "  unless the callbacks return a fatal error or the read callback returns"]
    #[doc = "  \\c FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM."]
    #[doc = ""]
    #[doc = "  The decoding flow is the same as what occurs when"]
    #[doc = "  FLAC__stream_decoder_process_single() is called to process an audio"]
    #[doc = "  frame, except that this function does not decode the parsed data into"]
    #[doc = "  PCM or call the write callback.  The integrity of the frame is still"]
    #[doc = "  checked the same way as in the other process functions."]
    #[doc = ""]
    #[doc = "  This function will return once one whole frame is skipped, in the"]
    #[doc = "  same way that FLAC__stream_decoder_process_single() will return once"]
    #[doc = "  one whole frame is decoded."]
    #[doc = ""]
    #[doc = "  This function can be used in more quickly determining FLAC frame"]
    #[doc = "  boundaries when decoding of the actual data is not needed, for"]
    #[doc = "  example when an application is separating a FLAC stream into frames"]
    #[doc = "  for editing or storing in a container.  To do this, the application"]
    #[doc = "  can use FLAC__stream_decoder_skip_single_frame() to quickly advance"]
    #[doc = "  to the next frame, then use"]
    #[doc = "  FLAC__stream_decoder_get_decode_position() to find the new frame"]
    #[doc = "  boundary."]
    #[doc = ""]
    #[doc = "  This function should only be called when the stream has advanced"]
    #[doc = "  past all the metadata, otherwise it will return \\c false."]
    #[doc = ""]
    #[doc = " \\param  decoder  An initialized decoder instance not in a metadata"]
    #[doc = "                  state."]
    #[doc = " \\assert"]
    #[doc = "    \\code decoder != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if any fatal read, write, or memory allocation error"]
    #[doc = "    occurred (meaning decoding must stop), or if the decoder"]
    #[doc = "    is in the FLAC__STREAM_DECODER_SEARCH_FOR_METADATA or"]
    #[doc = "    FLAC__STREAM_DECODER_READ_METADATA state, else \\c true; for more"]
    #[doc = "    information about the decoder, check the decoder state with"]
    #[doc = "    FLAC__stream_decoder_get_state()."]
    pub fn FLAC__stream_decoder_skip_single_frame(decoder: *mut FLAC__StreamDecoder) -> FLAC__bool;
}
extern "C" {
    #[doc = " Flush the input and seek to an absolute sample."]
    #[doc = "  Decoding will resume at the given sample.  Note that because of"]
    #[doc = "  this, the next write callback may contain a partial block.  The"]
    #[doc = "  client must support seeking the input or this function will fail"]
    #[doc = "  and return \\c false.  Furthermore, if the decoder state is"]
    #[doc = "  \\c FLAC__STREAM_DECODER_SEEK_ERROR, then the decoder must be flushed"]
    #[doc = "  with FLAC__stream_decoder_flush() or reset with"]
    #[doc = "  FLAC__stream_decoder_reset() before decoding can continue."]
    #[doc = ""]
    #[doc = " \\param  decoder  A decoder instance."]
    #[doc = " \\param  sample   The target sample number to seek to."]
    #[doc = " \\assert"]
    #[doc = "    \\code decoder != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c true if successful, else \\c false."]
    pub fn FLAC__stream_decoder_seek_absolute(
        decoder: *mut FLAC__StreamDecoder,
        sample: FLAC__uint64,
    ) -> FLAC__bool;
}
pub const FLAC__StreamEncoderState_FLAC__STREAM_ENCODER_OK: FLAC__StreamEncoderState = 0;
pub const FLAC__StreamEncoderState_FLAC__STREAM_ENCODER_UNINITIALIZED: FLAC__StreamEncoderState = 1;
pub const FLAC__StreamEncoderState_FLAC__STREAM_ENCODER_OGG_ERROR: FLAC__StreamEncoderState = 2;
pub const FLAC__StreamEncoderState_FLAC__STREAM_ENCODER_VERIFY_DECODER_ERROR:
    FLAC__StreamEncoderState = 3;
pub const FLAC__StreamEncoderState_FLAC__STREAM_ENCODER_VERIFY_MISMATCH_IN_AUDIO_DATA:
    FLAC__StreamEncoderState = 4;
pub const FLAC__StreamEncoderState_FLAC__STREAM_ENCODER_CLIENT_ERROR: FLAC__StreamEncoderState = 5;
pub const FLAC__StreamEncoderState_FLAC__STREAM_ENCODER_IO_ERROR: FLAC__StreamEncoderState = 6;
pub const FLAC__StreamEncoderState_FLAC__STREAM_ENCODER_FRAMING_ERROR: FLAC__StreamEncoderState = 7;
pub const FLAC__StreamEncoderState_FLAC__STREAM_ENCODER_MEMORY_ALLOCATION_ERROR:
    FLAC__StreamEncoderState = 8;
#[doc = " State values for a FLAC__StreamEncoder."]
#[doc = ""]
#[doc = " The encoder\'s state can be obtained by calling FLAC__stream_encoder_get_state()."]
#[doc = ""]
#[doc = " If the encoder gets into any other state besides \\c FLAC__STREAM_ENCODER_OK"]
#[doc = " or \\c FLAC__STREAM_ENCODER_UNINITIALIZED, it becomes invalid for encoding and"]
#[doc = " must be deleted with FLAC__stream_encoder_delete()."]
pub type FLAC__StreamEncoderState = u32;
extern "C" {
    #[link_name = "\u{1}FLAC__StreamEncoderStateString"]
    pub static mut FLAC__StreamEncoderStateString: [*const ::std::os::raw::c_char; 0usize];
}
pub const FLAC__StreamEncoderInitStatus_FLAC__STREAM_ENCODER_INIT_STATUS_OK:
    FLAC__StreamEncoderInitStatus = 0;
pub const FLAC__StreamEncoderInitStatus_FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR:
    FLAC__StreamEncoderInitStatus = 1;
pub const FLAC__StreamEncoderInitStatus_FLAC__STREAM_ENCODER_INIT_STATUS_UNSUPPORTED_CONTAINER:
    FLAC__StreamEncoderInitStatus = 2;
pub const FLAC__StreamEncoderInitStatus_FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_CALLBACKS:
    FLAC__StreamEncoderInitStatus = 3;
pub const FLAC__StreamEncoderInitStatus_FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_NUMBER_OF_CHANNELS : FLAC__StreamEncoderInitStatus = 4 ;
pub const FLAC__StreamEncoderInitStatus_FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_BITS_PER_SAMPLE:
    FLAC__StreamEncoderInitStatus = 5;
pub const FLAC__StreamEncoderInitStatus_FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_SAMPLE_RATE:
    FLAC__StreamEncoderInitStatus = 6;
pub const FLAC__StreamEncoderInitStatus_FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_BLOCK_SIZE:
    FLAC__StreamEncoderInitStatus = 7;
pub const FLAC__StreamEncoderInitStatus_FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_MAX_LPC_ORDER:
    FLAC__StreamEncoderInitStatus = 8;
pub const FLAC__StreamEncoderInitStatus_FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_QLP_COEFF_PRECISION : FLAC__StreamEncoderInitStatus = 9 ;
pub const FLAC__StreamEncoderInitStatus_FLAC__STREAM_ENCODER_INIT_STATUS_BLOCK_SIZE_TOO_SMALL_FOR_LPC_ORDER : FLAC__StreamEncoderInitStatus = 10 ;
pub const FLAC__StreamEncoderInitStatus_FLAC__STREAM_ENCODER_INIT_STATUS_NOT_STREAMABLE:
    FLAC__StreamEncoderInitStatus = 11;
pub const FLAC__StreamEncoderInitStatus_FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_METADATA:
    FLAC__StreamEncoderInitStatus = 12;
pub const FLAC__StreamEncoderInitStatus_FLAC__STREAM_ENCODER_INIT_STATUS_ALREADY_INITIALIZED:
    FLAC__StreamEncoderInitStatus = 13;
#[doc = " Possible return values for the FLAC__stream_encoder_init_*() functions."]
pub type FLAC__StreamEncoderInitStatus = u32;
extern "C" {
    #[link_name = "\u{1}FLAC__StreamEncoderInitStatusString"]
    pub static mut FLAC__StreamEncoderInitStatusString: [*const ::std::os::raw::c_char; 0usize];
}
pub const FLAC__StreamEncoderReadStatus_FLAC__STREAM_ENCODER_READ_STATUS_CONTINUE:
    FLAC__StreamEncoderReadStatus = 0;
pub const FLAC__StreamEncoderReadStatus_FLAC__STREAM_ENCODER_READ_STATUS_END_OF_STREAM:
    FLAC__StreamEncoderReadStatus = 1;
pub const FLAC__StreamEncoderReadStatus_FLAC__STREAM_ENCODER_READ_STATUS_ABORT:
    FLAC__StreamEncoderReadStatus = 2;
pub const FLAC__StreamEncoderReadStatus_FLAC__STREAM_ENCODER_READ_STATUS_UNSUPPORTED:
    FLAC__StreamEncoderReadStatus = 3;
#[doc = " Return values for the FLAC__StreamEncoder read callback."]
pub type FLAC__StreamEncoderReadStatus = u32;
extern "C" {
    #[link_name = "\u{1}FLAC__StreamEncoderReadStatusString"]
    pub static mut FLAC__StreamEncoderReadStatusString: [*const ::std::os::raw::c_char; 0usize];
}
pub const FLAC__StreamEncoderWriteStatus_FLAC__STREAM_ENCODER_WRITE_STATUS_OK:
    FLAC__StreamEncoderWriteStatus = 0;
pub const FLAC__StreamEncoderWriteStatus_FLAC__STREAM_ENCODER_WRITE_STATUS_FATAL_ERROR:
    FLAC__StreamEncoderWriteStatus = 1;
#[doc = " Return values for the FLAC__StreamEncoder write callback."]
pub type FLAC__StreamEncoderWriteStatus = u32;
extern "C" {
    #[link_name = "\u{1}FLAC__StreamEncoderWriteStatusString"]
    pub static mut FLAC__StreamEncoderWriteStatusString: [*const ::std::os::raw::c_char; 0usize];
}
pub const FLAC__StreamEncoderSeekStatus_FLAC__STREAM_ENCODER_SEEK_STATUS_OK:
    FLAC__StreamEncoderSeekStatus = 0;
pub const FLAC__StreamEncoderSeekStatus_FLAC__STREAM_ENCODER_SEEK_STATUS_ERROR:
    FLAC__StreamEncoderSeekStatus = 1;
pub const FLAC__StreamEncoderSeekStatus_FLAC__STREAM_ENCODER_SEEK_STATUS_UNSUPPORTED:
    FLAC__StreamEncoderSeekStatus = 2;
#[doc = " Return values for the FLAC__StreamEncoder seek callback."]
pub type FLAC__StreamEncoderSeekStatus = u32;
extern "C" {
    #[link_name = "\u{1}FLAC__StreamEncoderSeekStatusString"]
    pub static mut FLAC__StreamEncoderSeekStatusString: [*const ::std::os::raw::c_char; 0usize];
}
pub const FLAC__StreamEncoderTellStatus_FLAC__STREAM_ENCODER_TELL_STATUS_OK:
    FLAC__StreamEncoderTellStatus = 0;
pub const FLAC__StreamEncoderTellStatus_FLAC__STREAM_ENCODER_TELL_STATUS_ERROR:
    FLAC__StreamEncoderTellStatus = 1;
pub const FLAC__StreamEncoderTellStatus_FLAC__STREAM_ENCODER_TELL_STATUS_UNSUPPORTED:
    FLAC__StreamEncoderTellStatus = 2;
#[doc = " Return values for the FLAC__StreamEncoder tell callback."]
pub type FLAC__StreamEncoderTellStatus = u32;
extern "C" {
    #[link_name = "\u{1}FLAC__StreamEncoderTellStatusString"]
    pub static mut FLAC__StreamEncoderTellStatusString: [*const ::std::os::raw::c_char; 0usize];
}
#[doc = " class FLAC__StreamEncoder"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__StreamEncoderProtected {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__StreamEncoderPrivate {
    _unused: [u8; 0],
}
#[doc = " The opaque structure definition for the stream encoder type."]
#[doc = "  See the \\link flac_stream_encoder stream encoder module \\endlink"]
#[doc = "  for a detailed description."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__StreamEncoder {
    pub protected_: *mut FLAC__StreamEncoderProtected,
    pub private_: *mut FLAC__StreamEncoderPrivate,
}
#[doc = " Signature for the read callback."]
#[doc = ""]
#[doc = "  A function pointer matching this signature must be passed to"]
#[doc = "  FLAC__stream_encoder_init_ogg_stream() if seeking is supported."]
#[doc = "  The supplied function will be called when the encoder needs to read back"]
#[doc = "  encoded data.  This happens during the metadata callback, when the encoder"]
#[doc = "  has to read, modify, and rewrite the metadata (e.g. seekpoints) gathered"]
#[doc = "  while encoding.  The address of the buffer to be filled is supplied, along"]
#[doc = "  with the number of bytes the buffer can hold.  The callback may choose to"]
#[doc = "  supply less data and modify the byte count but must be careful not to"]
#[doc = "  overflow the buffer.  The callback then returns a status code chosen from"]
#[doc = "  FLAC__StreamEncoderReadStatus."]
#[doc = ""]
#[doc = " Here is an example of a read callback for stdio streams:"]
#[doc = " \\code"]
#[doc = " FLAC__StreamEncoderReadStatus read_cb(const FLAC__StreamEncoder *encoder, FLAC__byte buffer[], size_t *bytes, void *client_data)"]
#[doc = " {"]
#[doc = "   FILE *file = ((MyClientData*)client_data)->file;"]
#[doc = "   if(*bytes > 0) {"]
#[doc = "     *bytes = fread(buffer, sizeof(FLAC__byte), *bytes, file);"]
#[doc = "     if(ferror(file))"]
#[doc = "       return FLAC__STREAM_ENCODER_READ_STATUS_ABORT;"]
#[doc = "     else if(*bytes == 0)"]
#[doc = "       return FLAC__STREAM_ENCODER_READ_STATUS_END_OF_STREAM;"]
#[doc = "     else"]
#[doc = "       return FLAC__STREAM_ENCODER_READ_STATUS_CONTINUE;"]
#[doc = "   }"]
#[doc = "   else"]
#[doc = "     return FLAC__STREAM_ENCODER_READ_STATUS_ABORT;"]
#[doc = " }"]
#[doc = " \\endcode"]
#[doc = ""]
#[doc = " \\note In general, FLAC__StreamEncoder functions which change the"]
#[doc = " state should not be called on the \\a encoder while in the callback."]
#[doc = ""]
#[doc = " \\param  encoder  The encoder instance calling the callback."]
#[doc = " \\param  buffer   A pointer to a location for the callee to store"]
#[doc = "                  data to be encoded."]
#[doc = " \\param  bytes    A pointer to the size of the buffer.  On entry"]
#[doc = "                  to the callback, it contains the maximum number"]
#[doc = "                  of bytes that may be stored in \\a buffer.  The"]
#[doc = "                  callee must set it to the actual number of bytes"]
#[doc = "                  stored (0 in case of error or end-of-stream) before"]
#[doc = "                  returning."]
#[doc = " \\param  client_data  The callee\'s client data set through"]
#[doc = "                      FLAC__stream_encoder_set_client_data()."]
#[doc = " \\retval FLAC__StreamEncoderReadStatus"]
#[doc = "    The callee\'s return status."]
pub type FLAC__StreamEncoderReadCallback = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *const FLAC__StreamEncoder,
        buffer: *mut FLAC__byte,
        bytes: *mut usize,
        client_data: *mut ::std::os::raw::c_void,
    ) -> FLAC__StreamEncoderReadStatus,
>;
#[doc = " Signature for the write callback."]
#[doc = ""]
#[doc = "  A function pointer matching this signature must be passed to"]
#[doc = "  FLAC__stream_encoder_init*_stream().  The supplied function will be called"]
#[doc = "  by the encoder anytime there is raw encoded data ready to write.  It may"]
#[doc = "  include metadata mixed with encoded audio frames and the data is not"]
#[doc = "  guaranteed to be aligned on frame or metadata block boundaries."]
#[doc = ""]
#[doc = "  The only duty of the callback is to write out the \\a bytes worth of data"]
#[doc = "  in \\a buffer to the current position in the output stream.  The arguments"]
#[doc = "  \\a samples and \\a current_frame are purely informational.  If \\a samples"]
#[doc = "  is greater than \\c 0, then \\a current_frame will hold the current frame"]
#[doc = "  number that is being written; otherwise it indicates that the write"]
#[doc = "  callback is being called to write metadata."]
#[doc = ""]
#[doc = " \\note"]
#[doc = " Unlike when writing to native FLAC, when writing to Ogg FLAC the"]
#[doc = " write callback will be called twice when writing each audio"]
#[doc = " frame; once for the page header, and once for the page body."]
#[doc = " When writing the page header, the \\a samples argument to the"]
#[doc = " write callback will be \\c 0."]
#[doc = ""]
#[doc = " \\note In general, FLAC__StreamEncoder functions which change the"]
#[doc = " state should not be called on the \\a encoder while in the callback."]
#[doc = ""]
#[doc = " \\param  encoder  The encoder instance calling the callback."]
#[doc = " \\param  buffer   An array of encoded data of length \\a bytes."]
#[doc = " \\param  bytes    The byte length of \\a buffer."]
#[doc = " \\param  samples  The number of samples encoded by \\a buffer."]
#[doc = "                  \\c 0 has a special meaning; see above."]
#[doc = " \\param  current_frame  The number of the current frame being encoded."]
#[doc = " \\param  client_data  The callee\'s client data set through"]
#[doc = "                      FLAC__stream_encoder_init_*()."]
#[doc = " \\retval FLAC__StreamEncoderWriteStatus"]
#[doc = "    The callee\'s return status."]
pub type FLAC__StreamEncoderWriteCallback = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *const FLAC__StreamEncoder,
        buffer: *const FLAC__byte,
        bytes: usize,
        samples: ::std::os::raw::c_uint,
        current_frame: ::std::os::raw::c_uint,
        client_data: *mut ::std::os::raw::c_void,
    ) -> FLAC__StreamEncoderWriteStatus,
>;
#[doc = " Signature for the seek callback."]
#[doc = ""]
#[doc = "  A function pointer matching this signature may be passed to"]
#[doc = "  FLAC__stream_encoder_init*_stream().  The supplied function will be called"]
#[doc = "  when the encoder needs to seek the output stream.  The encoder will pass"]
#[doc = "  the absolute byte offset to seek to, 0 meaning the beginning of the stream."]
#[doc = ""]
#[doc = " Here is an example of a seek callback for stdio streams:"]
#[doc = " \\code"]
#[doc = " FLAC__StreamEncoderSeekStatus seek_cb(const FLAC__StreamEncoder *encoder, FLAC__uint64 absolute_byte_offset, void *client_data)"]
#[doc = " {"]
#[doc = "   FILE *file = ((MyClientData*)client_data)->file;"]
#[doc = "   if(file == stdin)"]
#[doc = "     return FLAC__STREAM_ENCODER_SEEK_STATUS_UNSUPPORTED;"]
#[doc = "   else if(fseeko(file, (off_t)absolute_byte_offset, SEEK_SET) < 0)"]
#[doc = "     return FLAC__STREAM_ENCODER_SEEK_STATUS_ERROR;"]
#[doc = "   else"]
#[doc = "     return FLAC__STREAM_ENCODER_SEEK_STATUS_OK;"]
#[doc = " }"]
#[doc = " \\endcode"]
#[doc = ""]
#[doc = " \\note In general, FLAC__StreamEncoder functions which change the"]
#[doc = " state should not be called on the \\a encoder while in the callback."]
#[doc = ""]
#[doc = " \\param  encoder  The encoder instance calling the callback."]
#[doc = " \\param  absolute_byte_offset  The offset from the beginning of the stream"]
#[doc = "                               to seek to."]
#[doc = " \\param  client_data  The callee\'s client data set through"]
#[doc = "                      FLAC__stream_encoder_init_*()."]
#[doc = " \\retval FLAC__StreamEncoderSeekStatus"]
#[doc = "    The callee\'s return status."]
pub type FLAC__StreamEncoderSeekCallback = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *const FLAC__StreamEncoder,
        absolute_byte_offset: FLAC__uint64,
        client_data: *mut ::std::os::raw::c_void,
    ) -> FLAC__StreamEncoderSeekStatus,
>;
#[doc = " Signature for the tell callback."]
#[doc = ""]
#[doc = "  A function pointer matching this signature may be passed to"]
#[doc = "  FLAC__stream_encoder_init*_stream().  The supplied function will be called"]
#[doc = "  when the encoder needs to know the current position of the output stream."]
#[doc = ""]
#[doc = " \\warning"]
#[doc = " The callback must return the true current byte offset of the output to"]
#[doc = " which the encoder is writing.  If you are buffering the output, make"]
#[doc = " sure and take this into account.  If you are writing directly to a"]
#[doc = " FILE* from your write callback, ftell() is sufficient.  If you are"]
#[doc = " writing directly to a file descriptor from your write callback, you"]
#[doc = " can use lseek(fd, SEEK_CUR, 0).  The encoder may later seek back to"]
#[doc = " these points to rewrite metadata after encoding."]
#[doc = ""]
#[doc = " Here is an example of a tell callback for stdio streams:"]
#[doc = " \\code"]
#[doc = " FLAC__StreamEncoderTellStatus tell_cb(const FLAC__StreamEncoder *encoder, FLAC__uint64 *absolute_byte_offset, void *client_data)"]
#[doc = " {"]
#[doc = "   FILE *file = ((MyClientData*)client_data)->file;"]
#[doc = "   off_t pos;"]
#[doc = "   if(file == stdin)"]
#[doc = "     return FLAC__STREAM_ENCODER_TELL_STATUS_UNSUPPORTED;"]
#[doc = "   else if((pos = ftello(file)) < 0)"]
#[doc = "     return FLAC__STREAM_ENCODER_TELL_STATUS_ERROR;"]
#[doc = "   else {"]
#[doc = "     *absolute_byte_offset = (FLAC__uint64)pos;"]
#[doc = "     return FLAC__STREAM_ENCODER_TELL_STATUS_OK;"]
#[doc = "   }"]
#[doc = " }"]
#[doc = " \\endcode"]
#[doc = ""]
#[doc = " \\note In general, FLAC__StreamEncoder functions which change the"]
#[doc = " state should not be called on the \\a encoder while in the callback."]
#[doc = ""]
#[doc = " \\param  encoder  The encoder instance calling the callback."]
#[doc = " \\param  absolute_byte_offset  The address at which to store the current"]
#[doc = "                               position of the output."]
#[doc = " \\param  client_data  The callee\'s client data set through"]
#[doc = "                      FLAC__stream_encoder_init_*()."]
#[doc = " \\retval FLAC__StreamEncoderTellStatus"]
#[doc = "    The callee\'s return status."]
pub type FLAC__StreamEncoderTellCallback = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *const FLAC__StreamEncoder,
        absolute_byte_offset: *mut FLAC__uint64,
        client_data: *mut ::std::os::raw::c_void,
    ) -> FLAC__StreamEncoderTellStatus,
>;
#[doc = " Signature for the metadata callback."]
#[doc = ""]
#[doc = "  A function pointer matching this signature may be passed to"]
#[doc = "  FLAC__stream_encoder_init*_stream().  The supplied function will be called"]
#[doc = "  once at the end of encoding with the populated STREAMINFO structure.  This"]
#[doc = "  is so the client can seek back to the beginning of the file and write the"]
#[doc = "  STREAMINFO block with the correct statistics after encoding (like"]
#[doc = "  minimum/maximum frame size and total samples)."]
#[doc = ""]
#[doc = " \\note In general, FLAC__StreamEncoder functions which change the"]
#[doc = " state should not be called on the \\a encoder while in the callback."]
#[doc = ""]
#[doc = " \\param  encoder      The encoder instance calling the callback."]
#[doc = " \\param  metadata     The final populated STREAMINFO block."]
#[doc = " \\param  client_data  The callee\'s client data set through"]
#[doc = "                      FLAC__stream_encoder_init_*()."]
pub type FLAC__StreamEncoderMetadataCallback = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *const FLAC__StreamEncoder,
        metadata: *const FLAC__StreamMetadata,
        client_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Signature for the progress callback."]
#[doc = ""]
#[doc = "  A function pointer matching this signature may be passed to"]
#[doc = "  FLAC__stream_encoder_init*_file() or FLAC__stream_encoder_init*_FILE()."]
#[doc = "  The supplied function will be called when the encoder has finished"]
#[doc = "  writing a frame.  The \\c total_frames_estimate argument to the"]
#[doc = "  callback will be based on the value from"]
#[doc = "  FLAC__stream_encoder_set_total_samples_estimate()."]
#[doc = ""]
#[doc = " \\note In general, FLAC__StreamEncoder functions which change the"]
#[doc = " state should not be called on the \\a encoder while in the callback."]
#[doc = ""]
#[doc = " \\param  encoder          The encoder instance calling the callback."]
#[doc = " \\param  bytes_written    Bytes written so far."]
#[doc = " \\param  samples_written  Samples written so far."]
#[doc = " \\param  frames_written   Frames written so far."]
#[doc = " \\param  total_frames_estimate  The estimate of the total number of"]
#[doc = "                                frames to be written."]
#[doc = " \\param  client_data      The callee\'s client data set through"]
#[doc = "                          FLAC__stream_encoder_init_*()."]
pub type FLAC__StreamEncoderProgressCallback = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *const FLAC__StreamEncoder,
        bytes_written: FLAC__uint64,
        samples_written: FLAC__uint64,
        frames_written: ::std::os::raw::c_uint,
        total_frames_estimate: ::std::os::raw::c_uint,
        client_data: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " Create a new stream encoder instance.  The instance is created with"]
    #[doc = "  default settings; see the individual FLAC__stream_encoder_set_*()"]
    #[doc = "  functions for each setting\'s default."]
    #[doc = ""]
    #[doc = " \\retval FLAC__StreamEncoder*"]
    #[doc = "    \\c NULL if there was an error allocating memory, else the new instance."]
    pub fn FLAC__stream_encoder_new() -> *mut FLAC__StreamEncoder;
}
extern "C" {
    #[doc = " Free an encoder instance.  Deletes the object pointed to by \\a encoder."]
    #[doc = ""]
    #[doc = " \\param encoder  A pointer to an existing encoder."]
    #[doc = " \\assert"]
    #[doc = "    \\code encoder != NULL \\endcode"]
    pub fn FLAC__stream_encoder_delete(encoder: *mut FLAC__StreamEncoder);
}
extern "C" {
    #[doc = " Set the serial number for the FLAC stream to use in the Ogg container."]
    #[doc = ""]
    #[doc = " \\note"]
    #[doc = " This does not need to be set for native FLAC encoding."]
    #[doc = ""]
    #[doc = " \\note"]
    #[doc = " It is recommended to set a serial number explicitly as the default of \'0\'"]
    #[doc = " may collide with other streams."]
    #[doc = ""]
    #[doc = " \\default \\c 0"]
    #[doc = " \\param  encoder        An encoder instance to set."]
    #[doc = " \\param  serial_number  See above."]
    #[doc = " \\assert"]
    #[doc = "    \\code encoder != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if the encoder is already initialized, else \\c true."]
    pub fn FLAC__stream_encoder_set_ogg_serial_number(
        encoder: *mut FLAC__StreamEncoder,
        serial_number: ::std::os::raw::c_long,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Set the \"verify\" flag.  If \\c true, the encoder will verify it\'s own"]
    #[doc = "  encoded output by feeding it through an internal decoder and comparing"]
    #[doc = "  the original signal against the decoded signal.  If a mismatch occurs,"]
    #[doc = "  the process call will return \\c false.  Note that this will slow the"]
    #[doc = "  encoding process by the extra time required for decoding and comparison."]
    #[doc = ""]
    #[doc = " \\default \\c false"]
    #[doc = " \\param  encoder  An encoder instance to set."]
    #[doc = " \\param  value    Flag value (see above)."]
    #[doc = " \\assert"]
    #[doc = "    \\code encoder != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if the encoder is already initialized, else \\c true."]
    pub fn FLAC__stream_encoder_set_verify(
        encoder: *mut FLAC__StreamEncoder,
        value: FLAC__bool,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Set the <A HREF=\"../format.html#subset\">Subset</A> flag.  If \\c true,"]
    #[doc = "  the encoder will comply with the Subset and will check the"]
    #[doc = "  settings during FLAC__stream_encoder_init_*() to see if all settings"]
    #[doc = "  comply.  If \\c false, the settings may take advantage of the full"]
    #[doc = "  range that the format allows."]
    #[doc = ""]
    #[doc = "  Make sure you know what it entails before setting this to \\c false."]
    #[doc = ""]
    #[doc = " \\default \\c true"]
    #[doc = " \\param  encoder  An encoder instance to set."]
    #[doc = " \\param  value    Flag value (see above)."]
    #[doc = " \\assert"]
    #[doc = "    \\code encoder != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if the encoder is already initialized, else \\c true."]
    pub fn FLAC__stream_encoder_set_streamable_subset(
        encoder: *mut FLAC__StreamEncoder,
        value: FLAC__bool,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Set the number of channels to be encoded."]
    #[doc = ""]
    #[doc = " \\default \\c 2"]
    #[doc = " \\param  encoder  An encoder instance to set."]
    #[doc = " \\param  value    See above."]
    #[doc = " \\assert"]
    #[doc = "    \\code encoder != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if the encoder is already initialized, else \\c true."]
    pub fn FLAC__stream_encoder_set_channels(
        encoder: *mut FLAC__StreamEncoder,
        value: ::std::os::raw::c_uint,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Set the sample resolution of the input to be encoded."]
    #[doc = ""]
    #[doc = " \\warning"]
    #[doc = " Do not feed the encoder data that is wider than the value you"]
    #[doc = " set here or you will generate an invalid stream."]
    #[doc = ""]
    #[doc = " \\default \\c 16"]
    #[doc = " \\param  encoder  An encoder instance to set."]
    #[doc = " \\param  value    See above."]
    #[doc = " \\assert"]
    #[doc = "    \\code encoder != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if the encoder is already initialized, else \\c true."]
    pub fn FLAC__stream_encoder_set_bits_per_sample(
        encoder: *mut FLAC__StreamEncoder,
        value: ::std::os::raw::c_uint,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Set the sample rate (in Hz) of the input to be encoded."]
    #[doc = ""]
    #[doc = " \\default \\c 44100"]
    #[doc = " \\param  encoder  An encoder instance to set."]
    #[doc = " \\param  value    See above."]
    #[doc = " \\assert"]
    #[doc = "    \\code encoder != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if the encoder is already initialized, else \\c true."]
    pub fn FLAC__stream_encoder_set_sample_rate(
        encoder: *mut FLAC__StreamEncoder,
        value: ::std::os::raw::c_uint,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Set the compression level"]
    #[doc = ""]
    #[doc = " The compression level is roughly proportional to the amount of effort"]
    #[doc = " the encoder expends to compress the file.  A higher level usually"]
    #[doc = " means more computation but higher compression.  The default level is"]
    #[doc = " suitable for most applications."]
    #[doc = ""]
    #[doc = " Currently the levels range from \\c 0 (fastest, least compression) to"]
    #[doc = " \\c 8 (slowest, most compression).  A value larger than \\c 8 will be"]
    #[doc = " treated as \\c 8."]
    #[doc = ""]
    #[doc = " This function automatically calls the following other \\c _set_"]
    #[doc = " functions with appropriate values, so the client does not need to"]
    #[doc = " unless it specifically wants to override them:"]
    #[doc = " - FLAC__stream_encoder_set_do_mid_side_stereo()"]
    #[doc = " - FLAC__stream_encoder_set_loose_mid_side_stereo()"]
    #[doc = " - FLAC__stream_encoder_set_apodization()"]
    #[doc = " - FLAC__stream_encoder_set_max_lpc_order()"]
    #[doc = " - FLAC__stream_encoder_set_qlp_coeff_precision()"]
    #[doc = " - FLAC__stream_encoder_set_do_qlp_coeff_prec_search()"]
    #[doc = " - FLAC__stream_encoder_set_do_escape_coding()"]
    #[doc = " - FLAC__stream_encoder_set_do_exhaustive_model_search()"]
    #[doc = " - FLAC__stream_encoder_set_min_residual_partition_order()"]
    #[doc = " - FLAC__stream_encoder_set_max_residual_partition_order()"]
    #[doc = " - FLAC__stream_encoder_set_rice_parameter_search_dist()"]
    #[doc = ""]
    #[doc = " The actual values set for each level are:"]
    #[doc = " <table>"]
    #[doc = " <tr>"]
    #[doc = "  <td><b>level</b></td>"]
    #[doc = "  <td>do mid-side stereo</td>"]
    #[doc = "  <td>loose mid-side stereo</td>"]
    #[doc = "  <td>apodization</td>"]
    #[doc = "  <td>max lpc order</td>"]
    #[doc = "  <td>qlp coeff precision</td>"]
    #[doc = "  <td>qlp coeff prec search</td>"]
    #[doc = "  <td>escape coding</td>"]
    #[doc = "  <td>exhaustive model search</td>"]
    #[doc = "  <td>min residual partition order</td>"]
    #[doc = "  <td>max residual partition order</td>"]
    #[doc = "  <td>rice parameter search dist</td>"]
    #[doc = " </tr>"]
    #[doc = " <tr>  <td><b>0</b></td> <td>false</td> <td>false</td> <td>tukey(0.5)<td>                                     <td>0</td>  <td>0</td> <td>false</td> <td>false</td> <td>false</td> <td>0</td> <td>3</td> <td>0</td> </tr>"]
    #[doc = " <tr>  <td><b>1</b></td> <td>true</td>  <td>true</td>  <td>tukey(0.5)<td>                                     <td>0</td>  <td>0</td> <td>false</td> <td>false</td> <td>false</td> <td>0</td> <td>3</td> <td>0</td> </tr>"]
    #[doc = " <tr>  <td><b>2</b></td> <td>true</td>  <td>false</td> <td>tukey(0.5)<td>                                     <td>0</td>  <td>0</td> <td>false</td> <td>false</td> <td>false</td> <td>0</td> <td>3</td> <td>0</td> </tr>"]
    #[doc = " <tr>  <td><b>3</b></td> <td>false</td> <td>false</td> <td>tukey(0.5)<td>                                     <td>6</td>  <td>0</td> <td>false</td> <td>false</td> <td>false</td> <td>0</td> <td>4</td> <td>0</td> </tr>"]
    #[doc = " <tr>  <td><b>4</b></td> <td>true</td>  <td>true</td>  <td>tukey(0.5)<td>                                     <td>8</td>  <td>0</td> <td>false</td> <td>false</td> <td>false</td> <td>0</td> <td>4</td> <td>0</td> </tr>"]
    #[doc = " <tr>  <td><b>5</b></td> <td>true</td>  <td>false</td> <td>tukey(0.5)<td>                                     <td>8</td>  <td>0</td> <td>false</td> <td>false</td> <td>false</td> <td>0</td> <td>5</td> <td>0</td> </tr>"]
    #[doc = " <tr>  <td><b>6</b></td> <td>true</td>  <td>false</td> <td>tukey(0.5);partial_tukey(2)<td>                    <td>8</td>  <td>0</td> <td>false</td> <td>false</td> <td>false</td> <td>0</td> <td>6</td> <td>0</td> </tr>"]
    #[doc = " <tr>  <td><b>7</b></td> <td>true</td>  <td>false</td> <td>tukey(0.5);partial_tukey(2)<td>                    <td>12</td> <td>0</td> <td>false</td> <td>false</td> <td>false</td> <td>0</td> <td>6</td> <td>0</td> </tr>"]
    #[doc = " <tr>  <td><b>8</b></td> <td>true</td>  <td>false</td> <td>tukey(0.5);partial_tukey(2);punchout_tukey(3)</td> <td>12</td> <td>0</td> <td>false</td> <td>false</td> <td>false</td> <td>0</td> <td>6</td> <td>0</td> </tr>"]
    #[doc = " </table>"]
    #[doc = ""]
    #[doc = " \\default \\c 5"]
    #[doc = " \\param  encoder  An encoder instance to set."]
    #[doc = " \\param  value    See above."]
    #[doc = " \\assert"]
    #[doc = "    \\code encoder != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if the encoder is already initialized, else \\c true."]
    pub fn FLAC__stream_encoder_set_compression_level(
        encoder: *mut FLAC__StreamEncoder,
        value: ::std::os::raw::c_uint,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Set the blocksize to use while encoding."]
    #[doc = ""]
    #[doc = " The number of samples to use per frame.  Use \\c 0 to let the encoder"]
    #[doc = " estimate a blocksize; this is usually best."]
    #[doc = ""]
    #[doc = " \\default \\c 0"]
    #[doc = " \\param  encoder  An encoder instance to set."]
    #[doc = " \\param  value    See above."]
    #[doc = " \\assert"]
    #[doc = "    \\code encoder != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if the encoder is already initialized, else \\c true."]
    pub fn FLAC__stream_encoder_set_blocksize(
        encoder: *mut FLAC__StreamEncoder,
        value: ::std::os::raw::c_uint,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Set to \\c true to enable mid-side encoding on stereo input.  The"]
    #[doc = "  number of channels must be 2 for this to have any effect.  Set to"]
    #[doc = "  \\c false to use only independent channel coding."]
    #[doc = ""]
    #[doc = " \\default \\c false"]
    #[doc = " \\param  encoder  An encoder instance to set."]
    #[doc = " \\param  value    Flag value (see above)."]
    #[doc = " \\assert"]
    #[doc = "    \\code encoder != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if the encoder is already initialized, else \\c true."]
    pub fn FLAC__stream_encoder_set_do_mid_side_stereo(
        encoder: *mut FLAC__StreamEncoder,
        value: FLAC__bool,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Set to \\c true to enable adaptive switching between mid-side and"]
    #[doc = "  left-right encoding on stereo input.  Set to \\c false to use"]
    #[doc = "  exhaustive searching.  Setting this to \\c true requires"]
    #[doc = "  FLAC__stream_encoder_set_do_mid_side_stereo() to also be set to"]
    #[doc = "  \\c true in order to have any effect."]
    #[doc = ""]
    #[doc = " \\default \\c false"]
    #[doc = " \\param  encoder  An encoder instance to set."]
    #[doc = " \\param  value    Flag value (see above)."]
    #[doc = " \\assert"]
    #[doc = "    \\code encoder != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if the encoder is already initialized, else \\c true."]
    pub fn FLAC__stream_encoder_set_loose_mid_side_stereo(
        encoder: *mut FLAC__StreamEncoder,
        value: FLAC__bool,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Sets the apodization function(s) the encoder will use when windowing"]
    #[doc = "  audio data for LPC analysis."]
    #[doc = ""]
    #[doc = " The \\a specification is a plain ASCII string which specifies exactly"]
    #[doc = " which functions to use.  There may be more than one (up to 32),"]
    #[doc = " separated by \\c \';\' characters.  Some functions take one or more"]
    #[doc = " comma-separated arguments in parentheses."]
    #[doc = ""]
    #[doc = " The available functions are \\c bartlett, \\c bartlett_hann,"]
    #[doc = " \\c blackman, \\c blackman_harris_4term_92db, \\c connes, \\c flattop,"]
    #[doc = " \\c gauss(STDDEV), \\c hamming, \\c hann, \\c kaiser_bessel, \\c nuttall,"]
    #[doc = " \\c rectangle, \\c triangle, \\c tukey(P), \\c partial_tukey(n[/ov[/P]]),"]
    #[doc = " \\c punchout_tukey(n[/ov[/P]]), \\c welch."]
    #[doc = ""]
    #[doc = " For \\c gauss(STDDEV), STDDEV specifies the standard deviation"]
    #[doc = " (0<STDDEV<=0.5)."]
    #[doc = ""]
    #[doc = " For \\c tukey(P), P specifies the fraction of the window that is"]
    #[doc = " tapered (0<=P<=1).  P=0 corresponds to \\c rectangle and P=1"]
    #[doc = " corresponds to \\c hann."]
    #[doc = ""]
    #[doc = " Specifying \\c partial_tukey or \\c punchout_tukey works a little"]
    #[doc = " different. These do not specify a single apodization function, but"]
    #[doc = " a series of them with some overlap. partial_tukey specifies a series"]
    #[doc = " of small windows (all treated separately) while punchout_tukey"]
    #[doc = " specifies a series of windows that have a hole in them. In this way,"]
    #[doc = " the predictor is constructed with only a part of the block, which"]
    #[doc = " helps in case a block consists of dissimilar parts."]
    #[doc = ""]
    #[doc = " The three parameters that can be specified for the functions are"]
    #[doc = " n, ov and P. n is the number of functions to add, ov is the overlap"]
    #[doc = " of the windows in case of partial_tukey and the overlap in the gaps"]
    #[doc = " in case of punchout_tukey. P is the fraction of the window that is"]
    #[doc = " tapered, like with a regular tukey window. The function can be"]
    #[doc = " specified with only a number, a number and an overlap, or a number"]
    #[doc = " an overlap and a P, for example, partial_tukey(3), partial_tukey(3/0.3)"]
    #[doc = " and partial_tukey(3/0.3/0.5) are all valid. ov should be smaller than 1"]
    #[doc = " and can be negative."]
    #[doc = ""]
    #[doc = " Example specifications are \\c \"blackman\" or"]
    #[doc = " \\c \"hann;triangle;tukey(0.5);tukey(0.25);tukey(0.125)\""]
    #[doc = ""]
    #[doc = " Any function that is specified erroneously is silently dropped.  Up"]
    #[doc = " to 32 functions are kept, the rest are dropped.  If the specification"]
    #[doc = " is empty the encoder defaults to \\c \"tukey(0.5)\"."]
    #[doc = ""]
    #[doc = " When more than one function is specified, then for every subframe the"]
    #[doc = " encoder will try each of them separately and choose the window that"]
    #[doc = " results in the smallest compressed subframe."]
    #[doc = ""]
    #[doc = " Note that each function specified causes the encoder to occupy a"]
    #[doc = " floating point array in which to store the window. Also note that the"]
    #[doc = " values of P, STDDEV and ov are locale-specific, so if the comma"]
    #[doc = " separator specified by the locale is a comma, a comma should be used."]
    #[doc = ""]
    #[doc = " \\default \\c \"tukey(0.5)\""]
    #[doc = " \\param  encoder        An encoder instance to set."]
    #[doc = " \\param  specification  See above."]
    #[doc = " \\assert"]
    #[doc = "    \\code encoder != NULL \\endcode"]
    #[doc = "    \\code specification != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if the encoder is already initialized, else \\c true."]
    pub fn FLAC__stream_encoder_set_apodization(
        encoder: *mut FLAC__StreamEncoder,
        specification: *const ::std::os::raw::c_char,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Set the maximum LPC order, or \\c 0 to use only the fixed predictors."]
    #[doc = ""]
    #[doc = " \\default \\c 0"]
    #[doc = " \\param  encoder  An encoder instance to set."]
    #[doc = " \\param  value    See above."]
    #[doc = " \\assert"]
    #[doc = "    \\code encoder != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if the encoder is already initialized, else \\c true."]
    pub fn FLAC__stream_encoder_set_max_lpc_order(
        encoder: *mut FLAC__StreamEncoder,
        value: ::std::os::raw::c_uint,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Set the precision, in bits, of the quantized linear predictor"]
    #[doc = "  coefficients, or \\c 0 to let the encoder select it based on the"]
    #[doc = "  blocksize."]
    #[doc = ""]
    #[doc = " \\note"]
    #[doc = " In the current implementation, qlp_coeff_precision + bits_per_sample must"]
    #[doc = " be less than 32."]
    #[doc = ""]
    #[doc = " \\default \\c 0"]
    #[doc = " \\param  encoder  An encoder instance to set."]
    #[doc = " \\param  value    See above."]
    #[doc = " \\assert"]
    #[doc = "    \\code encoder != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if the encoder is already initialized, else \\c true."]
    pub fn FLAC__stream_encoder_set_qlp_coeff_precision(
        encoder: *mut FLAC__StreamEncoder,
        value: ::std::os::raw::c_uint,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Set to \\c false to use only the specified quantized linear predictor"]
    #[doc = "  coefficient precision, or \\c true to search neighboring precision"]
    #[doc = "  values and use the best one."]
    #[doc = ""]
    #[doc = " \\default \\c false"]
    #[doc = " \\param  encoder  An encoder instance to set."]
    #[doc = " \\param  value    See above."]
    #[doc = " \\assert"]
    #[doc = "    \\code encoder != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if the encoder is already initialized, else \\c true."]
    pub fn FLAC__stream_encoder_set_do_qlp_coeff_prec_search(
        encoder: *mut FLAC__StreamEncoder,
        value: FLAC__bool,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Deprecated.  Setting this value has no effect."]
    #[doc = ""]
    #[doc = " \\default \\c false"]
    #[doc = " \\param  encoder  An encoder instance to set."]
    #[doc = " \\param  value    See above."]
    #[doc = " \\assert"]
    #[doc = "    \\code encoder != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if the encoder is already initialized, else \\c true."]
    pub fn FLAC__stream_encoder_set_do_escape_coding(
        encoder: *mut FLAC__StreamEncoder,
        value: FLAC__bool,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Set to \\c false to let the encoder estimate the best model order"]
    #[doc = "  based on the residual signal energy, or \\c true to force the"]
    #[doc = "  encoder to evaluate all order models and select the best."]
    #[doc = ""]
    #[doc = " \\default \\c false"]
    #[doc = " \\param  encoder  An encoder instance to set."]
    #[doc = " \\param  value    See above."]
    #[doc = " \\assert"]
    #[doc = "    \\code encoder != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if the encoder is already initialized, else \\c true."]
    pub fn FLAC__stream_encoder_set_do_exhaustive_model_search(
        encoder: *mut FLAC__StreamEncoder,
        value: FLAC__bool,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Set the minimum partition order to search when coding the residual."]
    #[doc = "  This is used in tandem with"]
    #[doc = "  FLAC__stream_encoder_set_max_residual_partition_order()."]
    #[doc = ""]
    #[doc = "  The partition order determines the context size in the residual."]
    #[doc = "  The context size will be approximately <tt>blocksize / (2 ^ order)</tt>."]
    #[doc = ""]
    #[doc = "  Set both min and max values to \\c 0 to force a single context,"]
    #[doc = "  whose Rice parameter is based on the residual signal variance."]
    #[doc = "  Otherwise, set a min and max order, and the encoder will search"]
    #[doc = "  all orders, using the mean of each context for its Rice parameter,"]
    #[doc = "  and use the best."]
    #[doc = ""]
    #[doc = " \\default \\c 0"]
    #[doc = " \\param  encoder  An encoder instance to set."]
    #[doc = " \\param  value    See above."]
    #[doc = " \\assert"]
    #[doc = "    \\code encoder != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if the encoder is already initialized, else \\c true."]
    pub fn FLAC__stream_encoder_set_min_residual_partition_order(
        encoder: *mut FLAC__StreamEncoder,
        value: ::std::os::raw::c_uint,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Set the maximum partition order to search when coding the residual."]
    #[doc = "  This is used in tandem with"]
    #[doc = "  FLAC__stream_encoder_set_min_residual_partition_order()."]
    #[doc = ""]
    #[doc = "  The partition order determines the context size in the residual."]
    #[doc = "  The context size will be approximately <tt>blocksize / (2 ^ order)</tt>."]
    #[doc = ""]
    #[doc = "  Set both min and max values to \\c 0 to force a single context,"]
    #[doc = "  whose Rice parameter is based on the residual signal variance."]
    #[doc = "  Otherwise, set a min and max order, and the encoder will search"]
    #[doc = "  all orders, using the mean of each context for its Rice parameter,"]
    #[doc = "  and use the best."]
    #[doc = ""]
    #[doc = " \\default \\c 0"]
    #[doc = " \\param  encoder  An encoder instance to set."]
    #[doc = " \\param  value    See above."]
    #[doc = " \\assert"]
    #[doc = "    \\code encoder != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if the encoder is already initialized, else \\c true."]
    pub fn FLAC__stream_encoder_set_max_residual_partition_order(
        encoder: *mut FLAC__StreamEncoder,
        value: ::std::os::raw::c_uint,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Deprecated.  Setting this value has no effect."]
    #[doc = ""]
    #[doc = " \\default \\c 0"]
    #[doc = " \\param  encoder  An encoder instance to set."]
    #[doc = " \\param  value    See above."]
    #[doc = " \\assert"]
    #[doc = "    \\code encoder != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if the encoder is already initialized, else \\c true."]
    pub fn FLAC__stream_encoder_set_rice_parameter_search_dist(
        encoder: *mut FLAC__StreamEncoder,
        value: ::std::os::raw::c_uint,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Set an estimate of the total samples that will be encoded."]
    #[doc = "  This is merely an estimate and may be set to \\c 0 if unknown."]
    #[doc = "  This value will be written to the STREAMINFO block before encoding,"]
    #[doc = "  and can remove the need for the caller to rewrite the value later"]
    #[doc = "  if the value is known before encoding."]
    #[doc = ""]
    #[doc = " \\default \\c 0"]
    #[doc = " \\param  encoder  An encoder instance to set."]
    #[doc = " \\param  value    See above."]
    #[doc = " \\assert"]
    #[doc = "    \\code encoder != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if the encoder is already initialized, else \\c true."]
    pub fn FLAC__stream_encoder_set_total_samples_estimate(
        encoder: *mut FLAC__StreamEncoder,
        value: FLAC__uint64,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Set the metadata blocks to be emitted to the stream before encoding."]
    #[doc = "  A value of \\c NULL, \\c 0 implies no metadata; otherwise, supply an"]
    #[doc = "  array of pointers to metadata blocks.  The array is non-const since"]
    #[doc = "  the encoder may need to change the \\a is_last flag inside them, and"]
    #[doc = "  in some cases update seek point offsets.  Otherwise, the encoder will"]
    #[doc = "  not modify or free the blocks.  It is up to the caller to free the"]
    #[doc = "  metadata blocks after encoding finishes."]
    #[doc = ""]
    #[doc = " \\note"]
    #[doc = " The encoder stores only copies of the pointers in the \\a metadata array;"]
    #[doc = " the metadata blocks themselves must survive at least until after"]
    #[doc = " FLAC__stream_encoder_finish() returns.  Do not free the blocks until then."]
    #[doc = ""]
    #[doc = " \\note"]
    #[doc = " The STREAMINFO block is always written and no STREAMINFO block may"]
    #[doc = " occur in the supplied array."]
    #[doc = ""]
    #[doc = " \\note"]
    #[doc = " By default the encoder does not create a SEEKTABLE.  If one is supplied"]
    #[doc = " in the \\a metadata array, but the client has specified that it does not"]
    #[doc = " support seeking, then the SEEKTABLE will be written verbatim.  However"]
    #[doc = " by itself this is not very useful as the client will not know the stream"]
    #[doc = " offsets for the seekpoints ahead of time.  In order to get a proper"]
    #[doc = " seektable the client must support seeking.  See next note."]
    #[doc = ""]
    #[doc = " \\note"]
    #[doc = " SEEKTABLE blocks are handled specially.  Since you will not know"]
    #[doc = " the values for the seek point stream offsets, you should pass in"]
    #[doc = " a SEEKTABLE \'template\', that is, a SEEKTABLE object with the"]
    #[doc = " required sample numbers (or placeholder points), with \\c 0 for the"]
    #[doc = " \\a frame_samples and \\a stream_offset fields for each point.  If the"]
    #[doc = " client has specified that it supports seeking by providing a seek"]
    #[doc = " callback to FLAC__stream_encoder_init_stream() or both seek AND read"]
    #[doc = " callback to FLAC__stream_encoder_init_ogg_stream() (or by using"]
    #[doc = " FLAC__stream_encoder_init*_file() or FLAC__stream_encoder_init*_FILE()),"]
    #[doc = " then while it is encoding the encoder will fill the stream offsets in"]
    #[doc = " for you and when encoding is finished, it will seek back and write the"]
    #[doc = " real values into the SEEKTABLE block in the stream.  There are helper"]
    #[doc = " routines for manipulating seektable template blocks; see metadata.h:"]
    #[doc = " FLAC__metadata_object_seektable_template_*().  If the client does"]
    #[doc = " not support seeking, the SEEKTABLE will have inaccurate offsets which"]
    #[doc = " will slow down or remove the ability to seek in the FLAC stream."]
    #[doc = ""]
    #[doc = " \\note"]
    #[doc = " The encoder instance \\b will modify the first \\c SEEKTABLE block"]
    #[doc = " as it transforms the template to a valid seektable while encoding,"]
    #[doc = " but it is still up to the caller to free all metadata blocks after"]
    #[doc = " encoding."]
    #[doc = ""]
    #[doc = " \\note"]
    #[doc = " A VORBIS_COMMENT block may be supplied.  The vendor string in it"]
    #[doc = " will be ignored.  libFLAC will use it\'s own vendor string. libFLAC"]
    #[doc = " will not modify the passed-in VORBIS_COMMENT\'s vendor string, it"]
    #[doc = " will simply write it\'s own into the stream.  If no VORBIS_COMMENT"]
    #[doc = " block is present in the \\a metadata array, libFLAC will write an"]
    #[doc = " empty one, containing only the vendor string."]
    #[doc = ""]
    #[doc = " \\note The Ogg FLAC mapping requires that the VORBIS_COMMENT block be"]
    #[doc = " the second metadata block of the stream.  The encoder already supplies"]
    #[doc = " the STREAMINFO block automatically.  If \\a metadata does not contain a"]
    #[doc = " VORBIS_COMMENT block, the encoder will supply that too.  Otherwise, if"]
    #[doc = " \\a metadata does contain a VORBIS_COMMENT block and it is not the"]
    #[doc = " first, the init function will reorder \\a metadata by moving the"]
    #[doc = " VORBIS_COMMENT block to the front; the relative ordering of the other"]
    #[doc = " blocks will remain as they were."]
    #[doc = ""]
    #[doc = " \\note The Ogg FLAC mapping limits the number of metadata blocks per"]
    #[doc = " stream to \\c 65535.  If \\a num_blocks exceeds this the function will"]
    #[doc = " return \\c false."]
    #[doc = ""]
    #[doc = " \\default \\c NULL, 0"]
    #[doc = " \\param  encoder     An encoder instance to set."]
    #[doc = " \\param  metadata    See above."]
    #[doc = " \\param  num_blocks  See above."]
    #[doc = " \\assert"]
    #[doc = "    \\code encoder != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if the encoder is already initialized, else \\c true."]
    #[doc = "    \\c false if the encoder is already initialized, or if"]
    #[doc = "    \\a num_blocks > 65535 if encoding to Ogg FLAC, else \\c true."]
    pub fn FLAC__stream_encoder_set_metadata(
        encoder: *mut FLAC__StreamEncoder,
        metadata: *mut *mut FLAC__StreamMetadata,
        num_blocks: ::std::os::raw::c_uint,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Get the current encoder state."]
    #[doc = ""]
    #[doc = " \\param  encoder  An encoder instance to query."]
    #[doc = " \\assert"]
    #[doc = "    \\code encoder != NULL \\endcode"]
    #[doc = " \\retval FLAC__StreamEncoderState"]
    #[doc = "    The current encoder state."]
    pub fn FLAC__stream_encoder_get_state(
        encoder: *const FLAC__StreamEncoder,
    ) -> FLAC__StreamEncoderState;
}
extern "C" {
    #[doc = " Get the state of the verify stream decoder."]
    #[doc = "  Useful when the stream encoder state is"]
    #[doc = "  \\c FLAC__STREAM_ENCODER_VERIFY_DECODER_ERROR."]
    #[doc = ""]
    #[doc = " \\param  encoder  An encoder instance to query."]
    #[doc = " \\assert"]
    #[doc = "    \\code encoder != NULL \\endcode"]
    #[doc = " \\retval FLAC__StreamDecoderState"]
    #[doc = "    The verify stream decoder state."]
    pub fn FLAC__stream_encoder_get_verify_decoder_state(
        encoder: *const FLAC__StreamEncoder,
    ) -> FLAC__StreamDecoderState;
}
extern "C" {
    #[doc = " Get the current encoder state as a C string."]
    #[doc = "  This version automatically resolves"]
    #[doc = "  \\c FLAC__STREAM_ENCODER_VERIFY_DECODER_ERROR by getting the"]
    #[doc = "  verify decoder\'s state."]
    #[doc = ""]
    #[doc = " \\param  encoder  A encoder instance to query."]
    #[doc = " \\assert"]
    #[doc = "    \\code encoder != NULL \\endcode"]
    #[doc = " \\retval const char *"]
    #[doc = "    The encoder state as a C string.  Do not modify the contents."]
    pub fn FLAC__stream_encoder_get_resolved_state_string(
        encoder: *const FLAC__StreamEncoder,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get relevant values about the nature of a verify decoder error."]
    #[doc = "  Useful when the stream encoder state is"]
    #[doc = "  \\c FLAC__STREAM_ENCODER_VERIFY_DECODER_ERROR.  The arguments should"]
    #[doc = "  be addresses in which the stats will be returned, or NULL if value"]
    #[doc = "  is not desired."]
    #[doc = ""]
    #[doc = " \\param  encoder  An encoder instance to query."]
    #[doc = " \\param  absolute_sample  The absolute sample number of the mismatch."]
    #[doc = " \\param  frame_number  The number of the frame in which the mismatch occurred."]
    #[doc = " \\param  channel       The channel in which the mismatch occurred."]
    #[doc = " \\param  sample        The number of the sample (relative to the frame) in"]
    #[doc = "                       which the mismatch occurred."]
    #[doc = " \\param  expected      The expected value for the sample in question."]
    #[doc = " \\param  got           The actual value returned by the decoder."]
    #[doc = " \\assert"]
    #[doc = "    \\code encoder != NULL \\endcode"]
    pub fn FLAC__stream_encoder_get_verify_decoder_error_stats(
        encoder: *const FLAC__StreamEncoder,
        absolute_sample: *mut FLAC__uint64,
        frame_number: *mut ::std::os::raw::c_uint,
        channel: *mut ::std::os::raw::c_uint,
        sample: *mut ::std::os::raw::c_uint,
        expected: *mut FLAC__int32,
        got: *mut FLAC__int32,
    );
}
extern "C" {
    #[doc = " Get the \"verify\" flag."]
    #[doc = ""]
    #[doc = " \\param  encoder  An encoder instance to query."]
    #[doc = " \\assert"]
    #[doc = "    \\code encoder != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    See FLAC__stream_encoder_set_verify()."]
    pub fn FLAC__stream_encoder_get_verify(encoder: *const FLAC__StreamEncoder) -> FLAC__bool;
}
extern "C" {
    #[doc = " Get the <A HREF=\"../format.html#subset>Subset</A> flag."]
    #[doc = ""]
    #[doc = " \\param  encoder  An encoder instance to query."]
    #[doc = " \\assert"]
    #[doc = "    \\code encoder != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    See FLAC__stream_encoder_set_streamable_subset()."]
    pub fn FLAC__stream_encoder_get_streamable_subset(
        encoder: *const FLAC__StreamEncoder,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Get the number of input channels being processed."]
    #[doc = ""]
    #[doc = " \\param  encoder  An encoder instance to query."]
    #[doc = " \\assert"]
    #[doc = "    \\code encoder != NULL \\endcode"]
    #[doc = " \\retval unsigned"]
    #[doc = "    See FLAC__stream_encoder_set_channels()."]
    pub fn FLAC__stream_encoder_get_channels(
        encoder: *const FLAC__StreamEncoder,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Get the input sample resolution setting."]
    #[doc = ""]
    #[doc = " \\param  encoder  An encoder instance to query."]
    #[doc = " \\assert"]
    #[doc = "    \\code encoder != NULL \\endcode"]
    #[doc = " \\retval unsigned"]
    #[doc = "    See FLAC__stream_encoder_set_bits_per_sample()."]
    pub fn FLAC__stream_encoder_get_bits_per_sample(
        encoder: *const FLAC__StreamEncoder,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Get the input sample rate setting."]
    #[doc = ""]
    #[doc = " \\param  encoder  An encoder instance to query."]
    #[doc = " \\assert"]
    #[doc = "    \\code encoder != NULL \\endcode"]
    #[doc = " \\retval unsigned"]
    #[doc = "    See FLAC__stream_encoder_set_sample_rate()."]
    pub fn FLAC__stream_encoder_get_sample_rate(
        encoder: *const FLAC__StreamEncoder,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Get the blocksize setting."]
    #[doc = ""]
    #[doc = " \\param  encoder  An encoder instance to query."]
    #[doc = " \\assert"]
    #[doc = "    \\code encoder != NULL \\endcode"]
    #[doc = " \\retval unsigned"]
    #[doc = "    See FLAC__stream_encoder_set_blocksize()."]
    pub fn FLAC__stream_encoder_get_blocksize(
        encoder: *const FLAC__StreamEncoder,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Get the \"mid/side stereo coding\" flag."]
    #[doc = ""]
    #[doc = " \\param  encoder  An encoder instance to query."]
    #[doc = " \\assert"]
    #[doc = "    \\code encoder != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    See FLAC__stream_encoder_get_do_mid_side_stereo()."]
    pub fn FLAC__stream_encoder_get_do_mid_side_stereo(
        encoder: *const FLAC__StreamEncoder,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Get the \"adaptive mid/side switching\" flag."]
    #[doc = ""]
    #[doc = " \\param  encoder  An encoder instance to query."]
    #[doc = " \\assert"]
    #[doc = "    \\code encoder != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    See FLAC__stream_encoder_set_loose_mid_side_stereo()."]
    pub fn FLAC__stream_encoder_get_loose_mid_side_stereo(
        encoder: *const FLAC__StreamEncoder,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Get the maximum LPC order setting."]
    #[doc = ""]
    #[doc = " \\param  encoder  An encoder instance to query."]
    #[doc = " \\assert"]
    #[doc = "    \\code encoder != NULL \\endcode"]
    #[doc = " \\retval unsigned"]
    #[doc = "    See FLAC__stream_encoder_set_max_lpc_order()."]
    pub fn FLAC__stream_encoder_get_max_lpc_order(
        encoder: *const FLAC__StreamEncoder,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Get the quantized linear predictor coefficient precision setting."]
    #[doc = ""]
    #[doc = " \\param  encoder  An encoder instance to query."]
    #[doc = " \\assert"]
    #[doc = "    \\code encoder != NULL \\endcode"]
    #[doc = " \\retval unsigned"]
    #[doc = "    See FLAC__stream_encoder_set_qlp_coeff_precision()."]
    pub fn FLAC__stream_encoder_get_qlp_coeff_precision(
        encoder: *const FLAC__StreamEncoder,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Get the qlp coefficient precision search flag."]
    #[doc = ""]
    #[doc = " \\param  encoder  An encoder instance to query."]
    #[doc = " \\assert"]
    #[doc = "    \\code encoder != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    See FLAC__stream_encoder_set_do_qlp_coeff_prec_search()."]
    pub fn FLAC__stream_encoder_get_do_qlp_coeff_prec_search(
        encoder: *const FLAC__StreamEncoder,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Get the \"escape coding\" flag."]
    #[doc = ""]
    #[doc = " \\param  encoder  An encoder instance to query."]
    #[doc = " \\assert"]
    #[doc = "    \\code encoder != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    See FLAC__stream_encoder_set_do_escape_coding()."]
    pub fn FLAC__stream_encoder_get_do_escape_coding(
        encoder: *const FLAC__StreamEncoder,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Get the exhaustive model search flag."]
    #[doc = ""]
    #[doc = " \\param  encoder  An encoder instance to query."]
    #[doc = " \\assert"]
    #[doc = "    \\code encoder != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    See FLAC__stream_encoder_set_do_exhaustive_model_search()."]
    pub fn FLAC__stream_encoder_get_do_exhaustive_model_search(
        encoder: *const FLAC__StreamEncoder,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Get the minimum residual partition order setting."]
    #[doc = ""]
    #[doc = " \\param  encoder  An encoder instance to query."]
    #[doc = " \\assert"]
    #[doc = "    \\code encoder != NULL \\endcode"]
    #[doc = " \\retval unsigned"]
    #[doc = "    See FLAC__stream_encoder_set_min_residual_partition_order()."]
    pub fn FLAC__stream_encoder_get_min_residual_partition_order(
        encoder: *const FLAC__StreamEncoder,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Get maximum residual partition order setting."]
    #[doc = ""]
    #[doc = " \\param  encoder  An encoder instance to query."]
    #[doc = " \\assert"]
    #[doc = "    \\code encoder != NULL \\endcode"]
    #[doc = " \\retval unsigned"]
    #[doc = "    See FLAC__stream_encoder_set_max_residual_partition_order()."]
    pub fn FLAC__stream_encoder_get_max_residual_partition_order(
        encoder: *const FLAC__StreamEncoder,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Get the Rice parameter search distance setting."]
    #[doc = ""]
    #[doc = " \\param  encoder  An encoder instance to query."]
    #[doc = " \\assert"]
    #[doc = "    \\code encoder != NULL \\endcode"]
    #[doc = " \\retval unsigned"]
    #[doc = "    See FLAC__stream_encoder_set_rice_parameter_search_dist()."]
    pub fn FLAC__stream_encoder_get_rice_parameter_search_dist(
        encoder: *const FLAC__StreamEncoder,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Get the previously set estimate of the total samples to be encoded."]
    #[doc = "  The encoder merely mimics back the value given to"]
    #[doc = "  FLAC__stream_encoder_set_total_samples_estimate() since it has no"]
    #[doc = "  other way of knowing how many samples the client will encode."]
    #[doc = ""]
    #[doc = " \\param  encoder  An encoder instance to set."]
    #[doc = " \\assert"]
    #[doc = "    \\code encoder != NULL \\endcode"]
    #[doc = " \\retval FLAC__uint64"]
    #[doc = "    See FLAC__stream_encoder_get_total_samples_estimate()."]
    pub fn FLAC__stream_encoder_get_total_samples_estimate(
        encoder: *const FLAC__StreamEncoder,
    ) -> FLAC__uint64;
}
extern "C" {
    #[doc = " Initialize the encoder instance to encode native FLAC streams."]
    #[doc = ""]
    #[doc = "  This flavor of initialization sets up the encoder to encode to a"]
    #[doc = "  native FLAC stream. I/O is performed via callbacks to the client."]
    #[doc = "  For encoding to a plain file via filename or open \\c FILE*,"]
    #[doc = "  FLAC__stream_encoder_init_file() and FLAC__stream_encoder_init_FILE()"]
    #[doc = "  provide a simpler interface."]
    #[doc = ""]
    #[doc = "  This function should be called after FLAC__stream_encoder_new() and"]
    #[doc = "  FLAC__stream_encoder_set_*() but before FLAC__stream_encoder_process()"]
    #[doc = "  or FLAC__stream_encoder_process_interleaved()."]
    #[doc = "  initialization succeeded."]
    #[doc = ""]
    #[doc = "  The call to FLAC__stream_encoder_init_stream() currently will also"]
    #[doc = "  immediately call the write callback several times, once with the \\c fLaC"]
    #[doc = "  signature, and once for each encoded metadata block."]
    #[doc = ""]
    #[doc = " \\param  encoder            An uninitialized encoder instance."]
    #[doc = " \\param  write_callback     See FLAC__StreamEncoderWriteCallback.  This"]
    #[doc = "                            pointer must not be \\c NULL."]
    #[doc = " \\param  seek_callback      See FLAC__StreamEncoderSeekCallback.  This"]
    #[doc = "                            pointer may be \\c NULL if seeking is not"]
    #[doc = "                            supported.  The encoder uses seeking to go back"]
    #[doc = "                            and write some some stream statistics to the"]
    #[doc = "                            STREAMINFO block; this is recommended but not"]
    #[doc = "                            necessary to create a valid FLAC stream.  If"]
    #[doc = "                            \\a seek_callback is not \\c NULL then a"]
    #[doc = "                            \\a tell_callback must also be supplied."]
    #[doc = "                            Alternatively, a dummy seek callback that just"]
    #[doc = "                            returns \\c FLAC__STREAM_ENCODER_SEEK_STATUS_UNSUPPORTED"]
    #[doc = "                            may also be supplied, all though this is slightly"]
    #[doc = "                            less efficient for the encoder."]
    #[doc = " \\param  tell_callback      See FLAC__StreamEncoderTellCallback.  This"]
    #[doc = "                            pointer may be \\c NULL if seeking is not"]
    #[doc = "                            supported.  If \\a seek_callback is \\c NULL then"]
    #[doc = "                            this argument will be ignored.  If"]
    #[doc = "                            \\a seek_callback is not \\c NULL then a"]
    #[doc = "                            \\a tell_callback must also be supplied."]
    #[doc = "                            Alternatively, a dummy tell callback that just"]
    #[doc = "                            returns \\c FLAC__STREAM_ENCODER_TELL_STATUS_UNSUPPORTED"]
    #[doc = "                            may also be supplied, all though this is slightly"]
    #[doc = "                            less efficient for the encoder."]
    #[doc = " \\param  metadata_callback  See FLAC__StreamEncoderMetadataCallback.  This"]
    #[doc = "                            pointer may be \\c NULL if the callback is not"]
    #[doc = "                            desired.  If the client provides a seek callback,"]
    #[doc = "                            this function is not necessary as the encoder"]
    #[doc = "                            will automatically seek back and update the"]
    #[doc = "                            STREAMINFO block.  It may also be \\c NULL if the"]
    #[doc = "                            client does not support seeking, since it will"]
    #[doc = "                            have no way of going back to update the"]
    #[doc = "                            STREAMINFO.  However the client can still supply"]
    #[doc = "                            a callback if it would like to know the details"]
    #[doc = "                            from the STREAMINFO."]
    #[doc = " \\param  client_data        This value will be supplied to callbacks in their"]
    #[doc = "                            \\a client_data argument."]
    #[doc = " \\assert"]
    #[doc = "    \\code encoder != NULL \\endcode"]
    #[doc = " \\retval FLAC__StreamEncoderInitStatus"]
    #[doc = "    \\c FLAC__STREAM_ENCODER_INIT_STATUS_OK if initialization was successful;"]
    #[doc = "    see FLAC__StreamEncoderInitStatus for the meanings of other return values."]
    pub fn FLAC__stream_encoder_init_stream(
        encoder: *mut FLAC__StreamEncoder,
        write_callback: FLAC__StreamEncoderWriteCallback,
        seek_callback: FLAC__StreamEncoderSeekCallback,
        tell_callback: FLAC__StreamEncoderTellCallback,
        metadata_callback: FLAC__StreamEncoderMetadataCallback,
        client_data: *mut ::std::os::raw::c_void,
    ) -> FLAC__StreamEncoderInitStatus;
}
extern "C" {
    #[doc = " Initialize the encoder instance to encode Ogg FLAC streams."]
    #[doc = ""]
    #[doc = "  This flavor of initialization sets up the encoder to encode to a FLAC"]
    #[doc = "  stream in an Ogg container.  I/O is performed via callbacks to the"]
    #[doc = "  client.  For encoding to a plain file via filename or open \\c FILE*,"]
    #[doc = "  FLAC__stream_encoder_init_ogg_file() and FLAC__stream_encoder_init_ogg_FILE()"]
    #[doc = "  provide a simpler interface."]
    #[doc = ""]
    #[doc = "  This function should be called after FLAC__stream_encoder_new() and"]
    #[doc = "  FLAC__stream_encoder_set_*() but before FLAC__stream_encoder_process()"]
    #[doc = "  or FLAC__stream_encoder_process_interleaved()."]
    #[doc = "  initialization succeeded."]
    #[doc = ""]
    #[doc = "  The call to FLAC__stream_encoder_init_ogg_stream() currently will also"]
    #[doc = "  immediately call the write callback several times to write the metadata"]
    #[doc = "  packets."]
    #[doc = ""]
    #[doc = " \\param  encoder            An uninitialized encoder instance."]
    #[doc = " \\param  read_callback      See FLAC__StreamEncoderReadCallback.  This"]
    #[doc = "                            pointer must not be \\c NULL if \\a seek_callback"]
    #[doc = "                            is non-NULL since they are both needed to be"]
    #[doc = "                            able to write data back to the Ogg FLAC stream"]
    #[doc = "                            in the post-encode phase."]
    #[doc = " \\param  write_callback     See FLAC__StreamEncoderWriteCallback.  This"]
    #[doc = "                            pointer must not be \\c NULL."]
    #[doc = " \\param  seek_callback      See FLAC__StreamEncoderSeekCallback.  This"]
    #[doc = "                            pointer may be \\c NULL if seeking is not"]
    #[doc = "                            supported.  The encoder uses seeking to go back"]
    #[doc = "                            and write some some stream statistics to the"]
    #[doc = "                            STREAMINFO block; this is recommended but not"]
    #[doc = "                            necessary to create a valid FLAC stream.  If"]
    #[doc = "                            \\a seek_callback is not \\c NULL then a"]
    #[doc = "                            \\a tell_callback must also be supplied."]
    #[doc = "                            Alternatively, a dummy seek callback that just"]
    #[doc = "                            returns \\c FLAC__STREAM_ENCODER_SEEK_STATUS_UNSUPPORTED"]
    #[doc = "                            may also be supplied, all though this is slightly"]
    #[doc = "                            less efficient for the encoder."]
    #[doc = " \\param  tell_callback      See FLAC__StreamEncoderTellCallback.  This"]
    #[doc = "                            pointer may be \\c NULL if seeking is not"]
    #[doc = "                            supported.  If \\a seek_callback is \\c NULL then"]
    #[doc = "                            this argument will be ignored.  If"]
    #[doc = "                            \\a seek_callback is not \\c NULL then a"]
    #[doc = "                            \\a tell_callback must also be supplied."]
    #[doc = "                            Alternatively, a dummy tell callback that just"]
    #[doc = "                            returns \\c FLAC__STREAM_ENCODER_TELL_STATUS_UNSUPPORTED"]
    #[doc = "                            may also be supplied, all though this is slightly"]
    #[doc = "                            less efficient for the encoder."]
    #[doc = " \\param  metadata_callback  See FLAC__StreamEncoderMetadataCallback.  This"]
    #[doc = "                            pointer may be \\c NULL if the callback is not"]
    #[doc = "                            desired.  If the client provides a seek callback,"]
    #[doc = "                            this function is not necessary as the encoder"]
    #[doc = "                            will automatically seek back and update the"]
    #[doc = "                            STREAMINFO block.  It may also be \\c NULL if the"]
    #[doc = "                            client does not support seeking, since it will"]
    #[doc = "                            have no way of going back to update the"]
    #[doc = "                            STREAMINFO.  However the client can still supply"]
    #[doc = "                            a callback if it would like to know the details"]
    #[doc = "                            from the STREAMINFO."]
    #[doc = " \\param  client_data        This value will be supplied to callbacks in their"]
    #[doc = "                            \\a client_data argument."]
    #[doc = " \\assert"]
    #[doc = "    \\code encoder != NULL \\endcode"]
    #[doc = " \\retval FLAC__StreamEncoderInitStatus"]
    #[doc = "    \\c FLAC__STREAM_ENCODER_INIT_STATUS_OK if initialization was successful;"]
    #[doc = "    see FLAC__StreamEncoderInitStatus for the meanings of other return values."]
    pub fn FLAC__stream_encoder_init_ogg_stream(
        encoder: *mut FLAC__StreamEncoder,
        read_callback: FLAC__StreamEncoderReadCallback,
        write_callback: FLAC__StreamEncoderWriteCallback,
        seek_callback: FLAC__StreamEncoderSeekCallback,
        tell_callback: FLAC__StreamEncoderTellCallback,
        metadata_callback: FLAC__StreamEncoderMetadataCallback,
        client_data: *mut ::std::os::raw::c_void,
    ) -> FLAC__StreamEncoderInitStatus;
}
extern "C" {
    #[doc = " Initialize the encoder instance to encode native FLAC files."]
    #[doc = ""]
    #[doc = "  This flavor of initialization sets up the encoder to encode to a"]
    #[doc = "  plain native FLAC file.  For non-stdio streams, you must use"]
    #[doc = "  FLAC__stream_encoder_init_stream() and provide callbacks for the I/O."]
    #[doc = ""]
    #[doc = "  This function should be called after FLAC__stream_encoder_new() and"]
    #[doc = "  FLAC__stream_encoder_set_*() but before FLAC__stream_encoder_process()"]
    #[doc = "  or FLAC__stream_encoder_process_interleaved()."]
    #[doc = "  initialization succeeded."]
    #[doc = ""]
    #[doc = " \\param  encoder            An uninitialized encoder instance."]
    #[doc = " \\param  file               An open file.  The file should have been opened"]
    #[doc = "                            with mode \\c \"w+b\" and rewound.  The file"]
    #[doc = "                            becomes owned by the encoder and should not be"]
    #[doc = "                            manipulated by the client while encoding."]
    #[doc = "                            Unless \\a file is \\c stdout, it will be closed"]
    #[doc = "                            when FLAC__stream_encoder_finish() is called."]
    #[doc = "                            Note however that a proper SEEKTABLE cannot be"]
    #[doc = "                            created when encoding to \\c stdout since it is"]
    #[doc = "                            not seekable."]
    #[doc = " \\param  progress_callback  See FLAC__StreamEncoderProgressCallback.  This"]
    #[doc = "                            pointer may be \\c NULL if the callback is not"]
    #[doc = "                            desired."]
    #[doc = " \\param  client_data        This value will be supplied to callbacks in their"]
    #[doc = "                            \\a client_data argument."]
    #[doc = " \\assert"]
    #[doc = "    \\code encoder != NULL \\endcode"]
    #[doc = "    \\code file != NULL \\endcode"]
    #[doc = " \\retval FLAC__StreamEncoderInitStatus"]
    #[doc = "    \\c FLAC__STREAM_ENCODER_INIT_STATUS_OK if initialization was successful;"]
    #[doc = "    see FLAC__StreamEncoderInitStatus for the meanings of other return values."]
    pub fn FLAC__stream_encoder_init_FILE(
        encoder: *mut FLAC__StreamEncoder,
        file: *mut FILE,
        progress_callback: FLAC__StreamEncoderProgressCallback,
        client_data: *mut ::std::os::raw::c_void,
    ) -> FLAC__StreamEncoderInitStatus;
}
extern "C" {
    #[doc = " Initialize the encoder instance to encode Ogg FLAC files."]
    #[doc = ""]
    #[doc = "  This flavor of initialization sets up the encoder to encode to a"]
    #[doc = "  plain Ogg FLAC file.  For non-stdio streams, you must use"]
    #[doc = "  FLAC__stream_encoder_init_ogg_stream() and provide callbacks for the I/O."]
    #[doc = ""]
    #[doc = "  This function should be called after FLAC__stream_encoder_new() and"]
    #[doc = "  FLAC__stream_encoder_set_*() but before FLAC__stream_encoder_process()"]
    #[doc = "  or FLAC__stream_encoder_process_interleaved()."]
    #[doc = "  initialization succeeded."]
    #[doc = ""]
    #[doc = " \\param  encoder            An uninitialized encoder instance."]
    #[doc = " \\param  file               An open file.  The file should have been opened"]
    #[doc = "                            with mode \\c \"w+b\" and rewound.  The file"]
    #[doc = "                            becomes owned by the encoder and should not be"]
    #[doc = "                            manipulated by the client while encoding."]
    #[doc = "                            Unless \\a file is \\c stdout, it will be closed"]
    #[doc = "                            when FLAC__stream_encoder_finish() is called."]
    #[doc = "                            Note however that a proper SEEKTABLE cannot be"]
    #[doc = "                            created when encoding to \\c stdout since it is"]
    #[doc = "                            not seekable."]
    #[doc = " \\param  progress_callback  See FLAC__StreamEncoderProgressCallback.  This"]
    #[doc = "                            pointer may be \\c NULL if the callback is not"]
    #[doc = "                            desired."]
    #[doc = " \\param  client_data        This value will be supplied to callbacks in their"]
    #[doc = "                            \\a client_data argument."]
    #[doc = " \\assert"]
    #[doc = "    \\code encoder != NULL \\endcode"]
    #[doc = "    \\code file != NULL \\endcode"]
    #[doc = " \\retval FLAC__StreamEncoderInitStatus"]
    #[doc = "    \\c FLAC__STREAM_ENCODER_INIT_STATUS_OK if initialization was successful;"]
    #[doc = "    see FLAC__StreamEncoderInitStatus for the meanings of other return values."]
    pub fn FLAC__stream_encoder_init_ogg_FILE(
        encoder: *mut FLAC__StreamEncoder,
        file: *mut FILE,
        progress_callback: FLAC__StreamEncoderProgressCallback,
        client_data: *mut ::std::os::raw::c_void,
    ) -> FLAC__StreamEncoderInitStatus;
}
extern "C" {
    #[doc = " Initialize the encoder instance to encode native FLAC files."]
    #[doc = ""]
    #[doc = "  This flavor of initialization sets up the encoder to encode to a plain"]
    #[doc = "  FLAC file.  If POSIX fopen() semantics are not sufficient (for example,"]
    #[doc = "  with Unicode filenames on Windows), you must use"]
    #[doc = "  FLAC__stream_encoder_init_FILE(), or FLAC__stream_encoder_init_stream()"]
    #[doc = "  and provide callbacks for the I/O."]
    #[doc = ""]
    #[doc = "  This function should be called after FLAC__stream_encoder_new() and"]
    #[doc = "  FLAC__stream_encoder_set_*() but before FLAC__stream_encoder_process()"]
    #[doc = "  or FLAC__stream_encoder_process_interleaved()."]
    #[doc = "  initialization succeeded."]
    #[doc = ""]
    #[doc = " \\param  encoder            An uninitialized encoder instance."]
    #[doc = " \\param  filename           The name of the file to encode to.  The file will"]
    #[doc = "                            be opened with fopen().  Use \\c NULL to encode to"]
    #[doc = "                            \\c stdout.  Note however that a proper SEEKTABLE"]
    #[doc = "                            cannot be created when encoding to \\c stdout since"]
    #[doc = "                            it is not seekable."]
    #[doc = " \\param  progress_callback  See FLAC__StreamEncoderProgressCallback.  This"]
    #[doc = "                            pointer may be \\c NULL if the callback is not"]
    #[doc = "                            desired."]
    #[doc = " \\param  client_data        This value will be supplied to callbacks in their"]
    #[doc = "                            \\a client_data argument."]
    #[doc = " \\assert"]
    #[doc = "    \\code encoder != NULL \\endcode"]
    #[doc = " \\retval FLAC__StreamEncoderInitStatus"]
    #[doc = "    \\c FLAC__STREAM_ENCODER_INIT_STATUS_OK if initialization was successful;"]
    #[doc = "    see FLAC__StreamEncoderInitStatus for the meanings of other return values."]
    pub fn FLAC__stream_encoder_init_file(
        encoder: *mut FLAC__StreamEncoder,
        filename: *const ::std::os::raw::c_char,
        progress_callback: FLAC__StreamEncoderProgressCallback,
        client_data: *mut ::std::os::raw::c_void,
    ) -> FLAC__StreamEncoderInitStatus;
}
extern "C" {
    #[doc = " Initialize the encoder instance to encode Ogg FLAC files."]
    #[doc = ""]
    #[doc = "  This flavor of initialization sets up the encoder to encode to a plain"]
    #[doc = "  Ogg FLAC file.  If POSIX fopen() semantics are not sufficient (for example,"]
    #[doc = "  with Unicode filenames on Windows), you must use"]
    #[doc = "  FLAC__stream_encoder_init_ogg_FILE(), or FLAC__stream_encoder_init_ogg_stream()"]
    #[doc = "  and provide callbacks for the I/O."]
    #[doc = ""]
    #[doc = "  This function should be called after FLAC__stream_encoder_new() and"]
    #[doc = "  FLAC__stream_encoder_set_*() but before FLAC__stream_encoder_process()"]
    #[doc = "  or FLAC__stream_encoder_process_interleaved()."]
    #[doc = "  initialization succeeded."]
    #[doc = ""]
    #[doc = " \\param  encoder            An uninitialized encoder instance."]
    #[doc = " \\param  filename           The name of the file to encode to.  The file will"]
    #[doc = "                            be opened with fopen().  Use \\c NULL to encode to"]
    #[doc = "                            \\c stdout.  Note however that a proper SEEKTABLE"]
    #[doc = "                            cannot be created when encoding to \\c stdout since"]
    #[doc = "                            it is not seekable."]
    #[doc = " \\param  progress_callback  See FLAC__StreamEncoderProgressCallback.  This"]
    #[doc = "                            pointer may be \\c NULL if the callback is not"]
    #[doc = "                            desired."]
    #[doc = " \\param  client_data        This value will be supplied to callbacks in their"]
    #[doc = "                            \\a client_data argument."]
    #[doc = " \\assert"]
    #[doc = "    \\code encoder != NULL \\endcode"]
    #[doc = " \\retval FLAC__StreamEncoderInitStatus"]
    #[doc = "    \\c FLAC__STREAM_ENCODER_INIT_STATUS_OK if initialization was successful;"]
    #[doc = "    see FLAC__StreamEncoderInitStatus for the meanings of other return values."]
    pub fn FLAC__stream_encoder_init_ogg_file(
        encoder: *mut FLAC__StreamEncoder,
        filename: *const ::std::os::raw::c_char,
        progress_callback: FLAC__StreamEncoderProgressCallback,
        client_data: *mut ::std::os::raw::c_void,
    ) -> FLAC__StreamEncoderInitStatus;
}
extern "C" {
    #[doc = " Finish the encoding process."]
    #[doc = "  Flushes the encoding buffer, releases resources, resets the encoder"]
    #[doc = "  settings to their defaults, and returns the encoder state to"]
    #[doc = "  FLAC__STREAM_ENCODER_UNINITIALIZED.  Note that this can generate"]
    #[doc = "  one or more write callbacks before returning, and will generate"]
    #[doc = "  a metadata callback."]
    #[doc = ""]
    #[doc = "  Note that in the course of processing the last frame, errors can"]
    #[doc = "  occur, so the caller should be sure to check the return value to"]
    #[doc = "  ensure the file was encoded properly."]
    #[doc = ""]
    #[doc = "  In the event of a prematurely-terminated encode, it is not strictly"]
    #[doc = "  necessary to call this immediately before FLAC__stream_encoder_delete()"]
    #[doc = "  but it is good practice to match every FLAC__stream_encoder_init_*()"]
    #[doc = "  with a FLAC__stream_encoder_finish()."]
    #[doc = ""]
    #[doc = " \\param  encoder  An uninitialized encoder instance."]
    #[doc = " \\assert"]
    #[doc = "    \\code encoder != NULL \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c false if an error occurred processing the last frame; or if verify"]
    #[doc = "    mode is set (see FLAC__stream_encoder_set_verify()), there was a"]
    #[doc = "    verify mismatch; else \\c true.  If \\c false, caller should check the"]
    #[doc = "    state with FLAC__stream_encoder_get_state() for more information"]
    #[doc = "    about the error."]
    pub fn FLAC__stream_encoder_finish(encoder: *mut FLAC__StreamEncoder) -> FLAC__bool;
}
extern "C" {
    #[doc = " Submit data for encoding."]
    #[doc = "  This version allows you to supply the input data via an array of"]
    #[doc = "  pointers, each pointer pointing to an array of \\a samples samples"]
    #[doc = "  representing one channel.  The samples need not be block-aligned,"]
    #[doc = "  but each channel should have the same number of samples.  Each sample"]
    #[doc = "  should be a signed integer, right-justified to the resolution set by"]
    #[doc = "  FLAC__stream_encoder_set_bits_per_sample().  For example, if the"]
    #[doc = "  resolution is 16 bits per sample, the samples should all be in the"]
    #[doc = "  range [-32768,32767]."]
    #[doc = ""]
    #[doc = "  For applications where channel order is important, channels must"]
    #[doc = "  follow the order as described in the"]
    #[doc = "  <A HREF=\"../format.html#frame_header\">frame header</A>."]
    #[doc = ""]
    #[doc = " \\param  encoder  An initialized encoder instance in the OK state."]
    #[doc = " \\param  buffer   An array of pointers to each channel\'s signal."]
    #[doc = " \\param  samples  The number of samples in one channel."]
    #[doc = " \\assert"]
    #[doc = "    \\code encoder != NULL \\endcode"]
    #[doc = "    \\code FLAC__stream_encoder_get_state(encoder) == FLAC__STREAM_ENCODER_OK \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c true if successful, else \\c false; in this case, check the"]
    #[doc = "    encoder state with FLAC__stream_encoder_get_state() to see what"]
    #[doc = "    went wrong."]
    pub fn FLAC__stream_encoder_process(
        encoder: *mut FLAC__StreamEncoder,
        buffer: *const *const FLAC__int32,
        samples: ::std::os::raw::c_uint,
    ) -> FLAC__bool;
}
extern "C" {
    #[doc = " Submit data for encoding."]
    #[doc = "  This version allows you to supply the input data where the channels"]
    #[doc = "  are interleaved into a single array (i.e. channel0_sample0,"]
    #[doc = "  channel1_sample0, ... , channelN_sample0, channel0_sample1, ...)."]
    #[doc = "  The samples need not be block-aligned but they must be"]
    #[doc = "  sample-aligned, i.e. the first value should be channel0_sample0"]
    #[doc = "  and the last value channelN_sampleM.  Each sample should be a signed"]
    #[doc = "  integer, right-justified to the resolution set by"]
    #[doc = "  FLAC__stream_encoder_set_bits_per_sample().  For example, if the"]
    #[doc = "  resolution is 16 bits per sample, the samples should all be in the"]
    #[doc = "  range [-32768,32767]."]
    #[doc = ""]
    #[doc = "  For applications where channel order is important, channels must"]
    #[doc = "  follow the order as described in the"]
    #[doc = "  <A HREF=\"../format.html#frame_header\">frame header</A>."]
    #[doc = ""]
    #[doc = " \\param  encoder  An initialized encoder instance in the OK state."]
    #[doc = " \\param  buffer   An array of channel-interleaved data (see above)."]
    #[doc = " \\param  samples  The number of samples in one channel, the same as for"]
    #[doc = "                  FLAC__stream_encoder_process().  For example, if"]
    #[doc = "                  encoding two channels, \\c 1000 \\a samples corresponds"]
    #[doc = "                  to a \\a buffer of 2000 values."]
    #[doc = " \\assert"]
    #[doc = "    \\code encoder != NULL \\endcode"]
    #[doc = "    \\code FLAC__stream_encoder_get_state(encoder) == FLAC__STREAM_ENCODER_OK \\endcode"]
    #[doc = " \\retval FLAC__bool"]
    #[doc = "    \\c true if successful, else \\c false; in this case, check the"]
    #[doc = "    encoder state with FLAC__stream_encoder_get_state() to see what"]
    #[doc = "    went wrong."]
    pub fn FLAC__stream_encoder_process_interleaved(
        encoder: *mut FLAC__StreamEncoder,
        buffer: *const FLAC__int32,
        samples: ::std::os::raw::c_uint,
    ) -> FLAC__bool;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
